<!DOCTYPE html>
<html lang=ch>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>创建和销毁对象 | Hesai&#39;s Blog</title>
  <meta name="description" content="创建和销毁对象何时以及如何创建对象 何时以及如何避免创建对象 如何确保对象能够适时销毁 如何管理对象销毁之前必须进行的各种清理动作 1用静态工厂方法替代构造器类可以提供一个静态工厂方法（static factory method），只用于返回一个类的实例的静态方法。 例如 123public static Boolean valueOf(boolean b)&amp;#123;	return b?Bool">
<meta property="og:type" content="article">
<meta property="og:title" content="创建和销毁对象">
<meta property="og:url" content="http://example.com/2021/03/28/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="Hesai&#39;s blog">
<meta property="og:description" content="创建和销毁对象何时以及如何创建对象 何时以及如何避免创建对象 如何确保对象能够适时销毁 如何管理对象销毁之前必须进行的各种清理动作 1用静态工厂方法替代构造器类可以提供一个静态工厂方法（static factory method），只用于返回一个类的实例的静态方法。 例如 123public static Boolean valueOf(boolean b)&amp;#123;	return b?Bool">
<meta property="og:locale">
<meta property="article:published_time" content="2021-03-28T15:05:16.515Z">
<meta property="article:modified_time" content="2021-03-28T15:40:37.261Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="tags">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://example.com/2021/03/28/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hesai&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/hs-jose" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">hs</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/hs-jose" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>记录知识</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E2%85%A0/">Java核心技术 Ⅰ</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E2%85%A1/">Java核心技术 Ⅱ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%85%A0-%E6%B7%BB%E5%8A%A0%E5%8D%9A%E6%96%87%E5%88%86%E7%B1%BB/">Java核心技术Ⅰ# 添加博文分类</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%85%A1/">Java核心技术Ⅱ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/effective-Java/">effective Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/">深入理解JVM</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/tags/" rel="tag">tags</a><span class="tag-list-count">13</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/tags/" style="font-size: 13px;">tags</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/">深入理解JVM</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/" class="title">Java内存区域与内存溢出异常</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:25.905Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/">深入理解JVM</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" class="title">垃圾收集器与内存分配策略</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:25.905Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/effective-Java/">effective Java</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%AF%B9%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/" class="title">通用方法</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:16.515Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/effective-Java/">effective Java</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/" class="title">创建和销毁对象</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:16.515Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%85%A0-%E6%B7%BB%E5%8A%A0%E5%8D%9A%E6%96%87%E5%88%86%E7%B1%BB/">Java核心技术Ⅰ# 添加博文分类</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/" class="title">异常、断言和日志</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:01.868Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">Catalogue</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">创建和销毁对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%9B%BF%E4%BB%A3%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">1用静态工厂方法替代构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text">优点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%A7%B0"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">有名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%BF%85%E5%9C%A8%E6%AF%8F%E6%AC%A1%E8%B0%83%E7%94%A8%E6%97%B6%E9%83%BD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">不必在每次调用时都创建一个新对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E8%BF%94%E5%9B%9E%E5%8E%9F%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%BB%E4%BD%95%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">可以返回原返回类型的任何子类型对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%8F%AF%E4%BB%A5%E9%9A%8F%E6%AF%8F%E6%AC%A1%E8%B0%83%E7%94%A8%E8%80%8C%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%EF%BC%8C%E5%8F%96%E5%86%B3%E4%BA%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">所返回的对象的类可以随每次调用而发生变化，取决于静态工厂方法的参数值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%80%E5%B1%9E%E7%9A%84%E7%B1%BB%EF%BC%8C%E5%9C%A8%E7%BC%96%E5%86%99%E8%AF%A5%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E7%B1%BB%E6%97%B6%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%AD%98%E5%9C%A8"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">返回的对象所属的类，在编写该静态工厂方法的类时可以不存在</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.2.</span> <span class="toc-text">缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%90%AB%E5%85%AC%E6%9C%89%E6%88%96%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%8C%E5%B0%B1%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%AD%90%E7%B1%BB%E5%8C%96"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">类如果不含公有或受保护的构造器，就不能被子类化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BE%88%E9%9A%BE%E5%8F%91%E7%8E%B0%E5%AE%83%E4%BB%AC"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">程序员很难发现它们</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E5%A4%9A%E4%B8%AA%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E6%97%B6%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E6%9E%84%E5%BB%BA%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">2多个构造器参数时考虑使用构建器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%8F%A0%E6%9E%84%E5%BB%BA%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">重叠构建器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaBean%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">JavaBean模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">建造者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.2.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E6%88%96%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%8C%96Singleton%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">3用私有构造器或枚举类型强化Singleton属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Singleton%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">实现Singleton的两种常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Singleton%E7%B1%BB%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.3.2.</span> <span class="toc-text">Singleton类的序列化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E9%80%9A%E8%BF%87%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%BA%E5%8C%96%E4%B8%8D%E5%8F%AF%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="toc-number">1.4.</span> <span class="toc-text">4通过私有构造器强化不可实例化的能力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%9D%A5%E5%BC%95%E7%94%A8%E8%B5%84%E6%BA%90"><span class="toc-number">1.5.</span> <span class="toc-text">5优先考虑依赖注入来引用资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number">1.5.1.</span> <span class="toc-text">依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%8F%98%E4%BD%93"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">依赖注入变体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">1.5.2.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.</span> <span class="toc-text">6避免创建不必要对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%83%85%E5%BD%A2"><span class="toc-number">1.6.1.</span> <span class="toc-text">一般情形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%83%85%E5%BD%A2"><span class="toc-number">1.6.2.</span> <span class="toc-text">适配器情形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E6%83%85%E5%BD%A2"><span class="toc-number">1.6.3.</span> <span class="toc-text">自动装箱情形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">1.6.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E6%B6%88%E9%99%A4%E8%BF%87%E6%9C%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.7.</span> <span class="toc-text">7消除过期对象的引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.1.</span> <span class="toc-text">修复方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%E5%88%86%E6%9E%90"><span class="toc-number">1.7.2.</span> <span class="toc-text">例子分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%9D%A5%E6%BA%90"><span class="toc-number">1.7.3.</span> <span class="toc-text">内存泄漏来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-number">1.7.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95%E5%92%8C%E6%B8%85%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.</span> <span class="toc-text">8避免使用终结方法和清除方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.1.</span> <span class="toc-text">解决方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95%E5%92%8C%E6%B8%85%E9%99%A4%E6%96%B9%E6%B3%95%E7%9A%84%E5%90%88%E6%B3%95%E7%94%A8%E9%80%94"><span class="toc-number">1.8.2.</span> <span class="toc-text">终结方法和清除方法的合法用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-number">1.8.3.</span> <span class="toc-text">清除方法使用技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-number">1.8.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9try-with-resources%E4%BC%98%E5%85%88%E4%BA%8Etry-finally"><span class="toc-number">1.9.</span> <span class="toc-text">9try-with-resources优先于try-finally</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-finally"><span class="toc-number">1.9.1.</span> <span class="toc-text">try-finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-with-resources"><span class="toc-number">1.9.2.</span> <span class="toc-text">try-with-resources</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="toc-number">1.9.3.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-创建和销毁对象" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      创建和销毁对象
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/28/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/" class="article-date">
	  <time datetime="2021-03-28T15:05:16.515Z" itemprop="datePublished">2021-03-28</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/effective-Java/">effective Java</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/tags/" rel="tag">tags</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/28/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/#comments" class="article-comment-link">Comments</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h1><p>何时以及如何创建对象</p>
<p>何时以及如何避免创建对象</p>
<p>如何确保对象能够适时销毁</p>
<p>如何管理对象销毁之前必须进行的各种清理动作</p>
<h2 id="1用静态工厂方法替代构造器"><a href="#1用静态工厂方法替代构造器" class="headerlink" title="1用静态工厂方法替代构造器"></a>1用静态工厂方法替代构造器</h2><p>类可以提供一个静态工厂方法（static factory method），只用于返回一个类的实例的静态方法。</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b?Boolean.TRUE:Boolean.FALSE;</span><br><span class="line">&#125;<span class="comment">//boolean基本类型值转换为Boolean对象引用</span></span><br></pre></td></tr></table></figure>

<p>提供静态工厂方法而不是公共构造器</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>相较于构造器，静态工厂方法</strong></p>
<h4 id="有名称"><a href="#有名称" class="headerlink" title="有名称"></a>有名称</h4><ul>
<li><strong>代码更易读</strong>。如果构造器参数没有确切描述被返回对象，具有适当名称的静态工厂方法会更易用，客户端代码更可读。</li>
<li>适用一个类需要多个带有相同签名的构造器时，使用静态工厂方法代替构造器，选择名称突出区别。</li>
</ul>
<h4 id="不必在每次调用时都创建一个新对象"><a href="#不必在每次调用时都创建一个新对象" class="headerlink" title="不必在每次调用时都创建一个新对象"></a>不必在每次调用时都创建一个新对象</h4><ul>
<li><p><strong>避免创建不必要重复对象。</strong>使得不可变类（）可使用预先构建好的实例或缓存实例重复利用。如<code>Boolean.valueOf(boolean b)</code></p>
</li>
<li><p>它能为重复调用返回相同对象，有助于类总能严格控制某时刻哪些类应存在（实例受控类 instance-controlled）</p>
<p>实例受控</p>
<ul>
<li>可以确保他是一个Singleton或者是不可实例化的</li>
<li>确保不可变的值类，不会存在两个相等实例（a==b &lt;=&gt; a.equals(b)）。享元模式的基础</li>
</ul>
</li>
</ul>
<h4 id="可以返回原返回类型的任何子类型对象"><a href="#可以返回原返回类型的任何子类型对象" class="headerlink" title="可以返回原返回类型的任何子类型对象"></a>可以返回原返回类型的任何子类型对象</h4><ul>
<li>选择返回对象时更灵活<ul>
<li>应用API可以返回对象，同时不会使对象的类变为私有，隐藏实现类，使API简洁。适用于基于接口的框架（interface-based framework）</li>
<li>java 8之前，接口不能有静态方法。接口Type的静态工厂方法放在不可实例化的伴生类Types中。如Collections提供同步集合，不可修改集合等，所返回的对象都是非公有的。</li>
<li><strong>使用接口来引用被返回的对象，而不是通过它的实现类（好习惯）</strong></li>
<li>java 8之后接口中能包含静态方法，但是仍有必要将这些静态方法背后的大部分实现代码单独放进一个包级私有的类中。因为java 8 要求接口所有静态成员必须公有。java 9 允许接口有私有静态方法，但静态域和静态成员类公有。</li>
</ul>
</li>
</ul>
<h4 id="所返回的对象的类可以随每次调用而发生变化，取决于静态工厂方法的参数值"><a href="#所返回的对象的类可以随每次调用而发生变化，取决于静态工厂方法的参数值" class="headerlink" title="所返回的对象的类可以随每次调用而发生变化，取决于静态工厂方法的参数值"></a>所返回的对象的类可以随每次调用而发生变化，取决于静态工厂方法的参数值</h4><ul>
<li><p>已声明返回类型的子类型，都是允许的。返回对象的类也可能随发行版本改变</p>
<ul>
<li><p>EnumSet无公共构造器，只有静态工厂方法。OpenJDK实现中，返回两种子类之一的一个实例，具体取决于底层枚举类型大小。</p>
<ul>
<li>枚举类型&lt;=64个，静态工厂返回RegalarEnumSet，单个long</li>
<li>枚举类型 &gt; 64个，静态工厂返回JumboEnumSet，long数组</li>
</ul>
<p>后续也肯能删除，增加某个实现类，但不会造成负面影响</p>
</li>
</ul>
</li>
</ul>
<h4 id="返回的对象所属的类，在编写该静态工厂方法的类时可以不存在"><a href="#返回的对象所属的类，在编写该静态工厂方法的类时可以不存在" class="headerlink" title="返回的对象所属的类，在编写该静态工厂方法的类时可以不存在"></a>返回的对象所属的类，在编写该静态工厂方法的类时可以不存在</h4><ul>
<li>灵活的静态工厂方法构成<strong>服务提供者框架（Service Provider Framework）</strong>的基础。<ul>
<li>例如JDBC API</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>服务提供者框架（Service Provider Framework）</strong>指一个系统，多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并将它们从多个实现中解耦</p>
<p>三个重要组件</p>
<ul>
<li>服务接口（Service Interface）：由提供者实现</li>
<li>提供者注册API（Provider Registration API）：提供者用来注册实现</li>
<li>服务访问API（Service Access API）：客户端获取服务实例“灵活的静态工厂”，服务提供者框架基础</li>
<li>服务提供者接口（Service Provider Interface）：可选，表示产生服务接口实例的工厂对象，没有这个，则通过反射实例化</li>
</ul>
</blockquote>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>静态工厂方法的主要缺点在于</p>
<h4 id="类如果不含公有或受保护的构造器，就不能被子类化"><a href="#类如果不含公有或受保护的构造器，就不能被子类化" class="headerlink" title="类如果不含公有或受保护的构造器，就不能被子类化"></a>类如果不含公有或受保护的构造器，就不能被子类化</h4><p>例如想将Collections Framework中任何便利的实现类子类化，是不可能的</p>
<p>它鼓励程序员使用复合（composition），而不是继承，这是不可变类型需要的</p>
<h4 id="程序员很难发现它们"><a href="#程序员很难发现它们" class="headerlink" title="程序员很难发现它们"></a>程序员很难发现它们</h4><p>它们没有像构造器一样，在API文档中明确标识出来，对于提供静态工厂方法而不是构造器的类，要查明如何实例化比较困难。</p>
<p>建议</p>
<ul>
<li>在类或接口注释中关注静态工厂</li>
<li>遵守标准命名习惯</li>
</ul>
<p>常用静态工厂方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>from</td>
<td>类型转换方法，单个参数，返回该类型对应实例</td>
<td><code>Date d = Date.from(instant);</code></td>
</tr>
<tr>
<td>of</td>
<td>聚合方法，多个参数，返回该类型一个实例，把他们合并</td>
<td><code>Set&lt;Rank&gt; faceCards = EnumSet.of(JACK,QUEEN,KING);</code></td>
</tr>
<tr>
<td>valueOf</td>
<td>比form和of跟繁琐的替代方法</td>
<td><code>BigInteger.valueOf(Integer.MAX_VALUE);</code></td>
</tr>
<tr>
<td>instance/getInstance</td>
<td>返回的实例通过方法参数（如有）描述，但是不能说与具体参数具有相同值</td>
<td><code>StackWalker luck = StackWalker.getInstance(options)</code></td>
</tr>
<tr>
<td>create/newInstance</td>
<td>与上一条类似，但是能确保每次调用返回一个新实例</td>
<td><code>Object arr = Array.newInstance(classObject.arrayLen)</code></td>
</tr>
<tr>
<td>get<em>Type</em></td>
<td>类似getInstance，在工厂方法处于不同的类中使用，<em>Type</em>表示工厂方法返回的对象类型</td>
<td><code>FileStore fs = Files.getFileStore(path);</code></td>
</tr>
<tr>
<td>new<em>Type</em></td>
<td>类似newInstance，但是在工厂方法处于不用的类中的时候使用，<code>Type</code>表示工厂方法返回的对象类型</td>
<td><code>BufferedReader br = Files.newBufferedReader(path);</code></td>
</tr>
<tr>
<td><em>type</em></td>
<td>get<em>Type</em>和new<em>Type</em>的简版</td>
<td><code>List&lt;Complaint&gt; litany = Collections.list(legacyLitancy);</code></td>
</tr>
</tbody></table>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>静态工厂方法和构造器各有用处，通常静态工厂更加适合。切忌第一反应使用公共构造器。</p>
<h2 id="2多个构造器参数时考虑使用构建器"><a href="#2多个构造器参数时考虑使用构建器" class="headerlink" title="2多个构造器参数时考虑使用构建器"></a>2多个构造器参数时考虑使用构建器</h2><p>静态工厂和构造器都有共同的局限性：<strong>不能很好的扩展大量可选参数</strong></p>
<p>一般可以采用 重叠构建器模式(telescoping constructor)、JavaBean模式、建造者模式。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>重叠构造器模式</td>
<td>形式简单</td>
<td>容易出错，参数表太长不容易控制，而且难以阅读</td>
</tr>
<tr>
<td>javaBean模式</td>
<td>容易阅读，创建实例比较容易</td>
<td>构造过程被分割到好多个set中容易造成线程不安全，导致对象处于不一致的状态</td>
</tr>
<tr>
<td>Builder模式</td>
<td>代码容易编写</td>
<td>创建对象，必须先创造构建器，造成一定的性能上的开销</td>
</tr>
</tbody></table>
<h3 id="重叠构建器模式"><a href="#重叠构建器模式" class="headerlink" title="重叠构建器模式"></a>重叠构建器模式</h3><p>重叠构造器模式可行，但是参数增多时，客户端代码难以编写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass1</span></span>&#123;</span><br><span class="line">    <span class="comment">//必要的参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> one;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> two;</span><br><span class="line">    <span class="comment">//可选的参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> three;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> four;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> five;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> six;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass1</span><span class="params">(<span class="keyword">int</span> one,<span class="keyword">int</span> two)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(one,two,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass1</span><span class="params">(<span class="keyword">int</span> one,<span class="keyword">int</span> two,<span class="keyword">int</span> three)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(one,two,three,<span class="number">0</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass1</span><span class="params">(<span class="keyword">int</span> one,<span class="keyword">int</span> two,<span class="keyword">int</span> three,<span class="keyword">int</span> four)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(one,two,three,four,<span class="number">0</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass1</span><span class="params">(<span class="keyword">int</span> one,<span class="keyword">int</span> two,<span class="keyword">int</span> three,<span class="keyword">int</span> four,<span class="keyword">int</span> five)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(one,two,three,four,five,<span class="number">0</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass1</span><span class="params">(<span class="keyword">int</span> one,<span class="keyword">int</span> two,<span class="keyword">int</span> three,<span class="keyword">int</span> four,<span class="keyword">int</span> five,<span class="keyword">int</span> six)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.one=one;</span><br><span class="line">        <span class="keyword">this</span>.two=two;</span><br><span class="line">        <span class="keyword">this</span>.three=three;</span><br><span class="line">        <span class="keyword">this</span>.four=four;</span><br><span class="line">        <span class="keyword">this</span>.five=five;</span><br><span class="line">        <span class="keyword">this</span>.six=six;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; one=&quot;</span>+<span class="keyword">this</span>.one+<span class="string">&quot; two=&quot;</span>+<span class="keyword">this</span>.two+<span class="string">&quot; three=&quot;</span>+<span class="keyword">this</span>.three+<span class="string">&quot; four=&quot;</span>+<span class="keyword">this</span>.four+<span class="string">&quot; five=&quot;</span>+<span class="keyword">this</span>.five+<span class="string">&quot; six=&quot;</span>+<span class="keyword">this</span>.six;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBuilderMain</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化MyClass1</span></span><br><span class="line">        MyClass1 myclass1=<span class="keyword">new</span> MyClass1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">        System.out.println(myclass1.toString());</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JavaBean模式"><a href="#JavaBean模式" class="headerlink" title="JavaBean模式"></a>JavaBean模式</h3><p>这种模式先调用一个无参构造器，然后调用setter方法设置每个参数。，弥补了重叠构造器模式不足。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>在构造过程中，JavaBean可能处于不一致状态。类无法同各国检验构造器参数有效性来保证一致性。</li>
<li>JavaBean模式，不可以把类做成不可变。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span></span>&#123;</span><br><span class="line">    <span class="comment">//必要的参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> one=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> two=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//可选的参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> three=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> four=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> five=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> six=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOne</span><span class="params">(<span class="keyword">int</span> one)</span></span>&#123;<span class="keyword">this</span>.one=one;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTwo</span><span class="params">(<span class="keyword">int</span> two)</span></span>&#123;<span class="keyword">this</span>.two=two;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setThree</span><span class="params">(<span class="keyword">int</span> three)</span></span>&#123;<span class="keyword">this</span>.three=three;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFour</span><span class="params">(<span class="keyword">int</span> four)</span></span>&#123;<span class="keyword">this</span>.four=four;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFive</span><span class="params">(<span class="keyword">int</span> five)</span></span>&#123;<span class="keyword">this</span>.five=five;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSix</span><span class="params">(<span class="keyword">int</span> six)</span></span>&#123;<span class="keyword">this</span>.six=six;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; one=&quot;</span>+<span class="keyword">this</span>.one+<span class="string">&quot; two=&quot;</span>+<span class="keyword">this</span>.two+<span class="string">&quot; three=&quot;</span>+<span class="keyword">this</span>.three+<span class="string">&quot; four=&quot;</span>+<span class="keyword">this</span>.four+<span class="string">&quot; five=&quot;</span>+<span class="keyword">this</span>.five+<span class="string">&quot; six=&quot;</span>+<span class="keyword">this</span>.six;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBuilderMain</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//初始化MyClass2</span></span><br><span class="line">        MyClass2 myclass2=<span class="keyword">new</span> MyClass2();</span><br><span class="line">        myclass2.setOne(<span class="number">1</span>);</span><br><span class="line">        myclass2.setTwo(<span class="number">2</span>);</span><br><span class="line">        myclass2.setThree(<span class="number">3</span>);</span><br><span class="line">        myclass2.setFour(<span class="number">4</span>);</span><br><span class="line">        myclass2.setFive(<span class="number">5</span>);</span><br><span class="line">        myclass2.setSix(<span class="number">6</span>);</span><br><span class="line">        System.out.println(myclass2.toString());</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>既能保证重叠构造器的安全性，也具有JavaBean模式的可读性。</p>
<p><strong>通过builder的设值方法返回builder本身，可以将调用链接起来，得到一个流式API。模拟了具名的可选参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass3</span></span>&#123;</span><br><span class="line">    <span class="comment">//必要的参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> one;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> two;</span><br><span class="line">    <span class="comment">//可选的参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> three;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> four;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> five;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> six;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;<span class="comment">//静态内部类，也可以使用外部类，</span></span><br><span class="line">        <span class="comment">//必要的参数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> one;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> two;</span><br><span class="line">        <span class="comment">//可选的参数</span></span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">int</span> three=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">int</span> four=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">int</span> five=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">int</span> six=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> one,<span class="keyword">int</span> two)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.one=one;</span><br><span class="line">            <span class="keyword">this</span>.two=two;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">Three</span><span class="params">(<span class="keyword">int</span> three)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.three=three;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//每次返回当前对象，以便后面继续调用更多初始化方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">Four</span><span class="params">(<span class="keyword">int</span> four)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.four=four;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//每次返回当前对象，以便后面继续调用更多初始化方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">Five</span><span class="params">(<span class="keyword">int</span> five)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.five=five;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//每次返回当前对象，以便后面继续调用更多初始化方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">Six</span><span class="params">(<span class="keyword">int</span> six)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.six=six;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//每次返回当前对象，以便后面继续调用更多初始化方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> MyClass3 <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyClass3(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyClass3</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.one=builder.one;</span><br><span class="line">        <span class="keyword">this</span>.two=builder.two;</span><br><span class="line">        <span class="keyword">this</span>.three=builder.three;</span><br><span class="line">        <span class="keyword">this</span>.four=builder.four;</span><br><span class="line">        <span class="keyword">this</span>.five=builder.five;</span><br><span class="line">        <span class="keyword">this</span>.six=builder.six;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; one=&quot;</span>+<span class="keyword">this</span>.one+<span class="string">&quot; two=&quot;</span>+<span class="keyword">this</span>.two+<span class="string">&quot; three=&quot;</span>+<span class="keyword">this</span>.three+<span class="string">&quot; four=&quot;</span>+<span class="keyword">this</span>.four+<span class="string">&quot; five=&quot;</span>+<span class="keyword">this</span>.five+<span class="string">&quot; six=&quot;</span>+<span class="keyword">this</span>.six;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBuilderMain</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化MyClass3</span></span><br><span class="line">        MyClass3 myclass3=<span class="keyword">new</span> MyClass3.Builder(<span class="number">1</span>,<span class="number">2</span>).Three(<span class="number">3</span>).Four(<span class="number">4</span>).Five(<span class="number">5</span>).Six(<span class="number">6</span>).build();</span><br><span class="line">        System.out.println(myclass3.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Builder模式也适用于类层次结构</p>
<p>使用平行层次结构的builder时，各自嵌套在相应类中。</p>
<p>抽象类有抽象的builder，具体类有具体的builder。</p>
<blockquote>
<p><strong>模拟self类型（simulated self-type）</strong></p>
<p><code>Pizzz.Builder</code>是泛型，他和抽象self方法一样，允许子类适当的进行方法链接，不需要转换类型。针对java缺少self类型的解决方案。</p>
<p>self方法相当于返回this</p>
<p>注意每个子类构造器build方法都声明返回正确的子类。子类方法声明返回超类声明返回类型的子类，称为<strong>协变返回类型（covarian return type）</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Topping</span> </span>&#123;HAM, MUSHROOM, ONION, PEPPER, SAUSAGE&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Set&lt;Topping&gt; toppings;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Builder</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">addTopping</span><span class="params">(Topping topping)</span> </span>&#123;</span><br><span class="line">            toppings.add(Objects.requireNonNull(topping));</span><br><span class="line">            <span class="keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> Pizza <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Subclasses must override this method to return &quot;this&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">self</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pizza(Builder&lt;?&gt; builder) &#123;</span><br><span class="line">        toppings = builder.toppings.clone(); <span class="comment">// See Item 50</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NyPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Size</span> </span>&#123; SMALL, MEDIUM, LARGE &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">Pizza</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Size size)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.size = Objects.requireNonNull(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> NyPizza <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NyPizza(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Builder <span class="title">self</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NyPizza</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(builder);</span><br><span class="line">        size = builder.size;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>builder优点</p>
<ul>
<li>与构造器相比，他又多个可变（varags）参数。因为builder单独利用方法来设置每一个参数。</li>
<li>可以利用单个builder创建多个对象，也可以对创建期的对象通过build方法进行调整，也可以随不同对象改变，十分灵活</li>
<li>builder可以自动填充某些域</li>
</ul>
<p>缺点</p>
<ul>
<li>为创建对象，必须创建对象的构建器，在注重性能的情况下，造成开销。</li>
<li>代码冗长，所以在参数很多时才使用。</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>构造器或静态工厂具有多个参数，设计这种类时，考虑使用Builder模式</p>
<h2 id="3用私有构造器或枚举类型强化Singleton属性"><a href="#3用私有构造器或枚举类型强化Singleton属性" class="headerlink" title="3用私有构造器或枚举类型强化Singleton属性"></a>3用私有构造器或枚举类型强化Singleton属性</h2><p>Singleton即单例类，只被实例化一次。</p>
<p>Singleton常用来代表一个无状态对象（函数，本质上唯一的系统组件）</p>
<p>Singleton的客户端测试很困难。</p>
<h3 id="实现Singleton的两种常用方法"><a href="#实现Singleton的两种常用方法" class="headerlink" title="实现Singleton的两种常用方法"></a>实现Singleton的两种常用方法</h3><p>两种方法都需要保持构造器私有，并导出静态公有成员</p>
<p><strong>公有域方法</strong></p>
<p>私有构造器仅被调用一次，用来实例化公有的静态final域的字段 如下的<code>Elvis.INSTANCE</code>。私有构造器保证了Elvis的全局唯一性</p>
<blockquote>
<p>注意</p>
<p>享有特权的客户端可以借助<code>AccessibleObject.setAccessible</code>方法，通过反射机制调用私有构造器。</p>
<p>可以修改构造器在创建第二个实例时抛出异常。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public final field</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点</p>
<ul>
<li>公有域是final，该域总是包含相同对象引用</li>
<li>相比之下更简单</li>
</ul>
<p><strong>静态工厂方法</strong></p>
<p>静态方法<code>Elvis.getInstance</code>的调用都返回同一个对象引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//static factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点</p>
<ul>
<li>提供灵活性：不改变API，可以改变该类是否应为Singleton</li>
<li>可以编写泛型Singleton工厂（tip 30）</li>
<li>可以通过方法引用作为提供者。如<strong>Elvis::instance</strong>就是一个<strong>Supplier<Elvis></strong></li>
</ul>
<p><strong>除非满足以上任何一种优势，否则还是优先考虑公有域方法</strong></p>
<p><strong>枚举方法</strong></p>
<p>声明一个包含单个元素的枚举类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Enum singLeton -preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Elvis</span></span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点</p>
<p>这种方法与公有域方法类似，</p>
<ul>
<li>更简洁，无偿提供了序列化机制，绝对防止多次实例化（即使面对复杂的序列化或反射攻击）</li>
</ul>
<p>单元素枚举类型经常成为实现Singleton的最佳实现方法。</p>
<p>缺点</p>
<ul>
<li>如果Singleton必须扩展一个超类，而不是扩展Enum时，不宜使用（虽然可以声明枚举实现接口）</li>
</ul>
<h3 id="Singleton类的序列化"><a href="#Singleton类的序列化" class="headerlink" title="Singleton类的序列化"></a>Singleton类的序列化</h3><p>将上述两种方法实现的Singleton类变成可序列化 Serializable，</p>
<ul>
<li><p>仅在声明中加上<code>implement.Serializable</code>还不够</p>
</li>
<li><p>为维护并保证Singleton，必须声明所有实例域都是<strong>瞬时（transinet）</strong>的</p>
</li>
<li><p>并提供一个readReslove方法（tip 89）</p>
<ul>
<li><p>否则每次反序列化一个序列化时，都会创建一个新实例。</p>
</li>
<li><p>readReslove 例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//readReslove method to preserve singleton property</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readReslove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//返回唯一Elvis实例 和 让垃圾收集器管理Elvis扮演者</span></span><br><span class="line">	<span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>也可通过枚举方法实现Singleton</p>
<h2 id="4通过私有构造器强化不可实例化的能力"><a href="#4通过私有构造器强化不可实例化的能力" class="headerlink" title="4通过私有构造器强化不可实例化的能力"></a>4通过私有构造器强化不可实例化的能力</h2><p>一些只包含静态方法和静态域的类比如</p>
<ul>
<li><p><code>java.lang.Math</code>和<code>java.util.Arrays</code></p>
<p>用于将基本类型的值或数组类型上的相关方法组织起来</p>
</li>
<li><p><code>java.util.Collections</code> </p>
<p>实现特定结口上静态方法的伴生类（这些方法 Java 8 以后可放进接口中）</p>
</li>
<li><p>还可以利用这种类把final类上的方法组织起来，因为不能把他们放在子类中</p>
</li>
</ul>
<p>这样的工具类不希望被实例化（因为没有意义）。但是编译器在<strong>缺少显示构造器的时会自动提供一个公有的无参的缺省构造器default constructor</strong>。可能导致无意识的实例化。</p>
<blockquote>
<p>通过将类做成抽象类来强制不可实例化行不通</p>
<p>抽象类专门为继承设计，会误导用户</p>
<p>抽象类可被子类化，且该子类能实例化。</p>
</blockquote>
<p><strong>正确方法</strong></p>
<p><strong>让这个类包含一个私有构造器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Nonistantiable utility class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UtilityClass</span></span>&#123;</span><br><span class="line">    <span class="comment">//Suppress default constructor for Nonistantiable</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">UtilityClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于显示构造器私有，所以外部不可能访问。<code>AssertionError</code>不是必须，避免内部不小心调用构造器。</p>
<p>同时最好在这个构造器上加上它的作用的注释</p>
<p><strong>缺点</strong></p>
<p>使一个类不能被子类化。所有构造器必须显示或隐式调用超类构造器，这种情况下子类无法访问超类构造器。</p>
<h2 id="5优先考虑依赖注入来引用资源"><a href="#5优先考虑依赖注入来引用资源" class="headerlink" title="5优先考虑依赖注入来引用资源"></a>5优先考虑依赖注入来引用资源</h2><p>有许多类会依赖一个或多个底层资源。</p>
<p>例如</p>
<p>拼写检查器需要依赖词典。因经常将这种类型的类实现为静态工具类或单例类。</p>
<p>局限性: 假的只有一个底层资源可用（词典）。实际上可能对每种语言需要选择对应词典，一本词典难满足需求。</p>
<p>如果在现有静态工具类或单例类，设dictionary域为nonfinal，并添加一个方法来修改词典。会很笨拙，容易出错，并且无法正常工作。</p>
<p><strong>静态工具类、单例类不适合需要引用底层资源的类。</strong></p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>这种情况下需要能支持类的多个实例，每一个实例使用客户端指定的资源（例子中的SpellChecker，和dictionary）。</p>
<p>满足依赖注入的最简单模式：<strong>创建一个新实例时，就将资源传到构造器中</strong>。</p>
<p>例如 dictionary是SpellChecker的一个依赖，在创建SpellChecker就将dictionary注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依赖注入提供 flexibility和testability</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lexicon dictionary;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">(Lexicon dictionary)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dictionary = Object.requiresNonNull(dictionary);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span></span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">suggestions</span><span class="params">(String typo)</span></span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，依赖注入适用任意数量的资源，以及人一样依赖形式。</p>
<p>依赖注入的对象资源具有<strong>不可变性</strong>（tip 17）多个客户端可以共享依赖（相同底层资源）对象。</p>
<p>依赖注入适用于构造器，静态工厂（tip 1）和构建器（tip 2）</p>
<h4 id="依赖注入变体"><a href="#依赖注入变体" class="headerlink" title="依赖注入变体"></a>依赖注入变体</h4><p>将资源工厂传给构造器。这里的工厂指工厂方法模式中的工厂，用于重复创建类型实例的一个对象。</p>
<blockquote>
<p>Java 8 中新增的<code>Supplier&lt;T&gt;</code>最适合表示工厂。</p>
<p>带有<code>Supplier&lt;T&gt;</code>的方法，通常应该限制输入工厂的类型参数，使用<strong>有限制的通配符类型（bounded wildcard type）</strong>tip 31</p>
<p>以便客户端传入一个工厂，来创建指定类型的任意子类型。</p>
<p><code>Mosaic create(Supplier&lt;? extends Title&gt; tileFactory)&#123; ... &#125;</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>依赖注入</p>
<ul>
<li><p>优点</p>
<ul>
<li>极大提升灵活性，可测试性，可重用性</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>使大型项目凌乱，可以通过<strong>依赖注入框架（dependcency injection framework）</strong>解决。</p>
<p>例如Dagger、Guice、Spring，设计成手动依赖注入的API都适用于这些框架）</p>
</li>
</ul>
</li>
</ul>
<p><strong>不要用单例类和静态工具类来实现依赖一个或多个底层资源的类</strong>，且该资源的行为会影响该类的行为。</p>
<p>不要直接用这个使用资源的类来创建这些资源。应该将这些资源或工厂传递给构造器（静态工厂，构建器）来创建类。&lt;-依赖注入</p>
<h2 id="6避免创建不必要对象"><a href="#6避免创建不必要对象" class="headerlink" title="6避免创建不必要对象"></a>6避免创建不必要对象</h2><p>最好能重用单个对象，而不是在每次需要时就创建一个相同功能的新对象。</p>
<p>如果对象是不可变（immutable）的（tip 17），就始终可以被重用。</p>
<h3 id="一般情形"><a href="#一般情形" class="headerlink" title="一般情形"></a>一般情形</h3><p>极端反例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;123123&quot;</span>);<span class="comment">//避免</span></span><br><span class="line"><span class="comment">//传递给构造器的参数“123123”本身就是一个String实例，功能等同于构造器创建的对象这样会重复创造出不必要的对象。</span></span><br><span class="line"></span><br><span class="line">String s = <span class="string">&quot;123123&quot;</span>;</span><br><span class="line"><span class="comment">//这样只是用一个String实例，而不是每次执行时都创建一个新实例。保证同一台虚拟机中运行的代码，只要包含相同字符串字面量，就会被重用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//String 采用了享元模式</span></span><br></pre></td></tr></table></figure>

<p><strong>对于提供静态工厂方法和构造器的不可变类，通常优先使用静态工厂方法而不是构造器</strong>，避免创建不必要的对象。</p>
<ul>
<li>构造器每次调用都会创建新对象</li>
<li>静态工厂方法不一定会创建新对象</li>
</ul>
<p>例如静态工厂方法<code>Boolean.valueOf(String)</code>几乎总是优先于构造器<code>Boolean(String)</code>。（<code>Boolean(String)</code>在java9中废弃）</p>
<p><strong>重用不可变对象和已知不会被修改的可变对象</strong></p>
<p>有些对象创建成本较高，如果重复创建这类对象，可以考虑将其缓存。</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s.matches(<span class="string">&quot;(-| +|^)M&#123;0,9&#125;(CM|CD|D?C&#123;0,3&#125;)(XC|XL|L?X&#123;0,3&#125;)(IX|IV|V?I&#123;0,3&#125;)( +|$)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实现方法问题在于<code>String.matches</code>。该方法检查字符串是否与正则表达式匹配，但不适合注重性能的情况下使用。</p>
<p>该方法在内部为正则表达式创建了一个Pattern实例，却只使用一次，之后就垃圾回收。而创建Pattern实例成本很高，因为需要将正则表达式编译成一个有限状态机。</p>
<p>为提升性能，应该将正则表达式显示的编译成一个Pattern实例（不可变），随类初始化并缓存。改进后性能更好，代码可读性更好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss RomanNumerals&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern ROMAN = Pattern.compile(<span class="string">&quot;(-| +|^)M&#123;0,9&#125;(CM|CD|D?C&#123;0,3&#125;)(XC|XL|L?X&#123;0,3&#125;)(IX|IV|V?I&#123;0,3&#125;)( +|$)&quot;</span>);</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ROMAN.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以对Pattern实例进行懒加载（tip 83），即在 <code>isRomanNumeral</code>方法第一次调用时才实例化Pattern。但是不建议，这样实习方法跟复杂，无法将性能显著提高到超过当前水平（tip 67）</p>
<h3 id="适配器情形"><a href="#适配器情形" class="headerlink" title="适配器情形"></a>适配器情形</h3><p>考虑适配器模式情形，有时也叫视图。</p>
<blockquote>
<p>适配器：把功能委托给一个后背对象，为后被对象提供一个可替代的接口。由于适配器除了后备对象外没有其他状态信息，所以针对某个给定对象的特定适配器而言，不需要创建多个适配器实例</p>
</blockquote>
<p>例如 Map接口的keySet方法返回该Map对象的Set视图。</p>
<p>表面上每次调用keySet都会创建一个新的Set实例，实际上对于一个给定Map对象，每次调用keySet都返回同样的Set实例。</p>
<p>返回Set实例一般可变，但所有返回对象在功能上等同：<strong>其中一个返回对象发生变化时，所有其他返回对象也发生相应变化。，因为它们由同一个Map实例支撑</strong></p>
<h3 id="自动装箱情形"><a href="#自动装箱情形" class="headerlink" title="自动装箱情形"></a>自动装箱情形</h3><p>自动装箱：允许将基本类型和装箱基本类型重用，按需自动装箱拆箱。</p>
<p>这使基本类型和装箱基本类型差别模糊，但没有完全消除。</p>
<p>在语义上由微妙差别</p>
<p>在性能上有显著差别</p>
<p>如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Long sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">0</span>; i&lt;= Integer&gt;MAX_VALUE;i++)</span><br><span class="line">   		sum+=i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序sum被声明成Long 而不是long，意味着程序大约构造了$2^{31}$个多余的Long实例。</p>
<p>结论：<strong>优先使用基本类型而不是装箱基本类型，注意无意识的自动装箱</strong></p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>不要认为创建对象代价昂贵而避免创建对象。小的对象构造器，只做很少量的显示工作，因此对小对象的创建和回收都很廉价。通过附加对象，提升程序清晰性、简洁性、功能性</p>
<p>通过自己维护对象池来避免创建对象并不是一种好做法。正确使用典范使数据库连接池，建立数据库连接很昂贵，重用有意义。但一般不用自建对象池（代码乱、占用内存）。</p>
<p>对应第50条“保护性拷贝”。”应该创建对象时，不要重用现有对象“。但是应该注意，在提倡保护性拷贝时重用对象的代价远大于创建重复对象的代价。</p>
<p>必要时没实施保护性拷贝，会导致潜在BUG和漏洞。</p>
<p>不必要创建对象只会影响程序的风格和性能。</p>
<p>面对具体问题需要具体分析。</p>
<h2 id="7消除过期对象的引用"><a href="#7消除过期对象的引用" class="headerlink" title="7消除过期对象的引用"></a>7消除过期对象的引用</h2><p>java有垃圾回收机制，不用手动管理内存，使用完的对象会自动回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存泄漏</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span></span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> element[--size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.length == size)</span><br><span class="line">            element = Arrays.copyOf(element,<span class="number">2</span>*size+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码没有明显错误。但是这段程序存在“内存泄漏”，随垃圾回收器活动的增加，或由于内存占用增加，程序性能会逐渐降低。</p>
<p>极端情况下这种内存泄漏会导致磁盘交换（Disk Paging）甚至程序崩溃OutOfMemoryError。</p>
<p>这个程序中，如果一个栈现增长，后收缩，从栈中弹出的对象不会被回收，即使栈不在使用这些对象。</p>
<p>原因：<strong>栈内部维护这些对象的过期引用（obsolete reference）</strong></p>
<blockquote>
<p>过期引用 永远不会再被解除的引用。</p>
</blockquote>
<p>本例中，再elements数组<strong>活动部分</strong>以外的引用都是过期引用</p>
<p>在支持垃圾回收的语言中，内存泄漏都是很隐蔽的（例子这类内存泄漏称为<strong>“无意识的对象保持”unintentional object retention</strong>）。</p>
<p>如果一个对象被无意识的保留，垃圾回收机制不会处理这个对象，也不会处理这个对象所引用的其他所有对象</p>
<h3 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h3><p><strong>一旦对象引用过期，只需清空这些引用。</strong>清空过期引用还能防止这些对象之后被错误的解除引用（程序会立即抛出<code>NullPointerException</code>异常。</p>
<p>例子中pop方法修改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        Object resule = element[--size];</span><br><span class="line">        elements[size] = <span class="keyword">null</span>;<span class="comment">//单元弹出栈指向它的引用就过期，清空引用</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>清空对象引用是一种例外，而不是一种编程规范。</strong></p>
<p>清除过期对象的最好方法是<strong>让包含该引用的变量结束其生命周期</strong>。如果在最紧凑的作用域范围内定义每一个变量（tip 57），这种情况自然发生。</p>
<h3 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h3><p>Stack类自己管理内存。储存池包含了elemnts数组（对象引用单元，而不是对象本身）。数组的活动部分时已分配的，其余部分是自由的。</p>
<p>对垃圾回收器而言，elements数组中所有对象引用<strong>同样有效</strong>。</p>
<p>程序员需要把变成非活动的元素手动清空。</p>
<p><strong>只要是类自己管理内存，就应该注意内存泄漏问题</strong>。一旦元素被释放，该元素中包含的任何对象引用都应该清空。</p>
<h3 id="内存泄漏来源"><a href="#内存泄漏来源" class="headerlink" title="内存泄漏来源"></a>内存泄漏来源</h3><ul>
<li><p>上面的，类自己管理内存。无意识的对象保持</p>
</li>
<li><p>另一个常见来源是缓存</p>
<ul>
<li><p>把对象放到缓存中，容易被遗忘，很长时间都留在缓存中。</p>
</li>
<li><p>解决方案</p>
<ul>
<li><p>对于 <em>缓存之外存在对某个项的键的引用，该项就有意义</em> 这种情况 可以使用<code>WeakHashMap</code>代表缓存。缓存中项过期后就会被自动删除。<strong>所有缓存项的生命周期有改键外部引用而不是值决定时，<code>WeakHashMap</code>才有用</strong></p>
</li>
<li><p>缓存项生命周期是否有意义并不容易确定。其中的项随时间变得无价值。这种情况可以定期清理没用的项。</p>
<p>后台线程（可能是<code>ScheduleThreadPoolExecutor</code>）来完成清除工作，或缓存添加新条目时顺便清理（<code>LinkedHashMap</code>利用<code>removeEldestEntry</code>方法方便实现）</p>
</li>
<li><p>对复杂的缓存必须直接使用<code>java.lang.ref</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>监听器和其他回调</p>
<ul>
<li>实现一个API，客户端在这个API注册回调，却没有显示取消注册，如果没有采取某些动作，否则就会不断堆积。</li>
<li>解决方案<ul>
<li>确保回调立即被当作垃圾回收的最佳方法是只保存它们的<strong>弱引用</strong>，例如只将它们保持成<code>WeakHashMap</code>的键</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>内存泄漏通常不会表现成明显的失败，所以可能在一个系统中存在很久。</p>
<p>同过仔细检查代码或借助<strong>Heap刨析工具（Heap Proflier）</strong>才能发现内存泄漏</p>
<p>所以在上述情况下注意这些问题并阻止它们发生。</p>
<h2 id="8避免使用终结方法和清除方法"><a href="#8避免使用终结方法和清除方法" class="headerlink" title="8避免使用终结方法和清除方法"></a>8避免使用终结方法和清除方法</h2><p><strong>终结方法（finalizer）通常是不可预测的，也很危险，一般情况下不必要。</strong></p>
<p>可能导致行为不稳定，性能降低，可移植性问题。</p>
<p>java 9中使用清除方法（cleaner）代替了终结方法。<strong>清除方法没有终结方法危险，但仍不可预测运行缓慢，一般也是不必要的。</strong></p>
<p>注意：不要把终结方法当作C++中的析构器（destructor）的对应物。</p>
<blockquote>
<p>C++中析构器是回收一个对象占用资源的常规方法，构造器必须的对应函数。析构器也可回收其他非内存资源，java中用try-finally来实现（tip 9）</p>
<p>Java中当一个引用不可达。垃圾回收器会回收该对象相关联的存储空间。</p>
</blockquote>
<p>终结和清除方法缺点在于<strong>不能保证会被及时执行</strong>。</p>
<p>对象变为不可达到它的终结方法执行，所花费的时间任意长<strong>。注重时间的任务不应该由终结方法和清楚方法来完成。</strong></p>
<p>例如用终结或清除方法关闭已打开文件。打开文件的描述符是一种有限资源，如果系不能及时运行终结或清除方法，导致大量文件保留打开状态，可能导致运行失败。</p>
<p>及时执行终结或清除方法是回收算法的一个主要功能，但是这种算法在不同JVM的实现会不同。</p>
<p>如果程序依赖终结或清除方法被执行的时间点，这个程序在不同JVM上的运行表现会不同。</p>
<p>java的语言规范不会保证哪个线程将执行终结方法。类的设计者可以控制自己清除线程，但清除方法仍在后台运行，垃圾回收器控制，不能确保直接清除。</p>
<p>java的语言规范不会保证终结或清除方法会被（及时）执行。一个程序终止时，某些已无法访问的对象的终结方法根本没有执行。依赖终结或清除方法来释放共享资源（数据库）上的永久锁可能使系统崩溃</p>
<blockquote>
<p><code>System.gc</code>和<code>System.runfinalization</code>增加了终结和清除方法被执行的机会，但并不保证它们一定会被执行</p>
</blockquote>
<p>结论：<strong>永远不应该依赖终结方法或清除方法来更新重要的持久状态</strong>。</p>
<p>使用终结方法的另一个问题：<strong>若忽略终结过程被抛出的未捕获的异常，该对象的终结过程也会中止</strong>。未被捕获的异常会使对象处于破坏状态，如果另一个线程使用这个被破坏对象会发生不确定行为。</p>
<p>异常发生在终结方法中不会打印警告。清除方法不会，使用清除方法的一个类库在控制它的线程。</p>
<p>使用<strong>终结或清除方法有一个非常严重的性能损失</strong>。主要使终结方法阻止了有效的垃圾回收，清除方法来清除所有类的实例会稍快。</p>
<p>但如果只把清除方法作为一道安全网，清除方法会更快。</p>
<p>终结方法存在一个严重安全问题：使终结方法攻击可以攻击类。</p>
<blockquote>
<p>终结方法攻击：从构造器或它的序列化对等体（readObject和readReslove方法）抛出异常，恶意子类的终结方法就可以在构造了一部分的（应该不存在）对象上运行。这个终结方法会将该对象记录在一个静态域中，阻止它被垃圾回收。一旦记录异常的对象，就可以在这个对象上调用其他方法。</p>
<p><strong>从构造器抛出异常应该可以防止对象继续存在，但是终结方法攻击导致不能</strong></p>
<p>为防止非final类收到终结方法攻击，要编写一个<strong>空的final的<code>finalize</code>方法</strong></p>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>对象中的资源确实需要终止，<strong>让类实现<code>AutoCloseable</code>，并要求客户端在每个实例不需要使调用close方法。（一般利用<code>try-with-resources</code> tip 9）</strong>就可以不用编写终结和清除方法。</p>
<p>细节：该实例必须记录下自己是否已被关闭，close方法必须在一个私有域中记录“该对象不在有效”，如果这些方法在对象终止后被调用，其他方法必须检查这个域，并抛出<code>IllegalStateException</code></p>
<h3 id="终结方法和清除方法的合法用途"><a href="#终结方法和清除方法的合法用途" class="headerlink" title="终结方法和清除方法的合法用途"></a>终结方法和清除方法的合法用途</h3><ul>
<li><p>安全网</p>
<p>当资源所有者忘记调用close时，终结方法和清除方法可以充当安全网。</p>
<p>使用安全网要考虑是否值得付出的代价。</p>
<p><code>FileInputStream、FileOutputStream、ThreadPoolExecutor、java.sql.Connection</code>等都有充当安全网的终结方法</p>
</li>
<li><p>与对象的本地对等体有关</p>
<blockquote>
<p>本地对等体是一个本地（非java）对象（naive object），普通对象通过本地方法（naive method）委托给一个本地对象。</p>
<p>本地对等体不是一个普通对象，垃圾回收器不会知道他，当它的java对等体被回收时，它不会被回收。</p>
</blockquote>
<p>如果本地对等体没有关键资源性能也可接受，清除或终结方法是最适合工具。如果本地对等体有关键资源性能或性能无法接受，这个类就应该具有一个close方法</p>
</li>
</ul>
<h3 id="清除方法使用技巧"><a href="#清除方法使用技巧" class="headerlink" title="清除方法使用技巧"></a>清除方法使用技巧</h3><p>例如</p>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>除非是作为安全网，或是为了终止非关键本地资源，否则不要使用清除方法，java 9之前发行的版本尽量不要使用终结方法。</p>
<p>若使用了终结或清除方法，则要注意它的不确定性和性能后果。</p>
<h2 id="9try-with-resources优先于try-finally"><a href="#9try-with-resources优先于try-finally" class="headerlink" title="9try-with-resources优先于try-finally"></a>9<code>try-with-resources</code>优先于<code>try-finally</code></h2><p>java类库中有许多需要调用close方法来手动关闭的资源，例如<code>InputStream,OutputStream,java.sql.Collecton</code>。忽略资源关闭，回对性能造成严重影响。许多资源使用终结方法作为安全网，但效果并不理想（tip 8）。</p>
<h3 id="try-finally"><a href="#try-finally" class="headerlink" title="try-finally"></a><code>try-finally</code></h3><p><code>try-finally</code>语句是确保资源关闭的好方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	BufferReader br = <span class="keyword">new</span> BufferReader(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> br.readLine();</span><br><span class="line">	&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">		br.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在添加第二个资源就不适用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">copy</span> <span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	InputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		OutputStream out = <span class="keyword">new</span> FileOutputStream(dst);</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="keyword">while</span>((n==in.read(buf))&gt;=<span class="number">0</span>)</span><br><span class="line">			out.write(buf,<span class="number">0</span>,n);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		in.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//不可以放到一个try里面吗？</span></span><br></pre></td></tr></table></figure>

<p><code>try-finally</code>即使正确的关闭了资源，如前两例，也会存在些许不足。</p>
<p>因为在try块和finally块的的代码都会抛出异常。</p>
<p>在例1中，如果底层物理设备异常，调用<code>readLine</code>就会抛出异常，同样<code>close</code>也会抛出异常。这种情况下第二个异常会抹去第一个异常</p>
<p>，在异常堆栈轨迹中不会有第一个异常的记录。</p>
<h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a><code>try-with-resources</code></h3><p>java 7中引入了<code>try-with-resources</code>，以上问题都被解决。</p>
<p>要使用这个构造资源，必须先实现<code>AutoCloseable</code>接口，其中包含单个返回void的<strong>close方法</strong></p>
<p>如果编写了一个代表<strong>必须被关闭的资源的类</strong>，这个类应该实现<code>AutoCloseable</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(BufferReader br = <span class="keyword">new</span> BufferReader(<span class="keyword">new</span> FileReader(path)))&#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">copy</span> <span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	<span class="keyword">try</span>(InputStream in = <span class="keyword">new</span> FileInputStream(src);OutputStream out = <span class="keyword">new</span> FileOutputStream(dst))&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="keyword">while</span>((n==in.read(buf))&gt;=<span class="number">0</span>)</span><br><span class="line">			out.write(buf,<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>

<p><code>try-with-resources</code>优点</p>
<ul>
<li>代码简洁易懂</li>
<li>容易诊断<ul>
<li>以firstLineOfFile为例，如果调用readLine和close（不可见）都出现异常，后一个异常就会被静止，保留第一个异常。为保留需要的异常后面的异常都会静止。这些被禁止的异常也会被打印在异常堆栈轨迹，并注明是被禁止异常。</li>
<li>编程调用getSuppressed方法可以访问到被禁止异常</li>
</ul>
</li>
<li><code>try-with-resources</code>可以和<code>try-finally</code>一样和catch一起使用捕获异常。这样不需要再嵌套一层代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(BufferReader br = <span class="keyword">new</span> BufferReader(<span class="keyword">new</span> FileReader(path)))&#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    	<span class="keyword">return</span> defaultVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//无法打开文件或无法读取就返回一个默认值</span></span><br></pre></td></tr></table></figure>

<h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>处理必须关闭的资源时，始终优先考虑使用<code>try-with-resources</code>。这样代码比<code>try-finally </code>更简洁、清晰，产生的异常也更有价值，编码也更加方便。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://example.com/2021/03/28/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/" title="创建和销毁对象" target="_blank" rel="external">http://example.com/2021/03/28/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/hs-jose" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/hs-jose" target="_blank"><span class="text-dark">hs</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/28/%E5%AF%B9%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/" title="通用方法"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/28/%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/" title="异常、断言和日志"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button">
        <span>[&nbsp;</span><span>Catalogue</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/hs-jose" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>