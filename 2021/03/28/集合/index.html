<!DOCTYPE html>
<html lang=ch>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>集合 | Hesai&#39;s Blog</title>
  <meta name="description" content="集合主要是标准库中集合类 集合接口与实现分离Java 集合类库将接口（interface）与实现（implementation）分离。 以队列为例 12345678&#x2F;&#x2F;队列接口最简形式public interface Queue&lt;E&gt;&amp;#123;	void add(E element);	E remove();	int size();&amp;#125;&#x2F;&#x2F;并未说明队列如何实现，常见有循环数组">
<meta property="og:type" content="article">
<meta property="og:title" content="集合">
<meta property="og:url" content="http://example.com/2021/03/28/%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="Hesai&#39;s blog">
<meta property="og:description" content="集合主要是标准库中集合类 集合接口与实现分离Java 集合类库将接口（interface）与实现（implementation）分离。 以队列为例 12345678&#x2F;&#x2F;队列接口最简形式public interface Queue&lt;E&gt;&amp;#123;	void add(E element);	E remove();	int size();&amp;#125;&#x2F;&#x2F;并未说明队列如何实现，常见有循环数组">
<meta property="og:locale">
<meta property="og:image" content="e:/学习资料/笔记/Java核心卷Ⅰ/image-20210113162729464.png">
<meta property="og:image" content="e:/学习资料/笔记/Java核心卷Ⅰ/image-20210114160934956.png">
<meta property="og:image" content="e:/学习资料/笔记/Java核心卷Ⅰ/image-20210115161827576.png">
<meta property="article:published_time" content="2021-03-28T15:05:01.868Z">
<meta property="article:modified_time" content="2021-03-28T15:40:59.395Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="tags">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="e:/学习资料/笔记/Java核心卷Ⅰ/image-20210113162729464.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://example.com/2021/03/28/%E9%9B%86%E5%90%88/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hesai&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/hs-jose" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">hs</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/hs-jose" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>记录知识</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E2%85%A0/">Java核心技术 Ⅰ</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E2%85%A1/">Java核心技术 Ⅱ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%85%A0-%E6%B7%BB%E5%8A%A0%E5%8D%9A%E6%96%87%E5%88%86%E7%B1%BB/">Java核心技术Ⅰ# 添加博文分类</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%85%A1/">Java核心技术Ⅱ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/effective-Java/">effective Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/">深入理解JVM</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/tags/" rel="tag">tags</a><span class="tag-list-count">13</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/tags/" style="font-size: 13px;">tags</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/">深入理解JVM</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/" class="title">Java内存区域与内存溢出异常</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:25.905Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/">深入理解JVM</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" class="title">垃圾收集器与内存分配策略</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:25.905Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/effective-Java/">effective Java</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%AF%B9%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/" class="title">通用方法</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:16.515Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/effective-Java/">effective Java</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/" class="title">创建和销毁对象</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:16.515Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%85%A0-%E6%B7%BB%E5%8A%A0%E5%8D%9A%E6%96%87%E5%88%86%E7%B1%BB/">Java核心技术Ⅰ# 添加博文分类</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/" class="title">异常、断言和日志</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:01.868Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">Catalogue</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB"><span class="toc-number">1.0.1.</span> <span class="toc-text">集合接口与实现分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.0.2.</span> <span class="toc-text">Collection接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.0.3.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.4.</span> <span class="toc-text">泛型实用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.0.5.</span> <span class="toc-text">集合框架中的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#List"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ListIterator"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">ListIterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8ArrayList"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">数组列表ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8HashMap"><span class="toc-number">1.0.5.4.</span> <span class="toc-text">散列表HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E9%9B%86-HashSet"><span class="toc-number">1.0.5.5.</span> <span class="toc-text">散列集 HashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E9%9B%86TreeSet"><span class="toc-number">1.0.5.6.</span> <span class="toc-text">树集TreeSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97-Queue-%E4%B8%8E-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-Deque"><span class="toc-number">1.0.5.7.</span> <span class="toc-text">队列 Queue 与  双端队列 Deque</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97PriorityQueue"><span class="toc-number">1.0.5.8.</span> <span class="toc-text">优先队列PriorityQueue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84-Map"><span class="toc-number">1.0.6.</span> <span class="toc-text">映射 Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%98%A0%E5%B0%84%E6%9D%A1%E7%9B%AE"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">更新映射条目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%95%A3%E5%88%97%E9%9B%86%E4%B8%8E%E6%98%A0%E5%B0%84-LinkedHashSet-LinkedHashMap"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">链接散列集与映射 LinkedHashSet LinkedHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E9%9B%86%E4%B8%8E%E6%98%A0%E5%B0%84EnumSet-EnumMap"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">枚举集与映射EnumSet EnumMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E6%95%A3%E5%88%97%E6%98%A0%E5%B0%84-IdentityHashMap"><span class="toc-number">1.0.6.4.</span> <span class="toc-text">标识散列映射 IdentityHashMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E4%B8%8E%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">1.0.7.</span> <span class="toc-text">视图与包装器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E9%9B%86%E5%90%88"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">小集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E8%8C%83%E5%9B%B4"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">子范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9%E7%9A%84%E8%A7%86%E5%9B%BE"><span class="toc-number">1.0.7.3.</span> <span class="toc-text">不可修改的视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%A7%86%E5%9B%BE"><span class="toc-number">1.0.7.4.</span> <span class="toc-text">同步视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%9E%8B%E8%A7%86%E5%9B%BE"><span class="toc-number">1.0.7.5.</span> <span class="toc-text">检查型视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%8F%AF%E9%80%89%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E"><span class="toc-number">1.0.7.6.</span> <span class="toc-text">关于可选操作的一些说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.0.8.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">泛型算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%B7%B7%E6%8E%92"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">排序与混排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.0.8.3.</span> <span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.8.4.</span> <span class="toc-text">批操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.0.8.5.</span> <span class="toc-text">集合与数组的转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%97%E7%95%99%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">1.0.9.</span> <span class="toc-text">遗留的集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable-%E7%B1%BB"><span class="toc-number">1.0.9.1.</span> <span class="toc-text">HashTable 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE-Enumeration"><span class="toc-number">1.0.9.2.</span> <span class="toc-text">枚举 Enumeration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84-Properties"><span class="toc-number">1.0.9.3.</span> <span class="toc-text">属性映射 Properties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88-Stack"><span class="toc-number">1.0.9.4.</span> <span class="toc-text">栈 Stack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E9%9B%86-BitSet"><span class="toc-number">1.0.9.5.</span> <span class="toc-text">位集 BitSet</span></a></li></ol></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-集合" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      集合
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/28/%E9%9B%86%E5%90%88/" class="article-date">
	  <time datetime="2021-03-28T15:05:01.868Z" itemprop="datePublished">2021-03-28</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E2%85%A0/">Java核心技术 Ⅰ</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/tags/" rel="tag">tags</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/28/%E9%9B%86%E5%90%88/#comments" class="article-comment-link">Comments</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>主要是标准库中集合类</p>
<h3 id="集合接口与实现分离"><a href="#集合接口与实现分离" class="headerlink" title="集合接口与实现分离"></a>集合接口与实现分离</h3><p>Java 集合类库将<strong>接口（interface）</strong>与<strong>实现（implementation）</strong>分离。</p>
<p>以队列为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列接口最简形式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">	<span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并未说明队列如何实现，常见有循环数组，链表</span></span><br></pre></td></tr></table></figure>

<p>对Queue接口的每一个实现都可用一个实现的Queue接口的类表示</p>
<p>Java 中定义了相应的接口</p>
<ul>
<li><code>public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;...&#125;</code></li>
</ul>
<p>具体的实现类实现对应接口</p>
<p>可以使用<strong>接口类型</strong>存放集合引用。</p>
<p>只有在构造集合对象的时候才会使用具体的类，在使用的时候不需要关心是何种方式实现的 </p>
<p>通常有一组名字以 <code>Abstract</code> 开头的类，例如 <code>AbstractQueue</code>，这些类是为<strong>类库实现者</strong>设计的</p>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>集合类的基本接口是 <code>Collection</code> 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>add 方法用于向集合 添加元素<ul>
<li>添加元素改变了集合返回 true；如果集合没有发生变化，返回 false。</li>
<li>集（set）如果对象已存在则返回 false</li>
</ul>
</li>
<li>iterator 方法返回一个实现了 <code>Iterator</code> 接口的对象，该迭代器对象依次访问集合中的元素</li>
</ul>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>接口源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next element in the iteration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the next element in the iteration</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if the iteration has no more elements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implSpec</span></span></span><br><span class="line"><span class="comment">     * The default implementation throws an instance of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> UnsupportedOperationException&#125; and performs no other action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the &#123;<span class="doctag">@code</span> remove&#125;</span></span><br><span class="line"><span class="comment">     *         operation is not supported by this iterator</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException if the &#123;<span class="doctag">@code</span> next&#125; method has not</span></span><br><span class="line"><span class="comment">     *         yet been called, or the &#123;<span class="doctag">@code</span> remove&#125; method has already</span></span><br><span class="line"><span class="comment">     *         been called after the last call to the &#123;<span class="doctag">@code</span> next&#125;</span></span><br><span class="line"><span class="comment">     *         method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反复调用 <code>next</code> 方法可以逐个访问集合中的每个元素</p>
<p>到达了<strong>集合末尾</strong>，next 方法会抛出 <code>NoSuchElementException</code></p>
<p>在调用 <code>next</code> 之前调用 <code>hasNext</code> 方法，如果还有可访问元素，该方法会返回true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = ...;</span><br><span class="line">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    String element = iter.next();</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for each循环可更方便的遍历集合。</p>
<p>编译器将“for each” 循环转换为带有迭代器的循环</p>
<p>因此”for each” 循环可以处理任何<strong>实现了 <code>Iterable</code> 接口的对象</strong>。（ <code>Iterable</code>包含一个抽象方法<code>iterator&lt;E&gt; iterator();</code>)</p>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(String element : c)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>Collection</code> 接口扩展了 <code>Iterable</code> 接口，因此标准类库的任何集合都可以使用 for each 循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>forEachRemaining</code> 方法并提供 <strong>lambda 表达式</strong>来处理每一个元素，直到没有元素为止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator.forEachRemaing(element -&gt; do something with element);</span><br></pre></td></tr></table></figure>

<p><strong>访问元素的顺序取决于集合类型</strong></p>
<ul>
<li><p>ArrayList从索引0开始，每次迭代索引+1</p>
</li>
<li><p>HashSet 会按照基本上随机的顺序获得元素</p>
</li>
</ul>
<blockquote>
<p> Iterator 接口的 next 和 hasNext 方法和 Enumeration 接口的 nextElement 和 hasMoreElements 方法作用一样.后者方法名累赘</p>
</blockquote>
<p><strong>Java标准集合类库库迭代器与其他类库迭代器区别</strong></p>
<ul>
<li>Java 迭代器的<strong>查找操作</strong>和<strong>位置变更</strong>紧密<strong>耦合</strong><ul>
<li>查找一个元素的唯一方法是调用 <code>next</code>，查找操作的同时，迭代器的位置就会随之向前移动</li>
<li>可以认为 Java 迭代器位于两个元素之间，调用 <code>next</code> 时，<strong>迭代器就越过下一个元素。并返回刚刚越过的那个元素的引用</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>C++STL库迭代器根据数组索引建模。不需要访问元素也可以通过i++移动迭代器</p>
</blockquote>
<ul>
<li><p>next 方法和 remove 方法调用之间存在<strong>依赖性</strong></p>
<ul>
<li><p>Iterator 接口的 remove 方法将会删除上次调用 <code>next</code> 方法时<strong>返回的元素</strong></p>
<ul>
<li><p>如果想删除指定位置上的元素，仍然需要越过这个元素</p>
</li>
<li><p>如果调用 remove 之前没有调用 next，将是不合法的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如删除两个连续元素</span></span><br><span class="line">it.remove();</span><br><span class="line">it.remove();<span class="comment">//ERROR</span></span><br><span class="line"></span><br><span class="line">it.remove();</span><br><span class="line">it.next();</span><br><span class="line">it.remove();<span class="comment">//正确</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="泛型实用方法"><a href="#泛型实用方法" class="headerlink" title="泛型实用方法"></a>泛型实用方法</h3><p> <code>Collection</code>和<code>Iterator</code>是泛型接口，方便编写处理任何集合类型的实用方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;    </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;    </span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;    </span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;    </span><br><span class="line">        <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;    </span><br><span class="line">        Object[] toArray();    </span><br><span class="line">        &lt;T&gt; T[] toArray(T[] a);    </span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;        </span><br><span class="line">            Objects.requireNonNull(filter);</span><br><span class="line">            <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> Iterator&lt;E&gt; each = iterator();</span><br><span class="line">            <span class="keyword">while</span> (each.hasNext()) &#123;            </span><br><span class="line">                <span class="keyword">if</span> (filter.test(each.next())) &#123;                </span><br><span class="line">                    each.remove();                </span><br><span class="line">                    removed = <span class="keyword">true</span>;            </span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;        </span><br><span class="line">        	<span class="keyword">return</span> removed;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="meta">@Override</span>    </span><br><span class="line">        <span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);    &#125;    </span><br><span class="line">        <span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);    &#125;    </span><br><span class="line">        <span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java类库提供一个叫做 <code>public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; </code>类，实现了大部分 <code>Collection</code> 接口的方法，来方便实现者。保持基础方法size（）和iterator（）仍为抽象方法，为实现者提供其他例行方法。</p>
<p>但是可以在 Collection 添加默认方法，也可以达到同样的效果</p>
<h3 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h3><p>java集合框架不同类型集合</p>
<p><img src="E:\学习资料\笔记\Java核心卷Ⅰ\image-20210113162729464.png" alt="image-20210113162729464"></p>
<p>集合有两个基本接口，Collection和Map</p>
<p>集合有两个基本接口 <code>Collection</code>（集合）和 <code>Map</code>（映射）</p>
<ul>
<li>集合插入元素 <code>boolean add(E element)</code></li>
<li>集合读取元素，可以用迭代器访问元素</li>
<li>映射（Map）包含键 / 值对<ul>
<li>用 <code>put</code> 方法插入 :   <code>V put(K key, V value);</code></li>
<li>用 <code>get</code> 方法读取值:   <code>V get(K key)</code></li>
</ul>
</li>
</ul>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p><code>List</code> 是一个<strong>有序集合（ordered collection）</strong>。</p>
<p>元素会增加到容器中的特定位置</p>
<p>访问元素方式</p>
<ul>
<li><p>迭代器方法</p>
<ul>
<li>必须<strong>按顺序访问</strong>元素</li>
</ul>
</li>
<li><p>整数索引方法</p>
<ul>
<li>又称<strong>随机访问（random access）</strong>，可以<strong>任意顺序</strong>访问元素</li>
</ul>
<p><code>List</code> 中随机访问的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void add(int index, E element)</span><br><span class="line">void remove(int index)</span><br><span class="line">E get(int index)</span><br><span class="line">E set(int index, E element)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h4><p><code>public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt;</code><br><code>ListIterator</code>接口是 <code>Iterator</code> 的一个子接口。它定义了一个方法用于在迭代器位置前面增加一个元素 void add(E element)</p>
<p>两种有序集合随机访问性能差异</p>
<ul>
<li><p>数组支持的有序集合</p>
<ul>
<li>可以快速地随机访问</li>
<li>适合使用 List 方法并提供一个整数索引访问</li>
</ul>
</li>
<li><p>链表支持的有序集合</p>
<ul>
<li><p>随机访问很慢</p>
</li>
<li><p>最好使用迭代器遍历</p>
</li>
<li><p>但是 <code>LinkedList</code> 仍然继承了 <code>List</code> 接口</p>
</li>
<li><p>```<br>public class LinkedList<E></p>
<pre><code>extends AbstractSequentialList&lt;E&gt;
implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; Java1.4引入标记接口RandomAcces。可用于测是一个特定集合是否支持高效随机访问。</span><br><span class="line">&gt;</span><br><span class="line">&gt; if(c instanceof RandomAcces)</span><br><span class="line">&gt;</span><br><span class="line">&gt; ​	random acces</span><br><span class="line">&gt;</span><br><span class="line">&gt; else</span><br><span class="line">&gt;</span><br><span class="line">&gt; ​	sequence acces</span><br><span class="line"></span><br><span class="line">#### Set</span><br><span class="line"></span><br><span class="line">集（Set）接口等同于&#96;Collection&#96;接口。但是集的方法的行为有更严谨的定义。</span><br><span class="line"></span><br><span class="line">-  &#96;add&#96;方法不允许增加重复元素</span><br><span class="line">-  &#96;equals&#96;方法：只要两个集包含同样到元素就是相等，而不要求元素需要有同样的顺序</span><br><span class="line">-  &#96;hashCode&#96;方法定义要保证包含相同元素的两个集会得到相同的散列码</span><br><span class="line"></span><br><span class="line">#### SortedSet和SortedMap</span><br><span class="line"></span><br><span class="line">&#96;SortedSet&#96;和&#96;SortedMap&#96;接口提供用于排序的比较器对象。定义了可以得到集合子集视图的方法。</span><br><span class="line"></span><br><span class="line">####  NavigableSet和NavigableMap</span><br><span class="line"></span><br><span class="line">Java6 引入了&#96;NavigableSet&#96;和&#96;NavigableMap&#96;接口，包含一些用于搜索和遍历有序集和映射的方法。&#96;TreeSet&#96;和&#96;TreeMap&#96;类实现了这些接口。</span><br><span class="line"></span><br><span class="line">### 具体集合</span><br><span class="line"></span><br><span class="line">除了以&#96;Map&#96;结尾的类之外，其他类都实现了&#96;Collection&#96;接口。以&#96;Map&#96;结尾的类实现了&#96;Map&#96;接口</span><br><span class="line"></span><br><span class="line">| 集合类型        | 描述                                           |      |</span><br><span class="line">| --------------- | ---------------------------------------------- | ---- |</span><br><span class="line">| ArrayList       | 可以**动态**增加和缩减的一个**索引**序列       |      |</span><br><span class="line">| LinkedList      | 可以在**任何位置高效插入和删除**的一个有序序列 |      |</span><br><span class="line">| ArrayDeque      | 实现为循环数组的一个双端队列                   |      |</span><br><span class="line">| HashSet         | 没有重复元素的一个无序集合                     |      |</span><br><span class="line">| TreeSet         | 一个有序集                                     |      |</span><br><span class="line">| EnumSet         | 一个包含枚举类型值的集                         |      |</span><br><span class="line">| LinkedHashSet   | 一个可以记住元素插入次序的集                   |      |</span><br><span class="line">| PriorityQueue   | 允许高效删除最小元素的一个集合                 |      |</span><br><span class="line">| HashMap         | 存储键&#x2F;值关联的一个数据结构                    |      |</span><br><span class="line">| TreeMap         | 键有序的一个映射                               |      |</span><br><span class="line">| EnumMap         | 键属于枚举类型的的一个映射                     |      |</span><br><span class="line">| LinkedHashMap   | 可以记住键&#x2F;值添加次序的一个映射                |      |</span><br><span class="line">| IdentityHashMap | 用&#x3D;&#x3D;而不是用equals比较键的一个映射             |      |</span><br><span class="line">| WeakHashMap     | 值不会在别处使用时就可以被垃圾回收的一个映射   |      |</span><br><span class="line"></span><br><span class="line">集合框架中的类</span><br><span class="line"></span><br><span class="line">p376 图9-5</span><br><span class="line"></span><br><span class="line">#### 链表 LinkedList</span><br><span class="line"></span><br><span class="line">数组和数组列表（ArrayList）缺点：从中间删除或插入元素的开销大</span><br><span class="line"></span><br><span class="line">Java 中，所有链表实际上都是**双向链接（doubly linked）**的。每个链接存放着其前驱的引用。</span><br><span class="line"></span><br><span class="line">&#96;LinkedList.add&#96; 方法将对象添加到链表的**尾部**</span><br><span class="line"></span><br><span class="line">对于插入链表中间，由于迭代器描述集合的位置，可以通过迭代器完成该操作</span><br><span class="line"></span><br><span class="line">- 只有对自然有序的集合使用迭代器添加元素才有实际意义</span><br><span class="line">-  set 数据类型是无序的，因此 &#96;Iterator&#96; 接口中没有 &#96;add&#96; 方法</span><br><span class="line"></span><br><span class="line">&#96;ListIterator&#96; 继承 &#96;Iterator&#96;，包含了 &#96;add&#96; 方法</span><br><span class="line"></span><br><span class="line">&#96;add&#96; 方法与 &#96;Collection.add&#96; 不同，不返回 &#96;boolean&#96; 类型，假定 add 操作总会改变链表</span><br><span class="line"></span><br><span class="line">同时&#96; E previous();&#96; 和 &#96;boolean hasPrevious();&#96; 可以反向遍历链表</span><br><span class="line"></span><br><span class="line">- &#96;previous&#96; 方法返回**跨越**过的对象 （于next类似）</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123;</span><br><span class="line">    boolean hasNext();</span><br><span class="line">    E next();</span><br><span class="line">    boolean hasPrevious();</span><br><span class="line">    E previous();</span><br><span class="line">    int nextIndex();</span><br><span class="line">    int previousIndex();</span><br><span class="line">    void remove();</span><br><span class="line">    void set(E e);</span><br><span class="line">    void add(E e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p> <code>LinkedList</code> 类的 <code>listIterator</code> 方法返回一个实现了 <code>ListIterator</code> 接口的迭代器对象    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listIterator(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ListIterator</code> 的 <code>add</code> 方法在迭代器位置<strong>之前</strong>添加一个新的对象，</p>
<p>注意</p>
<p>可以认为迭代器的位置在两个元素之间一个刚由 <code>listIterator</code> 方法返回并指向链表表头的迭代器调用 <code>add</code>，新添加的元素成为链表的新表头</p>
<p>在迭代器越过链表的最后一个元素（即 hasNext () 返回 false），添加元素称为链表新的表尾</p>
<p>如果链表有 n 个元素，则有 n+1 的位置可以添加新元素</p>
<p>set方法用一个新元素替换调用next或previous方法返回的元素。</p>
<p>如果一个迭代器在修改集合，另一个在遍历集合，则会出现混乱</p>
<ul>
<li><p><code>ListIterator</code> 可以检测到这种修改</p>
</li>
<li><p>如果一个迭代器发现它的集合被另一个迭代器修改了，或是该集合自身的某个方法修改了（集合改变），就会抛出 <code>ConcurrentModificationException</code> 异常</p>
</li>
<li><p>集合可以跟踪更改操作（添加或删除元素）的次数（并发修改检测），每个迭代器都会为它负责的更改操作维护一个单独的更改操作数。</p>
<ul>
<li><p>在迭代器被调用方法的开始，迭代器会检查它自己的更改操作数是否和集合的更改操作数相等。不一致就抛出 <code>ConcurrentModificationException</code></p>
</li>
<li><p>链表只跟踪对列表的</p>
<p>结构性修改，例如添加和删除</p>
<p><code>set</code> 方法不被视为结构性修改 </p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>contains</code> 方法检测某个元素是否出现在链表中</p>
<p><strong>链表不支持快速随机访问</strong></p>
<p>如果要查看链表中的第 n 个元素，就得从头开始，越过 n-1 个元素（<code>get</code> 方法优化：如果索引大于 <code>size()/2</code>，则从列表后端向前搜索元素）</p>
<p>不要用下面这种虚假的效率极低的随机访问遍历列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">    <span class="keyword">do</span> something with list.get(i);</span><br></pre></td></tr></table></figure>

<p>列表迭代器能够告诉当前位置的索引：由于 Java 迭代器指向两个元素之间的位置，所以有两个索引（可以画出迭代器位置示意图）</p>
<ul>
<li><code>nextIndex</code> 返回下一次调用 <code>next</code> 方法时返回元素的整数索引</li>
<li><code>previousIndex</code> 返回下一次调用 <code>previous</code> 方法时返回元素的整数索引</li>
<li><code>list.listIterator(n).next()</code> 和 <code>list.get(n)</code> 会产生同一个元素</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>区别迭代器 <code>ListIterator</code> 的 <code>add</code> 和集合本身的 <code>add</code> 的区别</li>
<li>迭代器的 <code>add</code> 是在迭代器<strong>之前</strong>的位置添加的<ul>
<li>原本 <code>A|BCD</code></li>
<li>调用 add 后（新增个 P）</li>
<li><code>AP|BCD</code> 注意迭代器的位置</li>
</ul>
</li>
<li>调用迭代器的 <code>remove</code> 方法是删除 <code>next</code> 方法或者 <code>previous</code> 方法返回的那个元素<ul>
<li>因此调用 next () 后，remove 方法删除的是迭代器左侧的元素</li>
<li>调用 previous 后，remove 方法删除的是迭代器右侧的元素</li>
</ul>
</li>
<li>同 <code>remove</code> 一样，迭代器的 <code>set</code> 方法</li>
</ul>
<h4 id="数组列表ArrayList"><a href="#数组列表ArrayList" class="headerlink" title="数组列表ArrayList"></a>数组列表ArrayList</h4><p><code>List</code> 接口用于描述一个有序集合，并且集合中每个元素的位置很重要。</p>
<p>访问元素的协议</p>
<ul>
<li>通过迭代器</li>
<li>通过 <code>get</code> 和 <code>set</code> 方法随机地访问每个元素（不适合链表）</li>
</ul>
<p><code>ArrayList</code> 封装了一个动态再分配的对象数组</p>
<p><strong><code>ArrayList</code> 与 <code>Vector</code></strong></p>
<ul>
<li>Vetor 类的所有方法都是同步的（并发线程）<ul>
<li>可以安全地从两个线程发访问一个 Vector 对象</li>
<li>只从一个线程访问 Vector 的话，代码会在同步操作浪费大量时间</li>
</ul>
</li>
<li> ArrayList 方法不是同步的</li>
</ul>
<h4 id="散列表HashMap"><a href="#散列表HashMap" class="headerlink" title="散列表HashMap"></a>散列表HashMap</h4><p>链表和数组允许指定元素次序，但是不知道具体位置则需要访问所有元素</p>
<p>如果不在意元素顺序，能够快速查找元素（缺点是无法控制元素出现的次序）</p>
<ul>
<li>散列表（hash table）<ul>
<li>为每个<strong>对象</strong>计算一个整数，用于快速查找</li>
</ul>
</li>
<li>散列码（hash code）<ul>
<li>对象的实例字段得出的整数</li>
</ul>
</li>
</ul>
<p>定义自己的类需要实现hashCode方法（5章），equals方法应与hashCode兼容。</p>
<p>Java中散列表用<strong>链表数组</strong>实现。每个列表被称为<strong>桶bucket</strong>。</p>
<p>结构示意图</p>
<p><img src="E:\学习资料\笔记\Java核心卷Ⅰ\image-20210114160934956.png" alt="image-20210114160934956"></p>
<p>要查找表中对象的位置</p>
<ul>
<li>计算该对象的散列码</li>
<li>散列码与<strong>桶的总数取余</strong></li>
<li>得到结果为保存该元素的桶的索引</li>
</ul>
<p><strong>散列冲突（hash collision）</strong>要插入元素时，桶已经被填充了。这时需要将新对象与桶中所有对象进行比较，查看这个对象是否存在。</p>
<p>如果散列码合理地随机分布，桶的数目足够大，需要比较的次数就会少</p>
<blockquote>
<p>在 Java8 中，桶满时会从<strong>链表</strong>变成<strong>平衡二叉树</strong>。</p>
<ul>
<li>散列函数选择不好，发生很多冲突。</li>
<li>恶意代码试图在散列表中填充多个相同散列码的值，这种情况下，改成平衡二叉树能提高性能</li>
</ul>
</blockquote>
<p><strong>桶数</strong>是用于收集有<strong>相同散列值</strong>的桶的<strong>数目</strong>（相同散列值的对象放在同一个桶中）（散列表的索引即为桶的索引）</p>
<p>可以指定一个初始的桶数（提高性能），桶数设置为预计元素个数的 75%~150%，标准类库使用的桶数试试 2 的幂，默认是 16</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap.java</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap.java</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">     * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">     * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">     * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//HashMap内部维护一个Node数组，同时该数组长度为2的幂</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap.java</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next; <span class="comment">// 可以看到这是一条链表</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>再散列（reshashed）</strong></p>
<ul>
<li>如果散列表太满，就需要再散列</li>
<li>创建一个桶数更多的表，将所有元素插入到新表，然后丢弃原来的表</li>
<li>装填因子（load factor）：确定何时对散列表进行再散列<ul>
<li>如果装填因子为 0.75（默认值），说明表中已经填满了 75% 以上，就会<strong>自动</strong>再散列，新表的桶数是原来的<strong>两倍</strong> </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">/ HashMap.java</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap.java</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        </span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li> HashMap 和 HashTable 区别？</li>
<li>HashMap是非线程同步的，HashTable是线程同步的。</li>
<li>HashMap允许null作为键或者值，HashTable不允许</li>
<li>HashTable中有个一个contains方法，HashMap去掉了此方法</li>
<li>效率上来讲，HashMap因为是非线程安全的，因此效率比HashTable高</li>
<li>hashTable继承Dictionary，而HashMap继承Abstract（实现Map接口）</li>
</ul>
<h4 id="散列集-HashSet"><a href="#散列集-HashSet" class="headerlink" title="散列集 HashSet"></a>散列集 HashSet</h4><p>集没有重复元素</p>
<p>Java类库中提供HashSet类，实现了基于散列表的集。</p>
<p>集允许快速地查找现有的元素。但是要查找一个元素，需要被查找元素的<strong>准确副本</strong></p>
<ul>
<li>集的 add 方法要先在集中查找要添加的对象，如果不存在，就添加这个对象 </li>
<li>contains用于查找某个元素是否已在集中（重新定义，只查看一个桶中的元素）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map; <span class="comment">// HashSet内部维护一个HashMap</span></span><br><span class="line">     </span><br><span class="line">    ...</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">   	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>散列集迭代器</strong>会依次访问所有的桶</p>
<p><strong>注意</strong></p>
<ul>
<li> HashSet 是一个 Set，存的是对象，而不是键值对（虽然 HashSet 里维护着一个 HashMap）</li>
<li>修改散列集中元素时，元素的散列码发生类改变，元素在数据结构中的位置也会改变。</li>
</ul>
<h4 id="树集TreeSet"><a href="#树集TreeSet" class="headerlink" title="树集TreeSet"></a>树集TreeSet</h4><p>树集是一个有序集合（sorted collection）。（当前排序时使用红黑树实现）</p>
<p>可以以<strong>任意顺序</strong>将元素<strong>插入</strong>到集合中，自动放置在正确排序位置上。迭代器总以有序顺序访问。</p>
<p>将一个元素添加到树集中要比<strong>添加</strong>到散列表中<strong>慢</strong>。查找新元素的正确位置平均需要 logn 次比较。</p>
<p>如果不需要数据是有序的，就没有必要付出排序的开销。</p>
<p>与<strong>检查</strong>数组或链表中的<strong>重复元素</strong>相比，使用树会<strong>快很多</strong>。树的排序必须全序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;String&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">ts.add(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">ts.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">ts.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">System.out.println(ts); <span class="comment">// [apple, cat, dog]</span></span><br><span class="line"><span class="keyword">for</span>(String s : ts) System.out.println(s); <span class="comment">//apple cat dog</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>要使用树集 TreeSet，<strong>必须</strong>能够比较元素。</p>
<p>这些元素必须实现 Comparable 接口，或者构造集时，必须提供一个 Comparator。（6章）</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Who&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        ts.add(<span class="keyword">new</span> Who(<span class="string">&quot;cool&quot;</span>)); <span class="comment">//ERROR java.lang.ClassCastException : CollectionTest.Who cannot be cast to java.lang.Comparable</span></span><br><span class="line">        ts.add(<span class="keyword">new</span> Who(<span class="string">&quot;good&quot;</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Who(<span class="string">&quot;bad&quot;</span>));</span><br><span class="line">        System.out.println(ts);</span><br><span class="line">        <span class="keyword">for</span>(Who s : ts) System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Who</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Who</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Who&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供 <code>Comparator</code></p>
<ul>
<li><code>TreeSet&lt;Who&gt; ts = new TreeSet&lt;&gt;((Who w1,Who w2) -&gt;w1.getName().compareTo(w2.getName()) );</code></li>
<li>new comparator方法（6章）</li>
</ul>
</blockquote>
<h4 id="队列-Queue-与-双端队列-Deque"><a href="#队列-Queue-与-双端队列-Deque" class="headerlink" title="队列 Queue 与  双端队列 Deque"></a>队列 Queue 与  双端队列 Deque</h4><ul>
<li>队列允许高效地在尾部添加元素，并在头部删除元素。</li>
<li>双端队列允许在头部和尾部都高效地添加或删除元素</li>
<li>队列不支持在中间添加元素</li>
</ul>
<p>ArrayList和LinkedList类实现了Deque接口（java6），两者都能提供双端队列，大小可以根据需要扩展。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>			</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ArrayDeque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">                           <span class="keyword">implements</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<h4 id="优先队列PriorityQueue"><a href="#优先队列PriorityQueue" class="headerlink" title="优先队列PriorityQueue"></a>优先队列PriorityQueue</h4><p>优先队列中的元素可以按<strong>任意顺序插入</strong>，但是会按照<strong>有序的顺序</strong>进行<strong>检索</strong></p>
<p>即调用 <code>remove</code> 方法，总会获得当前优先队列中<strong>最小的元素</strong></p>
<p>优先队列并没有对所有元素进行排序。</p>
<p>如果迭代处理这些元素，并不需要对它进行排序（看下方代码）</p>
<p>优先队列使用了堆（heap）（堆是自组织的二叉树），在添加（add）或删除（remove）操作可以让最小元素移动到根，而不必花费时间对元素进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;LocalDate&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">pq.add(LocalDate.of(<span class="number">1902</span>,<span class="number">12</span>,<span class="number">9</span>));</span><br><span class="line">pq.add(LocalDate.of(<span class="number">1804</span>,<span class="number">12</span>,<span class="number">29</span>));</span><br><span class="line">pq.add(LocalDate.of(<span class="number">1992</span>,<span class="number">2</span>,<span class="number">7</span>));</span><br><span class="line">pq.add(LocalDate.of(<span class="number">1202</span>,<span class="number">2</span>,<span class="number">9</span>));</span><br><span class="line"><span class="keyword">for</span>(LocalDate date : pq) System.out.println(date);<span class="comment">// 1202-02-09 1804-12-29 1992-02-07 1902-12-09</span></span><br><span class="line"><span class="keyword">while</span> (!pq.isEmpty()) System.out.println(pq.remove()); <span class="comment">// 1202-02-09 1804-12-29 1902-12-09 1992-02-07</span></span><br></pre></td></tr></table></figure>

<p>代码可以发现，add 操作后，堆顶总是最小元素。而 remove 操作的时候，堆顶也总是最小元素</p>
<p>优先队列的典型用法是任务调度。每个任务都有一个优先级，任务以随机顺序添加到队列中。每次启动一个新的任务时，都将优先级最高的任务从队列中删除。</p>
<p><strong>注意</strong></p>
<p>与 TreeSet 一样，优先队列</p>
<ul>
<li>既可以保存实现 Comparable 接口的类对像</li>
<li>也可以保存构造器中提供的 Comparator对象</li>
</ul>
<p>实践发现，如果没有实现这些接口，优先队列添加一个元素，还是能够正常保存，但是添加两个元素就抛出 <code>java.lang.ClassCastException: CollectionTest.Who cannot be cast to java.lang.Comparable</code></p>
<h3 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射 Map"></a>映射 Map</h3><p>集中要查找一个元素，需要有所要查找的那个元素的准确副本。</p>
<p>映射用来存放<strong>键 / 值</strong>对，主要方便通过关键信息查找与之关联的元素。</p>
<p>Java 类库位映射提供了两个通用的实现 <code>HashMap</code> 和 <code>TreeMap</code>。这两个类都实现了 <code>Map</code> 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取与键关联的值；返回与键关联的对象，如果映射中没有这个对象，则返回null。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得与键关联的值；返回与键关联的对象，如果未在映射中找到这个键，则返回defaultValue</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将关联的一对键和值放入映射中，如果这个键已经存在，新的对象将取代与这个键关联的旧对象。这个方法将返回键关联的旧值。如果之前没有这个键，则返回null。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对这个映射中的所有键/值对应用这个动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        comparator = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        comparator = <span class="keyword">null</span>;</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        comparator = m.comparator();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">firstKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key(getFirstEntry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">lastKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key(getLastEntry());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>散列映射（HashMap）对<strong>键</strong>进行<strong>散列</strong></p>
</li>
<li><p>树映射（TreeMap）根据键的顺序将元素组织为一个搜索树</p>
</li>
</ul>
<p><strong>散列</strong>或<strong>比较函数</strong>只应用于<strong>键</strong>，与键关联的值不进行散列或比较</p>
<ul>
<li>对于 HashMap，散列只对 key 键进行散列，value 是什么不会影响到散列</li>
<li>对于 TreeMap，里面元素的比较，只会比较键。</li>
</ul>
<p>散列稍快，<strong>不需要</strong>按照<strong>有序</strong>的顺序<strong>访问键</strong>，最好选择<strong>散列映射</strong>。</p>
<p>要想检索一个对象，必须<strong>使用键</strong></p>
<p>迭代处理映射的键和值，使用 <code>forEach</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((k,v)-&gt;</span><br><span class="line">           System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot;, valaue=&quot;</span> + v));</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ul>
<li>TreeMap 同 TreeSet 和 PriorityQueue 一样，需要要么存入的 Key 实现 <code>Comparable</code> 接口或者提供 <code>Comparator</code> 给构造器</li>
</ul>
<h4 id="更新映射条目"><a href="#更新映射条目" class="headerlink" title="更新映射条目"></a>更新映射条目</h4><p>对于一个映射进行更新 value 操作：<code>counts.put(word,counts.get(word)+1)</code>。如果是第一次放入 word，则会返回 null 而报出空指针异常。</p>
<p>解决办法</p>
<ul>
<li><p>```java<br>counts.put(word,counts.getOrDefault(word,0)+1);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;java</span><br><span class="line">  counts.putIfAbsent(word,0);  &#x2F;&#x2F;只有键原先不存在（或映射到null）才会放入另一个值。如果传入key对应的value已经存在，就返回存在的value，不进行替换。如果不存在，就添加key和value，返回null</span><br><span class="line">  counts.put(word,counts.get(word)+1);</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>counts.merge(word,1,Integer::sum); // 如果键原先不存在，则存入(word,1)，否则使用Integer::sum函数组合原值和1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  若键不存在，将word和1关联，否则使用Integer::sum函数组合原址和1</span><br><span class="line"></span><br><span class="line">#### 映射视图</span><br><span class="line"></span><br><span class="line">集合框架不认为映射本身是一个集合。</span><br><span class="line"></span><br><span class="line">但是映射的**视图view**，是实现了&#96;Collection&#96;接口或其某个子接口的对象。</span><br><span class="line"></span><br><span class="line">三种视图</span><br><span class="line"></span><br><span class="line">- 键集</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;java</span><br><span class="line">  Set&lt;K&gt; keySet()</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;例如</span><br><span class="line">  Set&lt;String&gt; keys &#x3D; map.keySet();</span><br></pre></td></tr></table></figure>

<p>keySet不是HashSet或TreeSet，而是实现Set接口的另外某个类的对象</p>
</li>
<li><p>值集合（不是集）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>键/值对集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()<span class="comment">//映射条目集的元素是实现了Map.Entry接口的类的对象</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> entry:map.entrySet())<span class="comment">//var&lt;=&gt;Map.Entry&lt;String,Employee&gt;,可使用var声明来避免笨拙的Map.Entry</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">map.forEach((K,V)-&gt;&#123;...&#125;)</span><br></pre></td></tr></table></figure>

<p>键和键/值对可以构成一个集，因为映射中一个键只能有一个副本</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">            keySet = ks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> Values();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>如果在键集视图上调用迭代器的remove方法，<strong>实际上会从映射中删除这个键和与他相关联的值</strong>。</p>
<p>不能向键集视图中田间元素。如果试图调用add方法，会抛出<code>UnsupportedOperationException</code></p>
<p><strong>映射条目集视图</strong>也有同样的限制</p>
<p>三种视图都可以删除元素，但是不可以添加元素</p>
<p>对于 <code>Map.Entry</code></p>
<ul>
<li><p><code>K getKey()</code></p>
</li>
<li><p><code>V getValue()</code></p>
</li>
<li><p>```<br>V setValue(V newValue)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  将相关映射中的值改为新值，并返回原来的值</span><br><span class="line"></span><br><span class="line">#### 弱散列映射WeakHashMap</span><br><span class="line"></span><br><span class="line">为解决</span><br><span class="line"></span><br><span class="line">如果有一个值，对应的键已经不再任何地方使用</span><br><span class="line"></span><br><span class="line">假定对某个键最后一个引用已经消失，不在有任何途径可以引用这个值的对象。但是由于程序中任何部分不会再有这个键，所以无法从映射中删除这个键值对。</span><br><span class="line"></span><br><span class="line">垃圾回收器会跟踪活动对象，只要映射对象是活动的，其中所有桶也是活动的，它们不能被回收。</span><br><span class="line"></span><br><span class="line">- 因此需要程序负责中长期存活的映射表中删除无用的值。</span><br><span class="line"></span><br><span class="line">- 或使用WeakHashMap。</span><br><span class="line"></span><br><span class="line">当对键的唯一引用来自散列表映射条目时，WeakHashMap将与垃圾回收器协同一起删除键&#x2F;值对</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public class WeakHashMap&lt;K,V&gt;</span><br><span class="line">    extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Reference queue for cleared WeakEntries</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final ReferenceQueue&lt;Object&gt; queue &#x3D; new ReferenceQueue&lt;&gt;();</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Expunges stale entries from the table.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void expungeStaleEntries() &#123;</span><br><span class="line">        for (Object x; (x &#x3D; queue.poll()) !&#x3D; null; ) &#123;</span><br><span class="line">            synchronized (queue) &#123;</span><br><span class="line">                </span><br><span class="line">                    Entry&lt;K,V&gt; e &#x3D; (Entry&lt;K,V&gt;) x;</span><br><span class="line">                int i &#x3D; indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">                Entry&lt;K,V&gt; prev &#x3D; table[i];</span><br><span class="line">                Entry&lt;K,V&gt; p &#x3D; prev;</span><br><span class="line">                while (p !&#x3D; null) &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next &#x3D; p.next;</span><br><span class="line">                    if (p &#x3D;&#x3D; e) &#123;</span><br><span class="line">                        if (prev &#x3D;&#x3D; e)</span><br><span class="line">                            table[i] &#x3D; next;</span><br><span class="line">                        else</span><br><span class="line">                            prev.next &#x3D; next;</span><br><span class="line">                        &#x2F;&#x2F; Must not null out e.next;</span><br><span class="line">                        &#x2F;&#x2F; stale entries may be in use by a HashIterator</span><br><span class="line">                        e.value &#x3D; null; &#x2F;&#x2F; Help GC</span><br><span class="line">                        size--;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev &#x3D; p;</span><br><span class="line">                    p &#x3D; next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>WeakHashMap使用<strong>弱引用WeakReference</strong>保存键，WeakReference对象包含另一个对象的引用。</p>
<p>垃圾回收器采用一种特有的方式处理这种类型对象。</p>
<ul>
<li>正常情况下，如果垃圾回收器发现某个对象已经没有他人引用了，就将其回收。</li>
<li>如果一个对象只能由 WeakReference引用，垃圾回收器也会将其回收，但会将引用这个对象的弱引用<strong>放入一个队列</strong>。<ul>
<li><code>WeakHashMap</code> 周期性的检查队列，以便找出新添加的弱引用。</li>
<li>一个弱引用进入队列意味着这个<strong>键</strong>不再被他人使用，并且已经回收，<code>WeakHashMap</code> 将删除先关联的映射条目</li>
</ul>
</li>
</ul>
<h4 id="链接散列集与映射-LinkedHashSet-LinkedHashMap"><a href="#链接散列集与映射-LinkedHashSet-LinkedHashMap" class="headerlink" title="链接散列集与映射 LinkedHashSet LinkedHashMap"></a>链接散列集与映射 LinkedHashSet LinkedHashMap</h4><p><code>LinkedHashSet</code> 和 <code>LinkedHashSMap</code> 类会记住插入<strong>元素项</strong>的顺序，避免散列表中的项看起来顺序是随机的。插入时会并入双向链表中。</p>
<p>结构示意图如下</p>
<p><img src="E:\学习资料\笔记\Java核心卷Ⅰ\image-20210115161827576.png" alt="image-20210115161827576"></p>
<p>除了按照插入顺序外，链接散列表映射可以使用访问顺序，而不是插入顺序来迭代处理映射条目。</p>
<ul>
<li>每次调用 get或 put时，收到影响的项将从当前的位置删除，并放到项链表的尾部。<ul>
<li><strong>只影响</strong>项在<strong>链表</strong>中的<strong>位置</strong>，而<strong>散列表的桶不会受影响</strong>。映射条目总是在键散列码对应的桶中。</li>
</ul>
</li>
</ul>
<p><strong>访问顺序</strong>对实现缓存的 <strong>“最近最少使用”</strong> 原则十分重要。</p>
<p>例如为提高性能可以</p>
<ul>
<li>将访问频率高的元素放入内存，而访问频率低的元素从数据库中读取</li>
<li>当表中找不到元素项而且表相当满时，可以得到迭代器并删除它，枚举的前几个元素 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可重写 removeEldestEntry 来实现自动删除 eldest 项</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="枚举集与映射EnumSet-EnumMap"><a href="#枚举集与映射EnumSet-EnumMap" class="headerlink" title="枚举集与映射EnumSet EnumMap"></a>枚举集与映射EnumSet EnumMap</h4><p>EnumSet是一个枚举类型元素集的高效实现。</p>
<p>由于枚举类型只有有限个实例 i，所以 <code>EnumSet</code> 内部用<strong>位序列</strong>实现。如果对应的值在集中，则相应的位置为 1</p>
<p><code>EnumSet</code> 类没有公共构造器，用<strong>静态工厂方法</strong>构造集</p>
<p>注意：Java8 不允许在定义局部枚举类，即在方法内定义内</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">WeekDay</span> </span>&#123;MONDAY ,TUESDAY, WEDENESDAY,  THURSDAY, FRIDAY,SATURDAY, SUNDAY&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EnumSet&lt;WeekDay&gt; always = EnumSet.allOf(WeekDay.class);</span><br><span class="line">EnumSet&lt;WeekDay&gt; never = EnumSet.noneOf(WeekDay.class);</span><br><span class="line">EnumSet&lt;WeekDay&gt; workday = EnumSet.range(WeekDay.MONDAY,WeekDay.FRIDAY);</span><br><span class="line">EnumSet&lt;WeekDay&gt; mwf = EnumSet.of(WeekDay.MONDAY,WeekDay.WEDENESDAY,WeekDay.FRIDAY);</span><br><span class="line">System.out.println(always);<span class="comment">//[MONDAY, TUESDAY, WEDENESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY]</span></span><br><span class="line">System.out.println(never);<span class="comment">//[]</span></span><br><span class="line">System.out.println(workday);<span class="comment">//[MONDAY, TUESDAY, WEDENESDAY, THURSDAY, FRIDAY]</span></span><br><span class="line">System.out.println(mwf);<span class="comment">//[MONDAY, WEDENESDAY, FRIDAY]</span></span><br></pre></td></tr></table></figure>

<p>可使用Set接口的常用方法修改EnumSet</p>
<blockquote>
<p>EnumSet API文档中，E extends Enum<E>表示E是一个枚举类型，所有的枚举类型都继承或扩展了泛型Enum类。如Weekday扩展了Enum<Weekday></p>
</blockquote>
<hr>
<p>EnumMap是一个键类型为枚举类型的映射。</p>
<p>可以高效且直接的实现为一个值数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> personInCharge = <span class="keyword">new</span> EnumMap&lt;Weekday,Empluyee&gt;(Weekday.class);<span class="comment">//需要在构造器中指定键的类型</span></span><br></pre></td></tr></table></figure>

<h4 id="标识散列映射-IdentityHashMap"><a href="#标识散列映射-IdentityHashMap" class="headerlink" title="标识散列映射 IdentityHashMap"></a>标识散列映射 IdentityHashMap</h4><p>这个类中键的散列值不是用hashCode函数计算的，而是用<code>System.identityHashCode</code>方法计算。</p>
<p>这是Object.hashCode根据对象的<strong>内存地址</strong>计算散列码使用的方法。</p>
<p>所有在进行比较时，IdentityHashMap类**使用<code>==</code>**而不是equals。</p>
<p>这个类中不同的键对象即使内容相同，也被视为不同的对象。</p>
<p>实现对象遍历算法（如对象串行化），可以用来跟踪哪些对象已经遍历过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdentityHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object x, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = System.identityHashCode(x);</span><br><span class="line">        <span class="comment">// Multiply by -127, and left-shift to use least bit as part of hash</span></span><br><span class="line">        <span class="keyword">return</span> ((h &lt;&lt; <span class="number">1</span>) - (h &lt;&lt; <span class="number">8</span>)) &amp; (length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h3><p>可以使用视图view获得其他实现了Collection接口或Map接口的对象。</p>
<p>例如<code>KeySet</code> 方法返回一个实现了 <code>Set</code> 接口的类对象，由这个类方法操纵原映射。这种集合称为视图</p>
<h4 id="小集合"><a href="#小集合" class="headerlink" title="小集合"></a>小集合</h4><p>Java9引入一些静态方法，可生成给定元素的列表或集以及键/值对映射。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;  names= List.of(<span class="string">&quot;Peter&quot;</span>,<span class="string">&quot;Pual&quot;</span>);</span><br><span class="line">Set&lt;Integer&gt; numbers = Set.of(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">MapMap&lt;String,Integer&gt; scores = Map.of(<span class="string">&quot;Peter&quot;</span>,<span class="number">2</span>,<span class="string">&quot;Pual&quot;</span>,<span class="number">3</span>);<span class="comment">//元素，键，值不能为null</span></span><br></pre></td></tr></table></figure>

<p>提供这种特性是为了提高效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Map.*;</span><br><span class="line">...</span><br><span class="line">MapMap&lt;String,Integer&gt; scores = ofEntries(</span><br><span class="line">entry(<span class="string">&quot;peter&quot;</span>,<span class="number">2</span>),</span><br><span class="line">entry(<span class="string">&quot;pual&quot;</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<p>这些集合对象是不可修改的。尝试修改会抛出UnsupportedOperationException异常。</p>
<p>需要可修改集合要将，这个不可修改集合传到构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> ArrayList&lt;&gt;(List.of(<span class="string">&quot;p&quot;</span>,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;a&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>方法<code>Collections.nCopies(n,anObject)</code>会返回一个实现List接口的不可变对象。</p>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; settings &#x3D; Collections.nCopies(100,&quot;DEFAULT&quot;);&#x2F;&#x2F;这样存储开销很小，对象只存储一次</span><br></pre></td></tr></table></figure>

<blockquote>
<p>of方法是Java9新引入的。</p>
<p>Collections类包含很多实用方法，参数返回值都是集合。不要将它和Colletion接口混淆</p>
<p>java没有pair类。可使用Map.Entry作为对组（pair）但这种方法不好。</p>
</blockquote>
<h4 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h4><p>可以为很多集合建立<strong>子范围subrange</strong>视图。</p>
<p>例如取出10-19个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; group2 = staff.subList(<span class="number">10</span>,<span class="number">20</span>);<span class="comment">//索引左闭右开，与String.subString()类似</span></span><br><span class="line"><span class="comment">//清楚</span></span><br><span class="line">group2.clear();</span><br></pre></td></tr></table></figure>

<p>所有对子范围的操作都会自动反映到整个列表。</p>
<p>对有序集和映射可以用排序顺序而不是元素位置建立子范围。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public interface SortedSet&lt;E&gt; extends Set&lt;E&gt;</span></span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span></span>;</span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span></span>;</span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; 、</span></span><br><span class="line"><span class="function">SortedMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K fromKey, K toKey)</span></span>;</span><br><span class="line"><span class="function">SortedMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K toKey)</span></span>;</span><br><span class="line"><span class="function">SortedMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K fromKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public interface NavigableSet&lt;E&gt; extends SortedSet&lt;E&gt; </span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> fromInclusive,</span></span></span><br><span class="line"><span class="function"><span class="params">                           E toElement,   <span class="keyword">boolean</span> toInclusive)</span></span>;</span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement, <span class="keyword">boolean</span> inclusive)</span></span>;</span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> inclusive)</span></span>;</span><br><span class="line"><span class="comment">//这些方法返回大于from小于to 的所有元素构成的子集，NavigableSet还可指定是否包含边界</span></span><br></pre></td></tr></table></figure>

<h4 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h4><p><code>Collections</code> 类中，有方法可以生成集合的<strong>不可修改视图（unmodifiable view）</strong></p>
<p>这些视图对现有集合增加了一个运行时检查，如果发现试图对集合修改，就抛出异常，集合仍保持不变。</p>
<p>一下8个方法获得不可修改视图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public class Collections </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">unmodifiableCollection</span><span class="params">(Collection&lt;? extends T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableCollection&lt;&gt;(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">unmodifiableSet</span><span class="params">(Set&lt;? extends T&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableSet&lt;&gt;(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">SortedSet&lt;T&gt; <span class="title">unmodifiableSortedSet</span><span class="params">(SortedSet&lt;T&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableSortedSet&lt;&gt;(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">NavigableSet&lt;T&gt; <span class="title">unmodifiableNavigableSet</span><span class="params">(NavigableSet&lt;T&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableNavigableSet&lt;&gt;(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">unmodifiableList</span><span class="params">(List&lt;? extends T&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">            <span class="keyword">new</span> UnmodifiableRandomAccessList&lt;&gt;(list) :</span><br><span class="line">            <span class="keyword">new</span> UnmodifiableList&lt;&gt;(list));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">unmodifiableMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableMap&lt;&gt;(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">SortedMap&lt;K,V&gt; <span class="title">unmodifiableSortedMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableSortedMap&lt;&gt;(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">NavigableMap&lt;K,V&gt; <span class="title">unmodifiableNavigableMap</span><span class="params">(NavigableMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableNavigableMap&lt;&gt;(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>视图只是<strong>包装</strong>了<strong>接口</strong>而不是具体的集合对象，所以<strong>只能访问接口中定义的方法</strong>。</p>
<p>例如 <code>LinkedList</code> 类的 <code>addFirst</code> 和 <code>addList</code> 由于不是 <code>List</code> 接口的方法，不能通过不可修改的视图访问这些方法。</p>
<p>unmodifiableCollection（syncchronizedCollection、checkedCollection）将返回一个集合，它的equals方法不调用底层集合的equals方法，而是Object类的equals方法（只检测两个对象是否是一个对象）。</p>
<p>如果将集或列表转换成集合，就再也无法检测其内容是否相同（而是判断是否为同一个对象）。视图采用这种工作方式</p>
<p>但是<code>unmodifiableSet</code> 和 <code>unmodifiableList</code> 方法使用底层集合的 <code>equals</code> 方法和 <code>hashCode</code> 方法</p>
<h4 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h4><p>通过视图机制来确保常规集合是线程安全的，而没有实现线程安全的集合类。</p>
<ul>
<li><p><code>Collections</code> 类的静态 <code>synchhronizedMap</code> 方法可以将任何一个映射转换成有同步访问方法的 Map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String,Employee&gt;());</span><br></pre></td></tr></table></figure>

<p>对map多线程访问时，类似get、put等方法都是同步的，即每个方法完全调用结束另一个线程才能调用另一个方法。</p>
</li>
</ul>
<h4 id="检查型视图"><a href="#检查型视图" class="headerlink" title="检查型视图"></a>检查型视图</h4><p>检查型视图对泛型类型可能出现的问题提供调试支持。</p>
<ul>
<li>将错误类型的元素混入泛型集合中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; safeStrings = Collections.checkedList(strings,String.class)</span><br><span class="line"><span class="comment">//这个视图的add方法将检查插入对象是否属于给定类，会在正确位置报告错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>检查型视图受限于虚拟机可以完成的运行时检查。对于 ArrayList<Pair>，无法阻止插入 Pair</p>
</blockquote>
<h4 id="关于可选操作的一些说明"><a href="#关于可选操作的一些说明" class="headerlink" title="关于可选操作的一些说明"></a>关于可选操作的一些说明</h4><p>视图会有一些限制，如只读、无法改变大小、只支持删除不支持插入（键映射视图）</p>
<p>在API文档中，许多方法描述为可选操作（与接口概念冲突）。</p>
<p>类库中是为方便实用。自己设计编码时最好不要。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>Collections类中提供一些简单常用算法。详见p416</p>
<h4 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h4><p>通过接口（interface）。泛型集合接口一个优点是，算法只需要实现一次。</p>
<p>考虑高效地执行这个算法所需要的<strong>最小集合接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受任何实现Collecton接口的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">max</span><span class="params">(Collection&lt;T&gt; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c.isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Iterator&lt;T&gt; iter = c.iterator();</span><br><span class="line">    T largest = iter.next();</span><br><span class="line">    <span class="keyword">while</span>(iter.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        T next = iter.next();</span><br><span class="line">        <span class="keyword">if</span>(largest.compareTo(next) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            largest = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> largest;z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="排序与混排"><a href="#排序与混排" class="headerlink" title="排序与混排"></a>排序与混排</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Collections.sort(staff);</span><br><span class="line"></span><br><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">staff.sort(Comparator.reverseOrder())</span><br><span class="line"></span><br><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary).reversed());</span><br></pre></td></tr></table></figure>

<p>Java 是将所有元素转入一个<strong>数组</strong>，将<strong>数组进行排序</strong>，然后再将排序后的序列<strong>复制回列表</strong></p>
<p>要排序的列表，列表必须是<strong>可修改</strong>的，但不一定可以改变大小</p>
<ul>
<li>如果列表支持 <code>set</code> 方法，则是可修改的（modifiable）</li>
<li>如果列表支持 <code>add</code> 和 <code>remove</code> 方法，则是可改变大小的（resizable）</li>
</ul>
<p>Collections类有一个算法shuffle算法，用于随机打乱列表顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Card&gt; cards &#x3D; ...;</span><br><span class="line">Collections.shuffle(cards);</span><br></pre></td></tr></table></figure>

<p>如果提供的列表没有实现RandomAccess接口，shuffle会将元素复制进数组，打乱数组然后复制回列表。</p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p><code>Collections</code> 类的 <code>binarySearch</code> 要求</p>
<ul>
<li>集合<strong>必须</strong>是有序的。</li>
<li>要查找某个元素，必须提供集合（集合要实现 <code>List</code> 接口）以及要查找的元素</li>
<li>如果集合没有采用 <code>Comparable</code> 接口，需要提供比较器对象。</li>
<li>只有采用随机访问，二分查找才有意义。如果提供链表，则退化为线性查找</li>
</ul>
<p>对于没有查找到的元素，可以利用返回值来计算应该将element元素插入位置,保证有序性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	c.add(-i-<span class="number">1</span>,element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="批操作"><a href="#批操作" class="headerlink" title="批操作"></a>批操作</h4><p>成批的进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coll1.removeAll(coll2);<span class="comment">//coll1中删除coll2中出现的元素</span></span><br><span class="line">coll1.retainAll(coll2);<span class="comment">//coll1中删除未在coll2中出现的元素</span></span><br></pre></td></tr></table></figure>

<p>对视图进行批操作</p>
<p>通过使用子范围视图可以方便的完成数据成批的操作</p>
<h4 id="集合与数组的转换"><a href="#集合与数组的转换" class="headerlink" title="集合与数组的转换"></a>集合与数组的转换</h4><p><code>toArray</code> 方法得到的结果是对象（Object）数组</p>
<p><code>Object[] values = staff.toArray()</code>;</p>
<p>而强制类型转换是不允许的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] values = (String[]) staff.toArray(); <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>

<p>可以使用 <code>toArray</code> 方法的变体，提供一个指定类型且长度为 0 的数组。返回的数组就会创建为相同的数组类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public interface List&lt;E&gt; extends Collection&lt;E&gt;</span></span><br><span class="line">Object[] toArray();</span><br><span class="line">&lt;T&gt; T[] toArray(T[] a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span></span><br><span class="line"><span class="comment">//        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<span class="comment">//有双重职责，填充和创建</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">words.add(<span class="string">&quot;cool&quot;</span>);</span><br><span class="line">words.add(<span class="string">&quot;bad&quot;</span>);</span><br><span class="line">words.add(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">String[] values = words.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);<span class="comment">//指定一个长度为0（其他也可）的数组</span></span><br><span class="line"></span><br><span class="line">String[] values = words.toArray(<span class="keyword">new</span> String[words.size()]);<span class="comment">//正确长度数组也可</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>以下是<strong>不允许</strong>的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ans.add(<span class="number">1</span>);</span><br><span class="line">ans.add(<span class="number">2</span>);</span><br><span class="line">ans.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">int</span>[] result = ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>]); <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>

<p>报错原因</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Required type: T[]</span><br><span class="line">Provided: <span class="keyword">int</span>[]</span><br><span class="line">reason: <span class="function">no <span class="title">instance</span><span class="params">(s)</span> of type <span class="title">variable</span><span class="params">(s)</span> T exist so that <span class="keyword">int</span>[] conforms to T[]</span></span><br><span class="line"><span class="function">即基本类型不能转换成类型变量</span></span><br></pre></td></tr></table></figure>

<h3 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h3><h4 id="HashTable-类"><a href="#HashTable-类" class="headerlink" title="HashTable 类"></a>HashTable 类</h4><ul>
<li><code>HashTable</code> 类和 <code>HashMap</code> 类的作用一样，接口也基本相同。</li>
<li><code>HashTable</code> 类和 <code>Vector</code> 类的方法都是同步的</li>
</ul>
<p>对遗留代码没有兼容性需求，应该使用 <code>HashMap</code></p>
<p>如果需要并发访问，使用 <code>ConcurrentHashMap</code></p>
<h4 id="枚举-Enumeration"><a href="#枚举-Enumeration" class="headerlink" title="枚举 Enumeration"></a>枚举 Enumeration</h4><p>遗留的结合使用 Enumeration 接口遍历元素序列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Enumeration</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">nextElement</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似 <code>Iterator</code> 接口的 <code>hasNext</code> 方法和 <code>next</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;java9中枚举转换为迭代器</span><br><span class="line">LogManager.getLoggerNames().asIterator().forEachRemainimg(n-&gt;&#123;...&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="属性映射-Properties"><a href="#属性映射-Properties" class="headerlink" title="属性映射 Properties"></a>属性映射 Properties</h4><p>属性映射（property map）是一个特殊类型的映射结构</p>
<ul>
<li>键和值都是字符串</li>
<li>这个映射可以很容易保存到文件以及从人间加载</li>
<li>有一个<strong>二级表</strong>存放<strong>默认值</strong></li>
</ul>
<p>属性映射的类名为 <code>Properties</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Properties</span> <span class="keyword">extends</span> <span class="title">Hashtable</span>&lt;<span class="title">Object</span>,<span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Properties</span> <span class="title">settings</span> </span>= <span class="keyword">new</span> Properties();</span><br><span class="line">settings.setProperty(<span class="string">&quot;width&quot;</span>,<span class="string">&quot;600.0&quot;</span>);</span><br><span class="line">settings.setProperty(<span class="string">&quot;filename&quot;</span>,<span class="string">&quot;/home/qibin/cool.txt&quot;</span>);</span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;program.properties&quot;</span>);</span><br><span class="line">settings.store(fileOutputStream,<span class="string">&quot;Program Properties&quot;</span>); <span class="comment">//第二个参数为文件中的注释</span></span><br></pre></td></tr></table></figure>

<p>program.properties 文件内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#Program Properties</span><br><span class="line">#Wed Dec 09 21:48:06 CST 2020</span><br><span class="line">filename&#x3D;&#x2F;home&#x2F;qibin&#x2F;cool.txt</span><br><span class="line">width&#x3D;600.0</span><br><span class="line">System.getProperties()</span><br></pre></td></tr></table></figure>

<p><code>Properties</code>没有层次结构</p>
<p>如果要储存复杂的配置信息，应该使用 <code>Preferences</code> 类（10章）</p>
<h4 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h4><p><code>Stack</code> 类扩展了 <code>Vector</code> 类，但是可以使用非栈操作 <code>insert</code> 和 <code>remove</code> 方法在任何地方插入和删除值，而不只是在栈顶</p>
<h4 id="位集-BitSet"><a href="#位集-BitSet" class="headerlink" title="位集 BitSet"></a>位集 BitSet</h4><p><code>BitSet</code> 类用于储存一个<strong>位序列</strong>（不是数学意义上的集，更恰当说法为<strong>位向量</strong>或<strong>位数组</strong>）</p>
<p>高效地储存位序列（如标志）就可以使用位集。使用位集要比使用 <code>Boolean</code> 对象的 <code>ArrayList</code> 高效多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">BitSet bucketOfBits = <span class="keyword">new</span> BitSet();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//第i位处于”开“状态返回true,否则返回false</span></span><br><span class="line">System.out.println(bucketOfBits.get(i));<span class="comment">//false</span></span><br><span class="line"><span class="comment">//将第i位 置为”开“状态</span></span><br><span class="line">bucketOfBits.set(i);</span><br><span class="line">System.out.println(bucketOfBits.get(i));<span class="comment">//true</span></span><br><span class="line"><span class="comment">//将第i位 置为”关“状态</span></span><br><span class="line">bucketOfBits.clear(i);</span><br><span class="line">System.out.println(bucketOfBits.get(i));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//public class BitSet implements Cloneable, java.io.Serializable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回位集的逻辑长度，即1+位集最高位的索引</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (wordsInUse == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BITS_PER_WORD * (wordsInUse - <span class="number">1</span>) +</span><br><span class="line">            (BITS_PER_WORD - Long.numberOfLeadingZeros(words[wordsInUse - <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//与另一个位集进行逻辑与</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">and</span><span class="params">(BitSet set)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">or</span><span class="params">(BitSet set)</span> </span>&#123; <span class="comment">//逻辑或</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xor</span><span class="params">(BitSet set)</span> </span>&#123;<span class="comment">//异或</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">andNot</span><span class="params">(BitSet set)</span> </span>&#123; <span class="comment">//对应另一个位集中设置为1的所有位，将这个位集中相应的位清楚为0</span></span><br><span class="line">    <span class="comment">// Perform logical (a &amp; !b) on words in common</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://example.com/2021/03/28/%E9%9B%86%E5%90%88/" title="集合" target="_blank" rel="external">http://example.com/2021/03/28/%E9%9B%86%E5%90%88/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/hs-jose" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/hs-jose" target="_blank"><span class="text-dark">hs</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/28/Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/" title="Java基本程序设计结构"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/28/%E5%B9%B6%E5%8F%91/" title="并发"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button">
        <span>[&nbsp;</span><span>Catalogue</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/hs-jose" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>