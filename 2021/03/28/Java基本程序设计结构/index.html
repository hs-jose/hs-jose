<!DOCTYPE html>
<html lang=ch>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Java基本程序设计结构 | Hesai&#39;s Blog</title>
  <meta name="description" content="Java基本程序设计结构命名规范 类名以大写字母开头的名词 FirstExample，每个单词第一个字母大写。（大驼峰命名法）  注释 &#x2F;&#x2F; 常用方式，到行尾  &#x2F;*     *&#x2F;  &#x2F;**    *&#x2F; 自动生成文档   数据类型java强类型语言 8中基本类型，4整型，2浮点型，1字符型，1布尔型 整型   类型 存储大小 取值范围    int 4 byte -2147483648，21474">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基本程序设计结构">
<meta property="og:url" content="http://example.com/2021/03/28/Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Hesai&#39;s blog">
<meta property="og:description" content="Java基本程序设计结构命名规范 类名以大写字母开头的名词 FirstExample，每个单词第一个字母大写。（大驼峰命名法）  注释 &#x2F;&#x2F; 常用方式，到行尾  &#x2F;*     *&#x2F;  &#x2F;**    *&#x2F; 自动生成文档   数据类型java强类型语言 8中基本类型，4整型，2浮点型，1字符型，1布尔型 整型   类型 存储大小 取值范围    int 4 byte -2147483648，21474">
<meta property="og:locale">
<meta property="og:image" content="c:/Users/qj/AppData/Roaming/Typora/typora-user-images/image-20201127201841319.png">
<meta property="article:published_time" content="2021-03-28T15:05:01.868Z">
<meta property="article:modified_time" content="2021-03-28T15:40:18.964Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="tags">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/qj/AppData/Roaming/Typora/typora-user-images/image-20201127201841319.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://example.com/2021/03/28/Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hesai&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/hs-jose" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">hs</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/hs-jose" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>记录知识</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E2%85%A0/">Java核心技术 Ⅰ</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E2%85%A1/">Java核心技术 Ⅱ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%85%A0-%E6%B7%BB%E5%8A%A0%E5%8D%9A%E6%96%87%E5%88%86%E7%B1%BB/">Java核心技术Ⅰ# 添加博文分类</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%85%A1/">Java核心技术Ⅱ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/effective-Java/">effective Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/">深入理解JVM</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/tags/" rel="tag">tags</a><span class="tag-list-count">13</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/tags/" style="font-size: 13px;">tags</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/">深入理解JVM</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/" class="title">Java内存区域与内存溢出异常</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:25.905Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/">深入理解JVM</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" class="title">垃圾收集器与内存分配策略</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:25.905Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/effective-Java/">effective Java</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%AF%B9%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/" class="title">通用方法</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:16.515Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/effective-Java/">effective Java</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/" class="title">创建和销毁对象</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:16.515Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%85%A0-%E6%B7%BB%E5%8A%A0%E5%8D%9A%E6%96%87%E5%88%86%E7%B1%BB/">Java核心技术Ⅰ# 添加博文分类</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/" class="title">异常、断言和日志</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:01.868Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">Catalogue</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">Java基本程序设计结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">1.0.1.</span> <span class="toc-text">命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.0.2.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.3.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#char%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">char类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8D%95%E5%85%83%E5%92%8C%E7%A0%81%E7%82%B9"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">代码单元和码点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#boolean%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.3.5.</span> <span class="toc-text">boolean类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F"><span class="toc-number">1.0.4.</span> <span class="toc-text">变量和常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.5.</span> <span class="toc-text">枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97"><span class="toc-number">1.0.6.</span> <span class="toc-text">运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">数值类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.0.6.4.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.0.6.5.</span> <span class="toc-text">扩展运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7"><span class="toc-number">1.0.6.6.</span> <span class="toc-text">运算符的优先级和结合性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.0.7.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API%E6%96%87%E6%A1%A3"><span class="toc-number">1.0.8.</span> <span class="toc-text">API文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">1.0.9.</span> <span class="toc-text">输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">1.0.10.</span> <span class="toc-text">文件输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.0.11.</span> <span class="toc-text">程序控制语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0"><span class="toc-number">1.0.12.</span> <span class="toc-text">大数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.13.</span> <span class="toc-text">数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">对象与类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7"><span class="toc-number">2.0.0.1.</span> <span class="toc-text">类设计技巧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.0.2.</span> <span class="toc-text">成员与方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%9F%9F%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.0.3.</span> <span class="toc-text">静态域与静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0"><span class="toc-number">2.0.0.4.</span> <span class="toc-text">对象构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E8%B7%AF%E5%BE%84-JAR"><span class="toc-number">2.0.0.5.</span> <span class="toc-text">类路径 JAR</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E3%80%81%E8%B6%85%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">类、超类和子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">覆盖方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">3.1.2.</span> <span class="toc-text">子类构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%B1%82%E6%AC%A1"><span class="toc-number">3.1.3.</span> <span class="toc-text">继承层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">3.1.4.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">3.1.5.</span> <span class="toc-text">动态绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.6.</span> <span class="toc-text">方法调用过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E7%BB%A7%E6%89%BF%EF%BC%9Afinal-%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.7.</span> <span class="toc-text">阻止继承：final 类和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.8.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">3.1.9.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">3.1.10.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7"><span class="toc-number">3.1.11.</span> <span class="toc-text">继承的设计技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.11.1.</span> <span class="toc-text">子类方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-number">3.1.12.</span> <span class="toc-text">Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#equals%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.12.1.</span> <span class="toc-text">equals方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">3.1.12.2.</span> <span class="toc-text">相等测试与继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashcode%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.12.3.</span> <span class="toc-text">hashcode方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#toString%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.12.4.</span> <span class="toc-text">toString方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8"><span class="toc-number">3.1.13.</span> <span class="toc-text">泛型数组列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-ArrayList-%E5%85%83%E7%B4%A0"><span class="toc-number">3.1.13.1.</span> <span class="toc-text">访问 ArrayList 元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1"><span class="toc-number">3.1.14.</span> <span class="toc-text">对象包装器与自动装箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E6%96%B9%E6%B3%95-%E5%8F%98%E5%8F%82-varargs-%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.15.</span> <span class="toc-text">参数数量可变的方法  变参 (varargs) 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">3.1.16.</span> <span class="toc-text">枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">3.1.17.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%82%E5%B8%B8%E5%85%A5%E9%97%A8"><span class="toc-number">3.1.17.1.</span> <span class="toc-text">声明异常入门</span></a></li></ol></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Java基本程序设计结构" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Java基本程序设计结构
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/28/Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/" class="article-date">
	  <time datetime="2021-03-28T15:05:01.868Z" itemprop="datePublished">2021-03-28</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E2%85%A0/">Java核心技术 Ⅰ</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/tags/" rel="tag">tags</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/28/Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/#comments" class="article-comment-link">Comments</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="Java基本程序设计结构"><a href="#Java基本程序设计结构" class="headerlink" title="Java基本程序设计结构"></a>Java基本程序设计结构</h1><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul>
<li>类名以大写字母开头的名词 <code>FirstExample</code>，每个单词第一个字母大写。（大驼峰命名法）</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol>
<li><p>//</p>
<p>常用方式，到行尾</p>
</li>
<li><p>/*     */</p>
</li>
<li><p>/**    */</p>
<p>自动生成文档</p>
</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>java强类型语言</p>
<p>8中基本类型，4整型，2浮点型，1字符型，1布尔型</p>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>存储大小</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>4 byte</td>
<td>-2147483648，2147483647</td>
</tr>
<tr>
<td>short</td>
<td>2 byte</td>
<td>-32768，32767</td>
</tr>
<tr>
<td>long</td>
<td>8 byte</td>
<td>-9223372036854775808，9223372036854775807</td>
</tr>
<tr>
<td>byte</td>
<td>1 byte</td>
<td>-128，127</td>
</tr>
</tbody></table>
<p>长整型数值后缀为L或l 如<code>4000000000L</code></p>
<p>java7开始加上前缀0B或0b可以直接写二进制。</p>
<p>java中整型大小与机器无关</p>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>存储大小</th>
<th>取值范围</th>
<th>后缀</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4 byte</td>
<td>有效位约为6 7位</td>
<td>F f</td>
</tr>
<tr>
<td>double</td>
<td>8 byte</td>
<td>有效位15</td>
<td>D d</td>
</tr>
</tbody></table>
<p>IEEE 754规范</p>
<h4 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h4><p>有的unicode可用一个char值表示，有些需要2个char值表示</p>
<p>char类型描述UTF-16编码中的一个代码单元 （16 bit）</p>
<p>转义字符</p>
<p>。。。</p>
<table>
<thead>
<tr>
<th>转义序列</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>\u….(4个16进制数）转义在注释中生效。</p>
<h4 id="代码单元和码点"><a href="#代码单元和码点" class="headerlink" title="代码单元和码点"></a>代码单元和码点</h4><p><strong>码点</strong>：一个编码表中的某个字符对应的代码值。Unicode标准中采用16进制书写，前缀U+。</p>
<p><strong>Unicode的码点分为17个代码平面</strong></p>
<ul>
<li><p>第一个级别是基本的多语言平面，码点从U+0000——U+FFFF</p>
<p>每个字符用16位表示<strong>代码单元</strong></p>
</li>
<li><p>其余16个级别从U+10000——U+10FFFF，其中包括一些辅助字符。</p>
<p>辅助字符采用连续的<strong>一对连续代码单元</strong>进行编码。</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>𝕆是一个辅助字符，实际占用两个char，这个字符串中总共有4个char，3个代码点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        String hello &#x3D; &quot;hi𝕆&quot;;</span><br><span class="line">        System.out.println(hello.length());&#x2F;&#x2F;4</span><br><span class="line">        System.out.println(hello.codePointCount(0, hello.length()));&#x2F;&#x2F;3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h4><p>java中整型值和布尔值不能进行相互转换。</p>
<h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><p>声明一个变量后，必须用赋值语句进行显式初始化。</p>
<p>变量声明尽可能靠近第一次使用变量的地方。</p>
<p>java 10 中 对于可以从初始值推断出类型的局部变量，可不声明类型。使用var 如<code>var str = &quot;hello&quot;</code></p>
<p><strong>常量</strong></p>
<ul>
<li><p>java使用关键字<strong>final</strong>指示常量。final表示该变量只能被赋值一次。</p>
</li>
<li><p>常量名一般使用全大写</p>
</li>
<li><p>类常量（一个类中多个方法使用）使用<strong>static final</strong>设置。</p>
<p>注意 类常量定义位于main方法外部。同一个类中其他方法可以使用这个常量。如果常量被声明为public，其他类的方法也可以使用这个常量。</p>
</li>
</ul>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举类型包括有限个命名的值</p>
<p>例子</p>
<p><code>emun Size &#123;SMALL，MEDIUM，LARGE，EXTERA_LARGE&#125;;</code></p>
<p>声明Size类型 <code>Size s = Size.SMALL;</code></p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>Math类中包含各种数学函数，常量。</p>
<p>floorMod方法解决整数余数为负。</p>
<h4 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h4><p><img src="C:\Users\qj\AppData\Roaming\Typora\typora-user-images\image-20201127201841319.png" alt="image-20201127201841319"></p>
<p>实线箭头表示 无信息丢失转换</p>
<p>虚线箭头表示 可能有精度损失转换                                                                                                                    </p>
<p> 二元运算符连接，类型转换</p>
<ul>
<li>如果两操作数中有一个是double型，另一个操作数转换为double类型</li>
<li>否则，如果两操作数中有一个是float型，另一个操作数转换为float类型 </li>
<li>否则，如果两操作数中有一个是long型，另一个操作数转换为long类型    </li>
<li>否则，两个操作数都转换为int型</li>
</ul>
<p><strong>强制类型转换</strong>可能损失信息</p>
<p><code>Math.round()</code>可进行舍入运算，得到最接近整数</p>
<p><strong>算数运算符</strong></p>
<p>​    算术运算符用在数学表达式中，作用和在数学中的作用一样，分为一元运算符和二元运算符，</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法 - 相加运算符两侧的值</td>
<td>A + B 等于 30</td>
</tr>
<tr>
<td>-</td>
<td>减法 - 左操作数减去右操作数</td>
<td>A – B 等于 -10</td>
</tr>
<tr>
<td>*</td>
<td>乘法 - 相乘操作符两侧的值</td>
<td>A * B等于200</td>
</tr>
<tr>
<td>/</td>
<td>除法 - 左操作数除以右操作数</td>
<td>B / A等于2</td>
</tr>
<tr>
<td>％</td>
<td>取余 - 左操作数除以右操作数的余数</td>
<td>B%A等于0</td>
</tr>
<tr>
<td>++</td>
<td>自增: 操作数的值增加1</td>
<td>B++ 或 ++B 等于 21</td>
</tr>
<tr>
<td>–</td>
<td>自减: 操作数的值减少1</td>
<td>B– 或 –B 等于 19</td>
</tr>
</tbody></table>
<ul>
<li><p>求余运算</p>
<p>结果是使用第一个操作数除以第二个操作数，得到一个整数的结果剩余的值就是余数。由于求余运算也是进行除法运算，如果除求余运算运算符的两个操作数都是整数，则求余运算的第二个操作数不可以是0，否则将引起除零异常。</p>
<p>在操作数涉及负数求余运算中，通过下面规则计算：先去掉负号，再计算结果，结果的符号取被除数的符号。如求-10 % -3的结果，去掉负号求10 % 3，结果为1。由于被除数是负值，因此最终结果为-1。</p>
</li>
<li><p>自加\减运算</p>
<ul>
<li><p>自加\减是单目运算符，只有一个操作数。除了自加自减是一元，正（+）和负（-）也是一元运算符，用来改变操作数的符号</p>
</li>
<li><p>自加\减运算符仅能操作一个单个数值型（整形和浮点型都可以），不能操作常量，直接量和表达式。</p>
</li>
<li><p>运算符放操作数的左边和右边，表达效果不一样。</p>
<p>放到左边，表示先把操作数加\减一，然后才把操作数放入表达式中运算。</p>
<p>放到右边，表示先把操作数操作数放入表达式中运算，然后才把操作数加\减一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看 b++ 与 ++b 的不同</span></span><br><span class="line"><span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;b++  = &quot;</span> + (b++) );<span class="comment">//1</span></span><br><span class="line">System.out.println(<span class="string">&quot;++b  = &quot;</span> + (++b) );<span class="comment">//2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p> java支持的位运算符有7个，分为两类：位逻辑运算和移位运算。</p>
<p>假设A = 10, B = 3</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>＆</td>
<td>按位与 如果相对应位都是1，则结果为1，否则为0</td>
<td>（A＆B），得到12，即0000 1100</td>
</tr>
<tr>
<td>|</td>
<td>按位或 如果相对应位都是0，则结果为0，否则为1</td>
<td>（A | B）得到61，即 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>按位同或 如果相对应位值相同，则结果为0，否则为1</td>
<td>（A ^ B）得到49，即 0011 0001</td>
</tr>
<tr>
<td>〜</td>
<td>按位取反 运算符翻转操作数的每一位，即0变成1，1变成0。</td>
<td>（〜A）得到-61，即1100 0011</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>按位左移运算符。左操作数按位左移右操作数指定的位数。左移n位等价于 乘2^n 低位补0</td>
<td>A &lt;&lt; 2得到40，即 0010 1000。</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>按位右移运算符（带符号）。左操作数按位右移右操作数指定的位数。右移n位等价于 除2^n <strong>符号位不变，左边补上符号位</strong></td>
<td>A &gt;&gt; 2得到2 即0000 0010</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>按位右移补零操作符（无符号）。左操作数的值按右操作数指定的位数右移，移动得到的高位以零填充。<strong>忽略了符号位扩展，0补最高位</strong></td>
<td>A&gt;&gt;&gt;2 得到2即0000 0010</td>
</tr>
</tbody></table>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>A=10，B=20</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>检查如果两个操作数的值是否相等，如果相等则条件为真。</td>
<td>（A == B）为假。</td>
</tr>
<tr>
<td>!=</td>
<td>检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td>
<td>(A != B) 为真。</td>
</tr>
<tr>
<td>&gt;</td>
<td>检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td>
<td>（A&gt; B）为假。</td>
</tr>
<tr>
<td>&lt;</td>
<td>检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td>
<td>（A &lt;B）为真。</td>
</tr>
<tr>
<td>&gt;=</td>
<td>检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td>
<td>（A&gt; = B）为假。</td>
</tr>
<tr>
<td>&lt;=</td>
<td>检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td>
<td>（A &lt;= B）为真。</td>
</tr>
</tbody></table>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>boolean A = ture </p>
<p>boolean B = false</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td>
<td>（A &amp;&amp; B）为假。</td>
</tr>
<tr>
<td>| |</td>
<td>称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td>
<td>（A | | B）为真。</td>
</tr>
<tr>
<td>！</td>
<td>称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td>
<td>！（A &amp;&amp; B）为真。</td>
</tr>
</tbody></table>
<h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>+ =</td>
<td>加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td>
<td>C + = A等价于C = C + A</td>
</tr>
<tr>
<td>- =</td>
<td>减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td>
<td>C - = A等价于C = C -   A</td>
</tr>
<tr>
<td>* =</td>
<td>乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td>
<td>C * = A等价于C = C * A</td>
</tr>
<tr>
<td>/ =</td>
<td>除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td>
<td>C / = A等价于C = C / A</td>
</tr>
<tr>
<td>（％）=</td>
<td>取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td>
<td>C％= A等价于C = C％A</td>
</tr>
<tr>
<td>&lt;&lt; =</td>
<td>左移位赋值运算符</td>
<td>C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt; =</td>
<td>右移位赋值运算符</td>
<td>C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td>
</tr>
<tr>
<td>＆=</td>
<td>按位与赋值运算符</td>
<td>C＆= 2等价于C = C＆2</td>
</tr>
<tr>
<td>^ =</td>
<td>按位异或赋值操作符</td>
<td>C ^ = 2等价于C = C ^ 2</td>
</tr>
<tr>
<td>| =</td>
<td>按位或赋值操作符</td>
<td>C|=2 等价于 C=C|2</td>
</tr>
</tbody></table>
<h4 id="运算符的优先级和结合性"><a href="#运算符的优先级和结合性" class="headerlink" title="运算符的优先级和结合性"></a>运算符的优先级和结合性</h4><table>
<thead>
<tr>
<th>类别</th>
<th>操作符</th>
<th>关联性</th>
</tr>
</thead>
<tbody><tr>
<td>后缀</td>
<td>() [] . (点操作符)</td>
<td>左到右</td>
</tr>
<tr>
<td>一元</td>
<td>+ + - ！〜</td>
<td>从右到左</td>
</tr>
<tr>
<td>乘性</td>
<td>* /％</td>
<td>左到右</td>
</tr>
<tr>
<td>加性</td>
<td>+ -</td>
<td>左到右</td>
</tr>
<tr>
<td>移位</td>
<td>&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td>
<td>左到右</td>
</tr>
<tr>
<td>关系</td>
<td>&gt;&gt; = &lt;&lt; =</td>
<td>左到右</td>
</tr>
<tr>
<td>相等</td>
<td>== !=</td>
<td>左到右</td>
</tr>
<tr>
<td>按位与</td>
<td>＆</td>
<td>左到右</td>
</tr>
<tr>
<td>按位异或</td>
<td>^</td>
<td>左到右</td>
</tr>
<tr>
<td>按位或</td>
<td>|</td>
<td>左到右</td>
</tr>
<tr>
<td>逻辑与</td>
<td>&amp;&amp;</td>
<td>左到右</td>
</tr>
<tr>
<td>逻辑或</td>
<td>| |</td>
<td>左到右</td>
</tr>
<tr>
<td>条件</td>
<td>？：</td>
<td>从右到左</td>
</tr>
<tr>
<td>赋值</td>
<td>= + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =</td>
<td>从右到左</td>
</tr>
<tr>
<td>逗号</td>
<td>，</td>
<td>左到右</td>
</tr>
</tbody></table>
<p>建议使用括号（）表示运算顺序</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>“”双引号括起来的都是String实例</p>
<p><strong>字串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s = str.substring(<span class="number">0</span>,<span class="number">3</span>)<span class="comment">//hel</span></span><br><span class="line">    <span class="comment">//字串[n,m)，开始位置（包含）到第一个不想复制位置。字串长度位m-n</span></span><br></pre></td></tr></table></figure>

<p>String使用+拼接</p>
<p>String中没有提供改变某个字符的方法，java使用拼接实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str = str.substring(<span class="number">0</span>,<span class="number">3</span>)+<span class="string">&quot;p!&quot;</span>;<span class="comment">//str = &quot;help!&quot;</span></span><br></pre></td></tr></table></figure>

<p>因为不能修改单个字符，java中String类型对象是不可变的</p>
<p>java中String类通过享元模式设计</p>
<p><strong>检测相等</strong></p>
<p><code>str.euqals(t);</code>str与t相等返回true，不等返回false。</p>
<p>不能使用==检测string是否相等。  ==符号只能确定两个字符串是否在内存中地址相同。（可能有相同的字符串副本放在不同内存）</p>
<p><code>str.compareTo(&quot;hello&quot;)==0</code>也可使用，类似c中的strcmp</p>
<p><strong>构建字符串</strong></p>
<p>避免每次拼接产生新的String对象</p>
<p>StringBuffer类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder  builder &#x3D; new StringBuilder；</span><br><span class="line">builder.append(ch);</span><br><span class="line">builder.append(str);</span><br><span class="line"></span><br><span class="line">String s &#x3D; builder.toString();</span><br></pre></td></tr></table></figure>



<h3 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a>API文档</h3><p><a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/9/docs/api">http://docs.oracle.com/javase/9/docs/api</a></p>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p><strong>读取输入</strong></p>
<p>Scanner  在 java.util.*</p>
<p>标准输入流System.in</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = in.nextLine();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Console类可用于读取密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console cons &#x3D; System.console();</span><br><span class="line">char[] passwd &#x3D; cons.readPassword(&quot;password:&quot;);&#x2F;&#x2F;不会显示密码</span><br></pre></td></tr></table></figure>

<p><strong>格式化输出</strong></p>
<p>在控制台上显示格式化输出:<code>System.out.printf</code>方法</p>
<ul>
<li>d 十进制整数</li>
<li>g 通用浮点数</li>
<li>s 字符串</li>
<li>c 字符</li>
<li>b 布尔<br> 用于 printf 的标志</li>
<li><code>$</code>给定被格式化的参数索引，例如：%1$d</li>
</ul>
<p>图3-6格式说明符语法</p>
<h3 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h3><p><strong>读取文件</strong></p>
<p><code>Scanner in = new Scanner(Path.of(&quot;mtfile.txt&quot;),StardandCharsets.UTF_8);</code></p>
<p>路径要先转化，”/“ 需要转义 “//”</p>
<p><strong>写入文件</strong></p>
<p><code>PrintWriter out = new PrintWriter(&quot;myfile.txt&quot;,StardandCharsets.UTF_8);</code></p>
<p>out使用println 、printf等</p>
<h3 id="程序控制语句"><a href="#程序控制语句" class="headerlink" title="程序控制语句"></a>程序控制语句</h3><p>条件、循环，switch case等</p>
<p><strong>中断控制流程语句</strong></p>
<p>java中可以使用带标签的break 和continue。</p>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tag:</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	break tag;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>break会跳转到tag标签处。continue类似    </p>
<h3 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h3><p><strong>BigInteger API</strong></p>
<ul>
<li><code>BigInteger add(BigInteger other)//加法</code></li>
<li><code>BigInteger subtract(BigInteger other)//减法</code></li>
<li><code>BigInteger multiply(BigInteger other)//乘法</code></li>
<li><code>BigInteger divide(BigInteger other)//除法</code></li>
<li><code>BigInteger mod(BigInteger other)//取余</code></li>
<li><code>int compareTo(BigInteger other)//比较，相等则返回 0，大于则返回 1，小于则返回 -1</code></li>
</ul>
<p><strong>BigDecimal API</strong></p>
<ul>
<li><code>BigDecimal add(BigDecimal other)</code></li>
<li><code>BigDecimal subtract(BigDecimal other)</code></li>
<li><code>BigDecimal multiply(BigDecimal other)</code></li>
<li><code>BigDecimal divide(BigDecimal other , RoundingMode mode)//需要给出**舍入方式**，如 RoundingMode.HALF_UP 四舍五入</code></li>
<li><code>int compareTo(BigDecimal other)</code></li>
<li><code>static BigDecimal valueOf(long x)</code></li>
<li><code>static BigDecimal valueOf(long x, int scale)// x/ 10^scale</code></li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><code>Arrays.copyOf()</code>可用于数组扩容</p>
<p><code>arr = Arrays.copyOf(arr,2*arr.length);</code></p>
<h1 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h1><ol>
<li>类：类是构造对象的模板。通俗点说类就是具有相同属性和相同行为的一类事物。</li>
<li>对象：是类的一个实例，通过类构造产生</li>
</ol>
<p>对象具有三个主要特新：</p>
<ul>
<li>行为：可以通过对象施加那些操作，可调用哪些方法和函数</li>
<li>状态：调用那些方法时，对象如何响应</li>
<li>标识：如何区分有相同方法与状态的不同对象</li>
</ul>
<p> 类之间的常见关系：</p>
<ul>
<li>依赖(uses-a):一个类依赖另一个类，例如类A中的方法需要用到类B中的属性</li>
<li>聚合(has-a):一个类的对象包含另一个类的对象</li>
<li>继承(is-a):一个类是继承另一个类而来，如:鱼–继承–&gt;动物</li>
</ul>
<h4 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h4><ol>
<li> 保证数据私有，不要破坏封装性</li>
<li>对数据初始化，尽管系统会给一个默认值；在C++中可以避免如野指针之类的问题</li>
<li>不要在类中使用过多的基本类型</li>
<li>不是所有的域都需要独立的域访问器和更改器</li>
<li>对于职责过多的类进行分解</li>
<li>类名和方法名要能够体现它们的职责，即名称要与功能匹配</li>
<li>优先使用不可变的类</li>
</ol>
<h4 id="成员与方法"><a href="#成员与方法" class="headerlink" title="成员与方法"></a>成员与方法</h4><p>成员就是类的一些属性，方法即类的一些行为</p>
<p><strong>方法参数：</strong></p>
<p>在C++中参数可以通过值传递，引用传递；</p>
<p>在Java中，参数都是<strong>按值进行传递</strong>，方法得到的参数都是一个副本（对象参数是引用的副本）</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数 (即数值型或布尔型)。</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ul>
<h4 id="静态域与静态方法"><a href="#静态域与静态方法" class="headerlink" title="静态域与静态方法"></a>静态域与静态方法</h4><p><strong>静态域</strong>：其修饰符为static,每个类只有一个这样的域。其修饰的成员变量属于类本身，不属于每一个对象，即所有的对象都共享这一个成员变量</p>
<p><strong>静态常量：</strong>对于一个类公共的成员，可将其定义成静态常量，不允许对象对其进行修改<br><strong>静态方法</strong>：静态方法不能向对象实施操作，即不能通过对象进行调用，可直接通过类名进行调用 如<code>Math.pow()</code></p>
<p>使用静态方法的两种情况：</p>
<ul>
<li>不需要访问对象状态，所需参数通过显示参数提供，如Math.pow;</li>
<li> 只需要访问类的静态域</li>
</ul>
<p>总结</p>
<ul>
<li>静态方法只能调用静态变量</li>
<li>静态方法不能调用非静态方法，非静态方法可以调用静态方法。</li>
<li> 静态方法不能用 this,super 调用</li>
<li>构造方法和局部变量不能声明为 static          </li>
</ul>
<p>类构造器对类进行初始化时，为类开辟了一块static域，并把静态成员存放到该位置。非静态方法是通过实例去调用的，故调用静态方法时，相应的域和成员已经初始化完毕， 静态方法调用非静态方法，对应的实例可能没有完成初始化，非静态方法或需要的成员变量并未加载进来</p>
<h4 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h4><ul>
<li><strong>默认域初始化</strong>若构造器没有显示给域赋予初始值，则会被自动符为默认值，数值为0，布尔型为false，对象引用为null</li>
<li><strong>无参构造器</strong>对象由无参构造函数创建时，其状态被设置为默认值，若类中没有编写任何的构造器，系统会默认生成一个无参构造</li>
<li><strong>显示域初始化</strong>在执行构造器前，可以执行赋值操作，为实例域设置一个有意义的初始值</li>
<li><strong>初始化块</strong>对类进行初始化数据域的方法：构造器设置，在声明中赋值，初始化块中赋值</li>
</ul>
<p>初始化块与构造器执行顺序：<br>    静态初始化块–&gt;静态变量–&gt;非静态初始化块–&gt;构造器</p>
<h4 id="类路径-JAR"><a href="#类路径-JAR" class="headerlink" title="类路径 JAR"></a>类路径 JAR</h4><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域， 以满足新的需求。</p>
<p><strong>java中所有继承都是公共继承。没有私有继承和保护继承</strong></p>
<h2 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h2><p>java关键字 <strong>extends</strong> 表明正在构造的新类派生于一个已存在的类。</p>
<p> 已存在的类称为超类(superclass)、 基类（ base class) 或父类（parent class); </p>
<p>新类称为子类（subclass、) 派生类( derived class) 或孩子类（child class)。</p>
<h3 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h3><p>调用超类中的方法， 而不是当前类的这个覆盖方法。为此， 可以使用特定的关键字 <strong>super</strong> 解决这个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super.getSalary()</span><br></pre></td></tr></table></figure>

<p>super只是一个指示编译器调用超类方法的特殊关键字。<br>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。</p>
<p><strong>this与 super</strong></p>
<ul>
<li><p>this</p>
<p> 两个含义</p>
<ol>
<li>指示隐式参数的引用</li>
<li>调用该类的其他构造器</li>
</ol>
</li>
<li><p>super</p>
<ol>
<li>调用超类的方法</li>
<li>调用超类的其他构造器</li>
</ol>
</li>
</ul>
<h3 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h3><p>由于子类的构造器不能访问超类的私有域， 所以必须利用超类的构造器对这部分私有域进行初始化，我们可以通过 super 实现对超类构造器的调用。<code>super()</code></p>
<p><strong>使用super 调用构造器的语句必须是子类构造器的第一条语句。</strong></p>
<p>若子类没有显示调用超类构造器，将会自动调用超类的无参构造器。</p>
<p>若超类没有无参构造器，且子类中没有显示调用超类其他构造器，编译器报错</p>
<h3 id="继承层次"><a href="#继承层次" class="headerlink" title="继承层次"></a>继承层次</h3><p>继承不限于一个层次。</p>
<p>由一个公共超类派生的所有类的集合称为继承层次。</p>
<p>继承层次中某个特定类到祖先类的的路径称为该类的继承链</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>一个对象变量（例如， 变量 e ) 可以指示多种实际类型的现象被称为多态（ polymorphism)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee e; </span><br><span class="line">e &#x3D; new Employee(. . .); &#x2F;&#x2F; Employee object expected</span><br><span class="line">e &#x3D; new Manager(. . .); &#x2F;&#x2F; OK, Manager can be used as well</span><br></pre></td></tr></table></figure>

<p>Java 中，<strong>对象变量是多态</strong>的。 一个 Employee 变量既可以引用一个Employee 类对象， 也可以引用一个 Employee 类的任何一个子类的对象（例如， Manager、Executive、Secretary 等）<br>但不能将一个超类的引用赋给子类变量。</p>
<p>“is-a” 规则可以用来判断是否应该将数据设计为继承关系，其指出子类的每个对象也是超类的对象 (经理都是员工)，但是反之则不然</p>
<p>“is-a” 规则另一种表述：替换原则 (substitution principle)，程序中任何地方的超类对象都可用子类对象替换。</p>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding）。</p>
<p>动态绑定有一个非常重要的特性： <strong>无需对现存的代码进行修改，就可以对程序进行扩展</strong>。</p>
<p>假设增加一个新类 Executive, 且变量 e 有可能引用这个类的对象， 不需要对包含调用e.getSalary() 的代码进行重新编译。如果 e  恰好引用一个 Executive 类的对象，就会自动地调用 Executive.getSalary()方法。虚拟机通过实际的对象调用相关方法</p>
<h3 id="方法调用过程"><a href="#方法调用过程" class="headerlink" title="方法调用过程"></a>方法调用过程</h3><ul>
<li><input disabled="" type="checkbox"> </li>
</ul>
<h3 id="阻止继承：final-类和方法"><a href="#阻止继承：final-类和方法" class="headerlink" title="阻止继承：final 类和方法"></a>阻止继承：final 类和方法</h3><p>不允许扩展的类被称为 final 类。如果在定义类的时候使用了 <strong>final</strong>  修饰符就表明这个类是 final 类。<code>public final class XXX</code></p>
<p>类中的特定方法也可以被声明为 final。如果这样做，子类就不能覆盖这个方法</p>
<p>final 类中的所有方法自动地成为 final 方法</p>
<p>final作用是确保final类和方法不会在子类中改变语义</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>将一个值存入变量时， 编译器将检查是否允许该操作。</p>
<p>将一个子类的引用赋给一个超类变量， 编译器是允许的。</p>
<p>将一个超类的引用赋给一个子类变量， 必须进行类型转换， 这样才能够通过运行时的检査。</p>
<p>如果承诺不符（超类实例强转为子类）实例，运行时会出错</p>
<p>应该养成这样一个良好的程序设计习惯：<strong>在进行类型转换之前，先查看一下是否能够成功地转换。</strong>简单地使用instanceof 操作符可实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (staff[1] instanceof Manager) &#123;</span><br><span class="line">boss &#x3D; (Manager) staff[1]:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<ul>
<li>只能在继承层次内进行类型转换。</li>
<li>在将超类转换成子类之前，应该使用 instanceof进行检查。</li>
<li>因为实现多态性的动态绑定机制，能够自动找到正确的方法，很多情况不需要进行强制类型转换</li>
<li>只有在使用子类 (如 <code>Manager</code>) 中特有的方法才需要进行强制类型转换</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>从某种角度看， 祖先类更加通用， 只将它作为派生其他类的基类，而不作为想使用的特定的实例类。（抽象类不能实例化）</p>
<p><strong>包含一个或多个抽象方法的类本身必须被声明为抽象的</strong>。</p>
<p><strong>类即使不含抽象方法，也可以将类声明为抽象类。</strong></p>
<p>除抽象方法之外，抽象类还可以包含具体数据和具体方法。但是建议将具体方法放在超类</p>
<p>使用 <strong>abstract</strong> 关键字，就完全不需要实现这个方法，抽象方法充当着占位的角色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract String getDescription();</span><br></pre></td></tr></table></figure>

<p>扩展抽象类有两种选择</p>
<ul>
<li> 一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类；</li>
<li>另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。</li>
</ul>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ol>
<li>仅对本类可见 private。</li>
<li> 对所有类可见 public。</li>
<li> 对本包和所有子类可见 protected。</li>
<li>对本包可见—默认  不需要修饰符。</li>
</ol>
<h3 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h3><ol>
<li>将公共操作和域放在超类</li>
<li>不要使用受保护的域</li>
<li>使用继承实现“ is-a” 关系</li>
<li>除非所有继承的方法都有意义，否则不要使用继承</li>
<li>在覆盖方法时，不要改变预期的行为</li>
<li>使用多态， 而非类型信息</li>
<li>不要过多地使用反射</li>
</ol>
<h4 id="子类方法"><a href="#子类方法" class="headerlink" title="子类方法"></a>子类方法</h4><p>方法的<strong>名字和参数列表称为方法的<em>签名</em></strong>，如果在子类中定义了一个与超类签名相同的方法，那么子类中这个方法就会覆盖超类中这个相同签名的方法</p>
<p>返回类型<strong>不是</strong>签名的一部分，但是在覆盖超类的方法时，需要保证返回类型的兼容性</p>
<ul>
<li>允许子类覆盖方法的返回类型改为原返回类型的子类型，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超类方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getBuddy</span><span class="params">()</span></span>&#123;....&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Manager <span class="title">getBuddy</span><span class="params">()</span></span>&#123;...&#125; <span class="comment">//这是可以的，Manager是Employee的子类</span></span><br></pre></td></tr></table></figure>

<p>不允许子类覆盖的方法的返回类型是超类的方法返回类型的超类，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//超类方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Manager <span class="title">getBuddy</span><span class="params">()</span></span>&#123;....&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">gerBuddy</span><span class="params">()</span></span>&#123;...&#125; <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>

<p>不允许子类覆盖的方法的返回类型和超类的方法返回类型不兼容，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超类方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBuddy</span><span class="params">()</span></span>&#123;....&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">gerBuddy</span><span class="params">()</span></span>&#123;...&#125; <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>

<p>子类覆盖超类方法</p>
<ul>
<li>子类方法不能低于超类方法的可见性</li>
<li>如果<strong>超类</strong>方式是 <code>public</code>，那么<strong>子类</strong>的方法必须也要声明为 <code>public</code>。如果子类方法遗漏掉了 <code>public</code> 修饰符，则编译器会报错</li>
</ul>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>java中所有类的祖先类。</p>
<p>一个类没有明确指出超类，则Object类就是其超类</p>
<p>java中只有基本类型（数值、字符、布尔的值）不是对象，其他都是对象，包括所有的（对象、基本类型）数组类型。</p>
<h4 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h4><p>Object类中的equals方法用于检测一个对象是否等于另一个对象。</p>
<p>Object类中的equals方法将确定两个对象引用是否相等。（对象引用相等，两个对象必相等）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object类实现的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际中常通过状态判断对象相等，需要重写 <code>equals</code> 方法，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//看这个对象引用是否相等  identical</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//如果为空，则肯定不相等</span></span><br><span class="line">  <span class="keyword">if</span>(otherObject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//类不匹配，肯定不相等</span></span><br><span class="line">    <span class="keyword">if</span>(getClass() != otherObject.getClass())<span class="comment">//getClass方法返回一个对象所属的类</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//该类是非空的Employee类，接下来比较对象的状态是否相等</span></span><br><span class="line">    Employee other = (Employee)otherObject;</span><br><span class="line">    <span class="keyword">return</span> name.euqals(other.name) ;</span><br><span class="line">     <span class="comment">//改写为</span></span><br><span class="line">     <span class="comment">//return Object.euqals(name,other.name);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为防止name为null，需使用Object.equals()方法，</p>
<ul>
<li><p>若两个参数都为null，Object.equals(a,b)返回true</p>
</li>
<li><p>其中一个为null返回false</p>
</li>
<li><p>两个都不为null调用a.equals(b)</p>
<p>Object.equals()实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>子类中定义equals方法时，首先调用超类的equals。检测失败，对象不可能相等。超类中字段都相等，则比较子类中的实例字段。</p>
<h4 id="相等测试与继承"><a href="#相等测试与继承" class="headerlink" title="相等测试与继承"></a>相等测试与继承</h4><p>java对equals方法的语言规范要求</p>
<ol>
<li>自反性 任何非空引用x，x.equals(x)返回ture</li>
<li>对称性 任何非空引用x和y，x.equals(y)等于y.equals(x)</li>
<li>传递性 任何非空引用x和y、z，x.equals(y)返回true y.equals(z)返回true ，则x.equals(z)返回一定为true</li>
<li>一致性 任何非空引用x和y，若x、y没有变化 多次调用x.equals(y)返回值不变</li>
<li>对于任意非空引用x，x.equals(null);返回false</li>
</ol>
<ul>
<li>如果由超类决定相等性的概念，那么就可以使用 <code>instanceof</code> 检测，这样就可以在不同子类的对象之间进行相等性比较</li>
<li>如果子类可有自己的相等性概念，则对称性需求将强制使用getClass检测</li>
</ul>
<p><strong>编写 equals 方法的建议</strong></p>
<ol>
<li><p>显示参数命名为 <code>otherObject</code>，稍后需要将它强制转换程另一个名为 <code>other</code> 的变量</p>
</li>
<li><p>检测 <code>this</code> 与 <code>otherObject</code> 是否相等<code>if(this == otherObject) return true;</code></p>
</li>
<li><p>检测 <code>otherObject</code> 是否为 <code>null</code>，如果为 <code>null</code>，返回 <code>false</code>。<code>if(otherObject == null) return false;</code></p>
</li>
<li><p>比较 <code>this</code> 和 <code>otherObject</code> 的类</p>
<ul>
<li>如果 <code>equals</code> 的语义可以在子类中改变 (意思就是两种不同类的子类，是不一样的)，就使用 <code>getClass</code> 检测<code>if(getClass() != otherObject.getClass()) return false;</code></li>
<li>如果所有的子类都有相同的相等性语义 (意思是继承同一个超类的，两个不同类的子类，认为它们类型是一样的)，可使用 <code>instanceof</code> 检测<code>if(!(otherObject instanceof ClassName)) return true;</code></li>
</ul>
</li>
<li><p>将otherObject强制转换为相应类型变量</p>
</li>
<li><p>根据相等性的要求来比较字段</p>
<ul>
<li><p>使用 <code>==</code> 比较基本类型字段</p>
</li>
<li><p>使用 <code>Objects.equals()</code> 比较对象字段</p>
</li>
<li><p>如果所有字段都匹配，返回 true; 否则返回 false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return field1 &#x3D; other.field1</span><br><span class="line">    &amp;&amp; Objects.equals(field2,other.field2)</span><br><span class="line">    &amp;&amp; ...;</span><br></pre></td></tr></table></figure>

<p>如果子类中重新定义equals，需要包含一个super.equals(other)的调用</p>
</li>
</ul>
</li>
</ol>
<p>集合比较特殊，应该将Abstract.equals声明为final（实际没有，可以让子类实现更高效的算法进行相等检测），因为所有子类不需要重新定义集合相等的语句。</p>
<p>实现 equals 方法常见错误：参数类型不是 <code>Object</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//错误示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Employee other)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> other != <span class="keyword">null</span></span><br><span class="line">          &amp;&amp; getClass() == other.getClass()</span><br><span class="line">          &amp;&amp; Objects.equals(name,other.name)</span><br><span class="line">          &amp;&amp; ...;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免发生错误，可以使用 <code>@override</code> 标记要覆盖超类的那些子类方法，如果出现错误，编译器会报错</li>
</ul>
<h4 id="hashcode方法"><a href="#hashcode方法" class="headerlink" title="hashcode方法"></a>hashcode方法</h4><ul>
<li>散列码 (hash code) 是由对象导出的一个无规律整型值 (可正可负)</li>
<li> 如果 x 和 y 是两个不同的对象，x.hashCode () 与 y.hashCode () 基本上不会相同</li>
</ul>
<p>String 类通过下列方法计算散列码 <code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int hash &#x3D; 0;</span><br><span class="line">for(int i &#x3D; 0;i&lt;length();i++)</span><br><span class="line">&#123;</span><br><span class="line">	hash +&#x3D; 31*hash + charAt(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>每个对象 (没有重写的情况下) 都有一个默认的散列码 (Object 类实现的)，其值由对象的储存地址得出</li>
<li>如果<strong>重新定义了 equals 方法，就必须为用户可能插入散列表的对象重新定义 hashCode 方法</strong><ul>
<li>要合理地组合示例字段的散列码，以便能够让不同对象产生的散列码分布均匀</li>
</ul>
</li>
</ul>
<ul>
<li>自己写一个 hashCode ()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">7</span>*name.hashCode()     + <span class="number">11</span> * <span class="keyword">new</span> Double(salary).hashCode()      + <span class="number">13</span> * hireDay.hashCode();</span><br><span class="line">&#125;<span class="comment">//自己写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">7</span>* Objects.hashCode(name)      + <span class="number">11</span> * Double.hashCode(salary)      + <span class="number">13</span> * Objects.hashCode(hireDay);</span><br><span class="line">&#125;<span class="comment">//更好的方法 最好使用null安全方法Object.hashCode</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> Objects.hash(name,salary,hireDay);</span><br><span class="line">&#125;<span class="comment">//更更好的做法</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>Objects.hash()</code> 方法能够对传入各个参数调用 Objects.hashCode, 并组合</p>
<p>其底层用的是 <code>Arrays.hashCode()</code> 实现 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static int hash(Object... values) &#123;</span><br><span class="line">    return Arrays.hashCode(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p> 最好使用 null 安全的方法 Objects.hashCode</p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static int hashCode(Object o) &#123;</span><br><span class="line">      return o !&#x3D; null ? o.hashCode() : 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：<strong>equals 与 hashCode 的定义必须相容</strong>，如果 x.equals (y) 返回 true, 那么 x.hashCode () 就必须与 y.hashCode () 返回相同的值。例如比较ID，hashCode就必须散列ID，而不是其他。</li>
</ul>
<h4 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h4><p>绝大多数的 toString 方法遵循格式：类的名字， 随后是一对方括号括起来的字段值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Employee[name=&quot;</span>+name</span><br><span class="line">          +<span class="string">&quot;,salary=&quot;</span>+salary</span><br><span class="line">          +<span class="string">&quot;,hireDay=&quot;</span>+hireDay</span><br><span class="line">          +<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 类名 可以不使用硬编码的方式，而是调用 getClass ().getName () 获得类名的字符串，子类也可以调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName()</span><br><span class="line">          +<span class="string">&quot;[name=&quot;</span>+name</span><br><span class="line">          +<span class="string">&quot;,salary=&quot;</span>+salary</span><br><span class="line">          +<span class="string">&quot;,hireDay=&quot;</span>+hireDay</span><br><span class="line">          +<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类重新定义 toString 方法时候，可以调用 <code>super.toString</code> 再加上子类自己的字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.toString()</span><br><span class="line">          +<span class="string">&quot;[bonus=&quot;</span>+bonus</span><br><span class="line">          +<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对象与字符串通过操作符 <code>+</code> 连接起来或system.out.println()，编译器会自动调用该对象的 toString 方法来获得该对象的字符串描述。如<code>&quot;&quot;+x</code></li>
</ul>
<p>Object 类定义的 toString 方法，打印出对象的类名和散列码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组类型继承了 Object 类的 toString 方法（不太好）</p>
<p>所以直接打印数组可能出现如下结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>+nums); <span class="comment">//[I@7f31245a</span></span><br></pre></td></tr></table></figure>

<p>可调用<code>Arrays.toString</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Arrays.toString(nums)<span class="comment">//生成字符串&quot;[2,3,4,5]&quot;</span></span><br></pre></td></tr></table></figure>

<p>多维数组可使用<code>Arrays.deepToString()</code></p>
<p>toString 用于调试十分便利，是有用的调试工具，也可用于日志记录</p>
<h3 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h3><p>Arraylist类似于数组，添加或删除元素时可以自动调整数组容量</p>
<p>ArrayList 是一个<strong>有类型参数 (type parameter)</strong> 的<strong>泛型类 (generic class)</strong></p>
<ul>
<li>用一对<em>尖括号</em>将<em>类名</em>括起来追加到 ArrayList 后面来指定数组列表保存的元素对象的类型</li>
</ul>
<p>例如<code>ArrayList&lt;Employee&gt; staff = new ArryList&lt;Employee&gt;();</code></p>
<ul>
<li><p>Java 10 中可使用<code>var</code>避免重复书写类名 <code>var staff = new ArryList&lt;Employee&gt;();</code>这种情况使用菱形语法，会产生<code>ArrayList&lt;Object&gt;</code></p>
</li>
<li><p>不使用<code>var</code>   可省去右边类型参数<code>ArrayList&lt;Employee&gt; staff = new ArryList&lt;&gt;();</code>称为菱形语法</p>
<p>菱形语法 编译器通过检查</p>
<ul>
<li><p>被赋值的变量</p>
</li>
<li><p>传递给方法的参数</p>
</li>
<li><p>返回的方法</p>
<p>的泛型类型，然后将类放入&lt;&gt;中</p>
</li>
</ul>
</li>
</ul>
<p>ArrayLsit管理一个内部的对象引用数组。这个数组满后，ArrayList会自动创建更大数组，并将所有对象从之前数组拷贝到较大数组。</p>
<ul>
<li><p><code>ensureCapacity()</code></p>
<p>已经知道或能够估计出数组可能存储的元素数量，可以在填充之前调用，这样不会带来开销很大的重新分配控件</p>
</li>
<li><p>构造器<code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(100);</code>也可确定capacity</p>
</li>
<li><p><code>size()</code>返回确切的元素个数 等价于 数组a的 a.length</p>
</li>
<li><p><code>trimToSize</code></p>
<p>将储存块的大小调整为当前保存当前元素数量所需要的储存空间。垃圾回收器将回收多余的储存空间。确定时再调用，否则可能花时间再次移动存储块</p>
</li>
</ul>
<blockquote>
<p>c++中 如果<code>a</code>和<code>b</code>是两个vector</p>
<ul>
<li>赋值操作<code>a = b</code>将会构造一个与b长度相同的新向量a，并将所有的元素由b拷贝到a</li>
</ul>
<p>Java ArrayList 中对于该赋值语句的操作结果是让 <code>a</code> 和 <code>b</code> 引用同一个数组列表 (ArrayList)</p>
</blockquote>
<h4 id="访问-ArrayList-元素"><a href="#访问-ArrayList-元素" class="headerlink" title="访问 ArrayList 元素"></a>访问 ArrayList 元素</h4><ul>
<li><p><strong>不能用 [] 的语法格式来访问或改变数组的元素</strong></p>
</li>
<li><p>改变第 i 个元素 set</p>
<ul>
<li><code>staff.set(i,harry);</code></li>
<li>必须第 i 的元素存在才能用 set, 否则得使用 add</li>
</ul>
</li>
<li><p>获取元素</p>
</li>
<li><p><code>staff.get(i);</code></p>
</li>
<li><p>在指定位置插入元素 <code>void add(int index, E obj)</code></p>
<p>后移元素，并将 obj 插入指定索引位置</p>
</li>
<li><p>从指定位置删除元素 <code>E remove(int index)</code></p>
<p>删除索引位置的元素，并将后面的所有元素前移，返回所删除元素</p>
</li>
</ul>
<p><strong>注意</strong> ArrayList 在中间插入和删除元素的效率很低.经常插入删除元素 考虑使用链表</p>
<p><code>toArray</code>可以将ArrayList拷贝到数组中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; new X(list.size());</span><br><span class="line">list.toArrat(a);</span><br></pre></td></tr></table></figure>

<p>旧的ArrayList没有类型参数。</p>
<p>将原始的ArrayList赋值给有类型的<code>ArrayList&lt;X&gt;</code>会提示警告（强制类型转换也会）</p>
<p>检查到没有违反规则后，所有ArrayList转换为原始ArrayList类型，即虚拟机中没有类型参数</p>
<h3 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h3><p>所有的基本类型都有一个与之对应的类 (包装器 wrapper)</p>
<ul>
<li>Integer</li>
<li>Long</li>
<li>Float</li>
<li>Double</li>
<li>Short</li>
<li>Byte</li>
<li>Character</li>
<li>Boolean</li>
</ul>
<p>前六个派生类的公共超类Number</p>
<ul>
<li><p> 包装器类是不可变的</p>
</li>
<li><p>里面储存的字段声明为 final</p>
</li>
<li><p>如<code>private final int value;</code></p>
</li>
<li><p>包装器类是 final 类，不能派生它们的子类</p>
<ul>
<li><code>public final class Integer extends Number implements Comparable&lt;Integer&gt;</code></li>
</ul>
</li>
</ul>
<p><strong>尖括号中的类型参数不允许是基本类型</strong></p>
<p>整型ArrayList应写成<code>ArrayList&lt;Intrger&gt;</code>。<code>ArrayList&lt;Integer&gt;</code> 效率远低于 <code>int[]</code> 数组</p>
<p><strong>自动装箱（autoboxing)</strong></p>
<ul>
<li><code>list.add(3)</code> 自动变成 <code>list.add(Integer.valueOf(3))</code></li>
<li>将 Integer 对象赋给 int 值时，会自动地拆箱</li>
<li><code>int n = list.get(i)</code> 自动转换成 <code>int n = list.get(i).intValue()</code></li>
<li>算数表达式也可用于自动装拆箱 <code>Integer n； n++；</code></li>
</ul>
<p><strong>包装类比较</strong></p>
<p><code>==</code> 运算符可以应用于包装器对象，但是是检测是否是相同的内存位置（与String类类似），建议调用equals()</p>
<p><strong>规范要求</strong></p>
<p> boolean、byte、char &lt;= 127，介于 - 128 和 127 之间的 short 和 int 会被包装到固定的对象中，因此小于等于 127 的包装器的 == 比较是 true</p>
<p>表达式中混用 Integer 和 Double 类型，Integer 值会拆箱，提升到 double，再装箱为 Double。<strong>与运算时类型转换规则相同</strong></p>
<blockquote>
<p>注意<strong>装箱和拆箱是编译器的工作</strong></p>
<p>编译器生成字节码时会插入必要的方法调用</p>
</blockquote>
<p>重要方法</p>
<ul>
<li><p><code>int intValue()</code> 返回 Integer 对象的值作为 int</p>
</li>
<li><p><code>static String toString(int i)</code></p>
</li>
<li><p><code>static String toString(int i, int radix)</code></p>
</li>
<li><p><code>static int parseInt(String s)</code></p>
</li>
<li><p><code>static int parseInt(String s, int radix)</code></p>
</li>
<li><p><code>static Integer valueOf(String s)</code></p>
</li>
<li><p><code>static Integer valueOf(String s, int radix)</code></p>
</li>
</ul>
<h3 id="参数数量可变的方法-变参-varargs-方法"><a href="#参数数量可变的方法-变参-varargs-方法" class="headerlink" title="参数数量可变的方法  变参 (varargs) 方法"></a>参数数量可变的方法  变参 (varargs) 方法</h3><p>比如printf方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line">System.out.printf(<span class="string">&quot;%d %s&quot;</span>,n, <span class="string">&quot;widgets&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">printf</span><span class="params">(String format, Object ... args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> format(format, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>...</code> 是 Java 代码的一部分，表明这个方法可以接受任意数量的对象，除参数 <code>format</code> 外</p>
<p><code>Object ... args</code> 其实是一个 Object [] 数组，保存所有其他参数，如果调用者提供的是基本类型的值，则会自动装箱</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> ... values)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> largest = Double.NEGATIVE_INFINITY;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> value : values)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(value &gt; largest)&#123;</span><br><span class="line">            largest = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> largest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">double</span> m = max(<span class="number">1</span>,<span class="number">2.0</span>,<span class="number">0.5</span>,<span class="number">20.7</span>);</span><br></pre></td></tr></table></figure>

<p>允许数组<strong>作为最后一个参数</strong>传递给有可变参数的方法</p>
<p>如<code>System.out.printf(&quot;%d %s&quot;，new Object[]&#123;new Integer(1),&quot;hello&quot;&#125;);</code></p>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Size</span> </span>&#123;SAMLL, MEDIUM, LARGE, EXTRA_LARGE&#125;</span><br></pre></td></tr></table></figure>

<p>声明定义的类型是一个类，它有四个实例，只有这四个实例，所以不可能再构造新的对象</p>
<p>比较两个枚举类型的值，直接使用 <code>==</code> 就可以</p>
<p>可以为枚举类型添加构造器，方法，字段 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public enum Size</span><br><span class="line">  &#123;</span><br><span class="line">      &#x2F;&#x2F;这里生成四个Size的实例，同时初始化调用构造函数，参数即为括号里面的字符串</span><br><span class="line">      SMALL(&quot;S&quot;),MEDIEUM(&quot;M&quot;),LARGE(&quot;L&quot;),EXTRA_LARGE(&quot;XL&quot;);</span><br><span class="line"></span><br><span class="line">      private String abbreviation;</span><br><span class="line">      &#x2F;&#x2F;枚举类的构造器总是私有的，可以省略private修饰符</span><br><span class="line">      &#x2F;&#x2F;如果声明一个enum构造器为public或protected，会出现语法错误</span><br><span class="line">      Size(String abbreviation) &#123;</span><br><span class="line">          this.abbreviation &#x3D; abbreviation;</span><br><span class="line">      &#125;</span><br><span class="line">      public String getAbbreviation()&#123;</span><br><span class="line">          return abbreviation;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>所有枚举类型都是 Enum 类的子类，继承了很多方法</p>
<ul>
<li><p>toString</p>
<p><code>Size.SMALL.toString()</code>  返回 <code>&quot;SMALL&quot;</code></p>
</li>
<li><p>toString 的逆方法是静态方法 valueOf</p>
<p><code>Size s = Enum.valueOf(Size.class,&quot;SMALL&quot;);</code></p>
</li>
<li><p>values () 方法返回一个包含全部枚举值的数组</p>
<p><code>System.out.println(Arrays.toString(Size.values())); //[SMALL, MEDIEUM, LARGE, EXTRA_LARGE]</code></p>
</li>
<li><p>ordinal () 方法返回声明中枚举常量的位置，位置从 0 开始计数</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Size.SMALL.ordinal()); &#x2F;&#x2F; 0</span><br><span class="line">System.out.println(Size.LARGE.ordinal()); &#x2F;&#x2F; 2</span><br><span class="line">int compareTo(E other)&#x2F;&#x2F;返回结果是 self.ordinal - other.ordinal</span><br></pre></td></tr></table></figure>





<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ul>
<li><input disabled="" type="checkbox"> 反射后面看</li>
</ul>
<p>反射库 (reflection library) 提供丰富且精巧的工具集，可以用来编写能够<strong>动态操纵 Java 代码的程序</strong></p>
<p>反射 (reflective) ：能够分析类能力的程序</p>
<p>反射机制可用于</p>
<ul>
<li>在运行时候分析类的能力</li>
<li>在运行时检查对象，例如编写一个适用于所有类的 toString 方法</li>
<li>实现泛型数组操作代码</li>
<li>利用 Method 对象，这个类似 C++ 的函数指针</li>
</ul>
<p><strong>class类</strong></p>
<p>Java 运行时，系统始终为所有对象维护一个<strong>运行时类型标识</strong>。这个信息会跟踪每个对象所属的类</p>
<p>保存这个信息的是 Class 类，Class对象会描述一个特定类的属性。<strong>Class类实际上是泛型类</strong></p>
<p><code>Object</code> 类中 <code>getClass()</code> 方法返回一个 <code>Class</code> 类型的实例</p>
<ul>
<li>Class类最常用方法时<code>getName()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">...</span><br><span class="line">Class cl = e.getClass();</span><br><span class="line">System.out.println(cl.getName());<span class="comment">//输出Employee 如果e时经理 输出Manager</span></span><br></pre></td></tr></table></figure>

<p>如果类在包中，包名也作为类名的一部分</p>
<ul>
<li><strong>静态方法</strong><code>forName()</code>可获取类名对应的Class对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String className = <span class="string">&quot;java.util.Randoom&quot;</span>;</span><br><span class="line">Class cl = Class.forName(className)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>forName方法会抛出一个检查型异常(checked exception),因此需要提供一个异常处理器(exception handler)</p>
</blockquote>
<p>Class 对象实际上表示的是一个<strong>类型</strong>，可能是类，也可能不是类。如 int不是类,但int.class 是一个Class类型对象</p>
<p>如果T是任意的Java类型（或void关键字）T.Class将代表匹配的类对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class cl1 &#x3D; Random.class;</span><br><span class="line">Class cl2 &#x3D; int.class;</span><br><span class="line">Class cl3 &#x3D; Double[].class;</span><br><span class="line">Class cl4 &#x3D; void.class;</span><br><span class="line">Class cl5 &#x3D; Integer.class;</span><br><span class="line">System.out.println(cl1.getName()); &#x2F;&#x2F; java.util.Random</span><br><span class="line">System.out.println(cl2.getName()); &#x2F;&#x2F; int</span><br><span class="line">System.out.println(cl3.getName()); &#x2F;&#x2F; [Ljava.lang.Double; [I</span><br><span class="line">System.out.println(cl4.getName()); &#x2F;&#x2F; void</span><br><span class="line">System.out.println(cl5.getName()); &#x2F;&#x2F; java.lang.Integer</span><br></pre></td></tr></table></figure>

<p>虚拟机为每个<em>类型</em>管理一个<strong>唯一</strong>的 Class 对象，因此可以用 == 运算符实现两个类对象的比较</p>
<ul>
<li><code>if(e.getClass() == Employee.class)</code></li>
<li>与 <code>e instanceof Employee</code> 不同，如果是某个子类的话，测试失败</li>
</ul>
<p>Class 类型的对象，可用于构造类的实例</p>
<ul>
<li><p>用 <code>getConstructor</code> 方法得到 <code>Constructor</code> 类型的对象</p>
</li>
<li><p>使用 <code>newInstance</code> 方法来构造一个实例 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String className = <span class="string">&quot;java.util.Random&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class cl = Class.forName(className);</span><br><span class="line">    Object o = cl.getConstructor().newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="声明异常入门"><a href="#声明异常入门" class="headerlink" title="声明异常入门"></a>声明异常入门</h4><p>运行出错时，程序就会抛出异常，可使用处理器（handler）捕获并处理</p>
<p>类型</p>
<ul>
<li><p>非检查型 (unchecked) 异常，例如越界错误、访问 null 引用</p>
<p>编译器不希望发生，要求程序员尽量避免触发这类异常</p>
</li>
<li><p>检查型 (checked) 异常 </p>
<p>编译器会检查程序员是否知道这个异常并做好处理异常带来的后果。</p>
</li>
<li></li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://example.com/2021/03/28/Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/" title="Java基本程序设计结构" target="_blank" rel="external">http://example.com/2021/03/28/Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/hs-jose" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/hs-jose" target="_blank"><span class="text-dark">hs</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/28/%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="泛型程序设计"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/28/%E9%9B%86%E5%90%88/" title="集合"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button">
        <span>[&nbsp;</span><span>Catalogue</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/hs-jose" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>