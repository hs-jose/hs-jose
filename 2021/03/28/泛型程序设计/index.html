<!DOCTYPE html>
<html lang=ch>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>泛型程序设计 | Hesai&#39;s Blog</title>
  <meta name="description" content="泛型程序设计泛型类和泛型方法有类型参数，能够准确描述用特定类型实例化会发生什么。 泛型程序设计意味着编写的代码可以对多种不同类型的对象重用。 类型参数的好处Java增加泛型类之前，泛型程序设计是用继承实现。 例如ArrayList类只维护一个Object引用的数组 12345public calss ArrayList&amp;#123;	private Object[];	...&amp;#125;  缺点">
<meta property="og:type" content="article">
<meta property="og:title" content="泛型程序设计">
<meta property="og:url" content="http://example.com/2021/03/28/%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="Hesai&#39;s blog">
<meta property="og:description" content="泛型程序设计泛型类和泛型方法有类型参数，能够准确描述用特定类型实例化会发生什么。 泛型程序设计意味着编写的代码可以对多种不同类型的对象重用。 类型参数的好处Java增加泛型类之前，泛型程序设计是用继承实现。 例如ArrayList类只维护一个Object引用的数组 12345public calss ArrayList&amp;#123;	private Object[];	...&amp;#125;  缺点">
<meta property="og:locale">
<meta property="og:image" content="e:/学习资料/笔记/Java核心卷Ⅰ/image-20210111180820799.png">
<meta property="og:image" content="e:/学习资料/笔记/Java核心卷Ⅰ/image-20210111182324062.png">
<meta property="og:image" content="e:/学习资料/笔记/Java核心卷Ⅰ/image-20210111205129157.png">
<meta property="article:published_time" content="2021-03-28T15:05:01.868Z">
<meta property="article:modified_time" content="2021-03-28T15:40:48.235Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="tags">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="e:/学习资料/笔记/Java核心卷Ⅰ/image-20210111180820799.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://example.com/2021/03/28/%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hesai&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/hs-jose" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">hs</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/hs-jose" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>记录知识</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E2%85%A0/">Java核心技术 Ⅰ</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E2%85%A1/">Java核心技术 Ⅱ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%85%A0-%E6%B7%BB%E5%8A%A0%E5%8D%9A%E6%96%87%E5%88%86%E7%B1%BB/">Java核心技术Ⅰ# 添加博文分类</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%85%A1/">Java核心技术Ⅱ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/effective-Java/">effective Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/">深入理解JVM</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/tags/" rel="tag">tags</a><span class="tag-list-count">13</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/tags/" style="font-size: 13px;">tags</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/">深入理解JVM</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/" class="title">Java内存区域与内存溢出异常</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:25.905Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/">深入理解JVM</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" class="title">垃圾收集器与内存分配策略</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:25.905Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/effective-Java/">effective Java</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%AF%B9%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/" class="title">通用方法</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:16.515Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/effective-Java/">effective Java</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/" class="title">创建和销毁对象</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:16.515Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%85%A0-%E6%B7%BB%E5%8A%A0%E5%8D%9A%E6%96%87%E5%88%86%E7%B1%BB/">Java核心技术Ⅰ# 添加博文分类</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/" class="title">异常、断言和日志</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:01.868Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">Catalogue</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">泛型程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.0.1.</span> <span class="toc-text">类型参数的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">1.0.2.</span> <span class="toc-text">定义简单泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.3.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E9%99%90%E5%AE%9A"><span class="toc-number">1.0.4.</span> <span class="toc-text">类型变量的限定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E4%BB%A3%E7%A0%81%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.0.5.</span> <span class="toc-text">泛型代码和虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">类型擦除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B3%9B%E5%9E%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">转换泛型表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">转换泛型方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%81%97%E7%95%99%E4%BB%A3%E7%A0%81"><span class="toc-number">1.0.5.4.</span> <span class="toc-text">调用遗留代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">1.0.6.</span> <span class="toc-text">限制与局限性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF%E8%A7%84%E5%88%99"><span class="toc-number">1.0.7.</span> <span class="toc-text">泛型类型的继承规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.8.</span> <span class="toc-text">通配符类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A6%82%E5%BF%B5"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">通配符概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E8%B6%85%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">通配符超类型限定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">1.0.8.3.</span> <span class="toc-text">无限定通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E6%8D%95%E8%8E%B7"><span class="toc-number">1.0.8.4.</span> <span class="toc-text">通配符捕获</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%9B%E5%9E%8B%EF%BC%88%E8%B7%B3%E8%BF%87%E5%8F%8D%E5%B0%84%EF%BC%89"><span class="toc-number">1.0.9.</span> <span class="toc-text">反射和泛型（跳过反射）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8BClass%E7%B1%BB"><span class="toc-number">1.0.9.1.</span> <span class="toc-text">泛型Class类</span></a></li></ol></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-泛型程序设计" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      泛型程序设计
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/28/%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="article-date">
	  <time datetime="2021-03-28T15:05:01.868Z" itemprop="datePublished">2021-03-28</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E2%85%A0/">Java核心技术 Ⅰ</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/tags/" rel="tag">tags</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/28/%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#comments" class="article-comment-link">Comments</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h1><p>泛型类和泛型方法有类型参数，能够准确描述用特定类型实例化会发生什么。</p>
<p>泛型程序设计意味着编写的代码可以对多种不同类型的对象重用。</p>
<h3 id="类型参数的好处"><a href="#类型参数的好处" class="headerlink" title="类型参数的好处"></a>类型参数的好处</h3><p>Java增加泛型类之前，泛型程序设计是用继承实现。</p>
<p>例如ArrayList类只维护一个Object引用的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss ArrayList</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> Object[];</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点</p>
<ul>
<li>获取一个值时必须进行强制类型转换</li>
<li>没有错误检查 可以向数组列表中添加任意类型的值</li>
</ul>
<p>解决方案：类型参数</p>
<p>新的ArrayList有一个类型参数指示元素类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> files = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>菱形语法 省略构造器中类型参数</p>
<p><code>ArrayList&lt;String&gt; files = new ArrayList&lt;&gt;();</code></p>
<p>java9扩展后，匿名子类也可以使用菱形语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; passwords &#x3D; new ArrayList&lt;&gt;()</span><br><span class="line">&#123;</span><br><span class="line">	public String get(int n)&#123;return super.get(n).replaceAll(&quot;.&quot;,&quot;*&quot;);&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>通过类型参数编译器可以检查，防止插入错误的对象。</p>
<p>类型参数可以让程序更安全、易读</p>
<p>实现泛型类，需要预计到泛型类所有可能的用法。</p>
<p>通配符类型</p>
<p>代码中大量使用通用类型（Object、Comparable）的强制类型转换时，使用类型参数获益大</p>
<p>泛型程序设计三个水平</p>
<ul>
<li>使用泛型类</li>
<li>对java泛型有足够了解，如何与未知类型参数遗留代码交互，混合使用不同泛型类，了解并会系统的解决出现的问题</li>
<li>实现泛型类、泛型方法</li>
</ul>
<h3 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h3><p>泛型类（generic class）就是有一个或多个类型变量的类。</p>
<p>以Pair为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T first;</span><br><span class="line">	<span class="keyword">private</span> T second;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span></span>&#123; first = <span class="keyword">null</span>; second = <span class="keyword">null</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span></span>&#123; <span class="keyword">this</span>.first = first; <span class="keyword">this</span>.second = second; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> first; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> second; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span></span>&#123; <span class="keyword">this</span>.first = first; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T second)</span></span>&#123; <span class="keyword">this</span>.second = second; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型变量用<code>&lt;&gt;</code>防止类名后面。</p>
<p>泛型类可以有<strong>多个</strong>变量类型 例如<code>public class Pair&lt;T,U&gt;&#123; ... &#125;</code></p>
<blockquote>
<p>常见做法类型变量大写字母，且比较简短。</p>
<p>java 库中</p>
<ul>
<li>变量E表示集合元素类型</li>
<li>K和V分别表示表的键和值的类型</li>
<li>T（U 和 S）表示任意类型</li>
</ul>
</blockquote>
<p>类型变量在整个类定义中用于</p>
<ul>
<li><strong>指定方法的返回类型</strong></li>
<li><strong>字段类型</strong></li>
<li><strong>局部变量类型</strong></li>
</ul>
<p>泛型类相当于普通类的工厂</p>
<p>​    可使用具体类型替换类型变量来实例化泛型类型 如 <code>Pair&lt;String&gt;</code></p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p><strong>泛型方法</strong>可在<strong>普通类</strong>和<strong>泛型类</strong>中定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T... a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类型变量</strong> 的位置</p>
<p>定义时</p>
<ul>
<li>放在修饰符（这里指 <code>public static</code>）的后面</li>
<li>放在返回类型的前面（这里的返回类型是 <code>T</code>）</li>
</ul>
<p>调用泛型方法时</p>
<ul>
<li><p>可以把具体类型包为在尖括号中，放在<strong>方法名前面</strong></p>
<p><code>String middle = ArrayAlg.&lt;String&gt;getMiddle(&quot;Jogn&quot;,&quot;CAt&quot;,&quot;Dog&quot;);</code></p>
</li>
<li><p>大多数情况下，编译器有足够信息推断出想法，将参数的类型和泛型类型 T 进行匹配进行推断，可以省略 类型参数（<code>&lt;String&gt;</code>)</p>
<p><code>String middle = ArrayAlg.getMiddle(&quot;Jogn&quot;,&quot;CAt&quot;,&quot;Dog&quot;);</code></p>
</li>
</ul>
<h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><ul>
<li>使用<code>extends</code>对泛型类型进行限定。</li>
</ul>
<p><code>&lt;T extends Comparable&gt;  </code> T是限定类型的子类型。</p>
<ul>
<li>使用**&amp;**来分割变量类型。</li>
</ul>
<p>一个类型变量或通配符可以有多个限定如<code>T extends Comparable &amp; Serializable</code></p>
<p>​    限定类型（BoundingType）用”&amp;” 分隔</p>
<p>​    类型变量（T) 用逗号分隔</p>
<ul>
<li>java继承中可以有多个接口超类型，但是最多只有一个限定是类。如果有一个类作为限定，<strong>类必须是限定列表中第一个限定。</strong></li>
</ul>
<h3 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h3><p>虚拟机中没有泛型对象，所有对象属于普通类。<strong>泛型变量擦除</strong></p>
<h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>任意定义泛型类型，虚拟机都会自动提供一个相应的<strong>原始类型</strong></p>
<p>原始类型的名字为，去掉类型参数后的泛型类型名，类型变量会被<strong>擦除</strong>，并替换为其限定类型。无限定的变量替换为Object。</p>
<p><code>Pair&lt;T&gt;</code> 的<strong>原始类型（raw type）</strong>（T无限定类型，所以用Object代替）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;first = <span class="keyword">null</span>; second = <span class="keyword">null</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object second)</span></span>&#123;<span class="keyword">this</span>.first = first; <span class="keyword">this</span>.second = second;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> first;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSecond</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> second;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span></span>&#123;<span class="keyword">this</span>.first = newValue;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object newValue)</span></span>&#123;<span class="keyword">this</span>.second = newValue;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>C++ 会为每个模板的实例化产生不同的类型，这一现象叫做 “模板代码膨胀”。Java 不存在这个问题</p>
</blockquote>
<p>原始类型使用<strong>第一个限定</strong>来替换类型变量。没有限定就替换为Object。</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &amp; <span class="title">Serializable</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T lower;</span><br><span class="line">    <span class="keyword">private</span> T upper;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(T first, T second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first.compareTo(second) &lt;= <span class="number">0</span>) &#123; lower = first; upper = second;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; lower = second; upper = first;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>原始类型（raw type）<code>Interval</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable lower;</span><br><span class="line">    <span class="keyword">private</span> Comparable upper;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(Comparable first, Comparable second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first.compareTo(second) &lt;= <span class="number">0</span>) &#123; lower = first; upper = second;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; lower = second; upper = first;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：如果声明的类型变量的限定顺序是这样的 <code>&lt;T extends Serializable &amp; Comparable &gt;</code>。则原始类型会用 <code>Serializable</code> 替换 <code>T</code>。<strong>编译器在必要时向 <code>Comparable</code> 插入强制类型转换。</strong></p>
<p>为提高效率，应该将<strong>标签（tagging）接口（即没有方法的接口）</strong>放在<strong>限定列表的末尾</strong>。</p>
</blockquote>
<h4 id="转换泛型表达式"><a href="#转换泛型表达式" class="headerlink" title="转换泛型表达式"></a>转换泛型表达式</h4><p>调用泛型方法时，如果擦除了返回类型，编译器会插入强制类型转换。</p>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; buddies &#x3D; ...;</span><br><span class="line">Employee buddy &#x3D; buddies.getFirst();</span><br></pre></td></tr></table></figure>

<p>编译器会自动插入转换到Employee的强制类型转换。</p>
<p>编译器转换虚拟机指令</p>
<ul>
<li>对原始方法Pair.getFirst()调用</li>
<li>将返回的Object类型强制转换为Employee类型</li>
</ul>
<p>访问泛型字段时也要插入强制类型转换</p>
<p>假设 <code>Pair</code> 类中的 <code>first</code> 字段 <code>public</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee buddy &#x3D; buddies.first;</span><br></pre></td></tr></table></figure>

<p>会在结果字节码中插入强制类型转换</p>
<h4 id="转换泛型方法"><a href="#转换泛型方法" class="headerlink" title="转换泛型方法"></a>转换泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span><span class="comment">//整个一组方法</span></span></span><br></pre></td></tr></table></figure>

<p>类型擦除后成为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">min</span><span class="params">(Comparable[] a)</span></span></span><br></pre></td></tr></table></figure>

<p>方法的擦除带来两个问题。</p>
<ol>
<li><p>类型擦除与多态冲突</p>
<p>例如继承泛型类的子类中，重写父类的方法。再类型擦除后，会有一个从父类继承来的方法，一个自己重写的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">LocalDate</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DateInterval interval = <span class="keyword">new</span> DateInterval(...);</span><br><span class="line">Pair&lt;LocalDate&gt; pair = interval;</span><br><span class="line">pair.setSecond(aDate);</span><br></pre></td></tr></table></figure>

<p>在类型擦除后，有两个同名方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>第二个是从父类继承来的。</p>
<p>解决办法是在子类中（这里指 <code>DateInterval</code> 类）生成<strong>桥方法（bridge method）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;setSeond((LocalDate) second);&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类型擦除后，子类会有两个方法名和参数类型相同，但是返回类型不相同的方法 </li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LocalDate <span class="title">getSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Object <span class="title">getSecond</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>不能这样编写代码（两个同名方法有相同类型参数不合法），但在虚拟机中，会有<strong>参数类型</strong>和<strong>返回类型</strong>共同制定一个方法，因此编译器可以为两个仅返回类型不同的方法生成字节码，虚拟机能够正确处理这种情况</p>
<blockquote>
<p>桥方法也用在有协变的返回类型（convariant return type）：一个方法覆盖另一个方法时，可以指定一个更严格的返回类型。</p>
</blockquote>
<p><strong>java泛型转换重要事实</strong></p>
<ul>
<li>虚拟机没有泛型，只有普通的类和方法</li>
<li>所有的类型参数都会替换为它们的限定类型</li>
<li>会合成桥方法来保持多态</li>
<li>为保持类型安全性，必要时会插入强制类型转换</li>
</ul>
<h4 id="调用遗留代码"><a href="#调用遗留代码" class="headerlink" title="调用遗留代码"></a>调用遗留代码</h4><p>使用注解（annotation）来消除警告</p>
<ul>
<li>给局部变量加注解 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupperssWarnings(&quot;uncheacked&quot;)</span></span><br><span class="line">Dictionary&lt;Integer, Components&gt; labelTable = slider.getLabelTable();</span><br></pre></td></tr></table></figure>

<ul>
<li>给整个方法加注解 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupperssWarnings(&quot;uncheacked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureSlider</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="限制与局限性"><a href="#限制与局限性" class="headerlink" title="限制与局限性"></a>限制与局限性</h3><ul>
<li><p>不能用基本类型代替类型参数</p>
<p>原因在于类型擦除。擦除后泛型类含有Object（或其他类名字段）可能不能存储基础类型值如<code>int，double</code></p>
</li>
<li><p>运行时类型查询只适用于原始类型</p>
<p>虚拟机中对象总有一个特定的非泛型类型。因此所有类型查询只产生原始类型。</p>
<p>如<code>if(a instanceof Pair&lt;String&gt;)//ERROR</code>和<code>if(a instanceof Pair&lt;T&gt;)//ERROR</code>。或强制类型转换<code>Pair&lt;String&gt; p =  (Pair&lt;String&gt;) a//warning -can only test that a is a pair</code>。</p>
<p><strong>只能测试a是否为任意类型Pair</strong></p>
<p><strong>同理getClass方法总是返回原始类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; stringPair = ...;</span><br><span class="line">Pair&lt;Employee&gt; employeePair = ...;</span><br><span class="line"><span class="keyword">if</span>(stringPair.getClass() == employeePair.getClasss()) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p>不能创建参数化类型的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>];<span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<p>擦除后他变了类型为Pair[],可转换为Object[]。</p>
<p>数组会保存存储的数据类型，防止存储其他类型错误，抛出ArrayStoreException。</p>
<p>擦除会使这种机制无效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var objarray &#x3D; table;</span><br><span class="line">objarray [0]&#x3D;new Pair&lt;Employee&gt;;</span><br></pre></td></tr></table></figure>

<p>能通过检查，但是类型出错。</p>
<p>注意：只是不能创建这些数组，声明类型<code>Pair&lt;String&gt;[]</code>的变量是合法的。不能用<code>new Pair&lt;String&gt;[10];</code>初始化</p>
<ul>
<li><p>​    可以使用通配类型数组，然后进行强制类型转换。结果不安全。table[0]中存储<code>Pair&lt;Employee&gt;</code>调用<code>table[0].getFirst().xxx</code>String的方法时，抛出ClassCastException。</p>
<p><code>var table = (Pair&lt;String&gt;) new Pair&lt;?&gt;[10];</code></p>
</li>
<li><p>收集参数化对象，使用ArrayList更安全有效。<code>ArrayList&lt;Pair&lt;String&gt;&gt;</code></p>
</li>
</ul>
</li>
<li><p>Varargs警告</p>
<p>向参数个数可变方法传递一个泛型类型实例。</p>
<p>如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; coll,T... ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(T t:ts)coll.add(t);</span><br><span class="line">&#125;</span><br><span class="line">Collection&lt;Pair&lt;String&gt;&gt; table = ...;</span><br><span class="line">Pair&lt;String&gt; pair1 = ...;</span><br><span class="line">Pair&lt;String&gt; pair2 = ...;</span><br><span class="line">addAll(table, pair1, pair2);</span><br></pre></td></tr></table></figure>

<p>在向参数个数可变的方法传递一个泛型类型的实例时，Java虚拟机必须建立一个泛型数组。相对于上一条”不能创建参数化类型的数组”而言，<strong>这种情况会有所放松，会得到一个警告而不是错误</strong></p>
<ul>
<li><p>抑制警告的方法有</p>
<ul>
<li><p>方法增加注解<code>SuppressWarnings(&quot;unchecked&quot;)</code></p>
</li>
<li><p>或方法增加注解<code>SafeVaragrs</code></p>
<p><code>SafeVarargs</code>注解只能用于声明为<code>static</code>、<code>final</code>的方法或（java9）private的构造器方法（其他方法可能被覆盖，使得注解没有意义）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>不能实例化类型变量</p>
<p>不能在类似 <code>new T()</code> 的表达式中使用类型变量。类型擦除后变为Object</p>
<p>​    <code>public Pair() &#123;first = new T(); second = new T();&#125; // ERROR</code></p>
<p>解决办法 1：提供一个构造器表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p><code>makePair</code>方法接受一个<code>Supportlier&lt;T&gt;</code>函数式接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Pair&lt;T&gt; makePair(Supplies&lt;T&gt; constr)&#123;return new Pair&lt;(constr.get(),constr.get());&#125;</span><br></pre></td></tr></table></figure>



<p>解决办法 2：反射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; cl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(cl.getConstructor().newInstance(),cl.getConstructor().newInstance());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e) &#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String.class);</span><br></pre></td></tr></table></figure></li>
<li><p>不能构造泛型数组</p>
<p>和不能实例化类型变量一样</p>
<p>提供数组构造器表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(InFunction&lt;T[]&gt; constr, T...a)&#123;    T[] result = constr.apply(<span class="number">2</span>);    ...&#125;</span><br><span class="line"></span><br><span class="line">String[] names = ArrayAlg.minmax(String[]:: <span class="keyword">new</span>,<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Dick&quot;</span>,<span class="string">&quot;Harry&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>或利用反射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T... a)</span><br><span class="line">&#123;</span><br><span class="line">    T[] result = (T[]) Array.newInstance(a.getClass().getComponentType(),<span class="number">2</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>泛型类中静态上下文中类型变量无效</p>
<p>不能在静态字段或方法中引用类型变量</p>
<p>不能声明类型变量是静态的（static）。不能在静态方法中使用类型变量  </p>
<p>类型擦除后只有singleton类,只包含一个singleInstance字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt;    </span>&#123;        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T singleInstance; <span class="comment">// ERROR        </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">getSingleInstance</span><span class="params">()</span> <span class="comment">// ERROR        </span></span></span><br><span class="line"><span class="function">    </span>&#123;            </span><br><span class="line">        <span class="keyword">if</span> (singleInstance == <span class="keyword">null</span>) </span><br><span class="line">            construct <span class="keyword">new</span> instance of T            </span><br><span class="line">        <span class="keyword">return</span> singleInstance;        	</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>不能抛出或捕获泛型类实例</p>
<p><strong>包括泛型类扩展Throwable也是不合法的</strong>。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;....&#125;<span class="comment">//ERROR cannot extend Throwable</span></span><br></pre></td></tr></table></figure>

<p><strong>catch子句（）中不能使用类型变量。</strong>例如，一下方法不能编译</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">do</span> work;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span>(T e)  <span class="comment">// ERROR 不能去捕获类型变量</span></span><br><span class="line">       &#123;</span><br><span class="line">           Logger.global.info(...);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>在异常规范中使用类型变量是允许的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">       <span class="keyword">do</span> work;</span><br><span class="line">     &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">catch</span>(Throwable realcase)  <span class="comment">// ERROR 不能去捕获类型变量</span></span><br><span class="line">        &#123;</span><br><span class="line">           t.iniCause;</span><br><span class="line">            <span class="keyword">throw</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可取消对检查型异常的检查</p>
<p>java异常机制处理为，必须为所有检查型异常提供一个处理器。</p>
<p>利用泛型可以取消这个机制。关键在于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupperessWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable t)</span> <span class="keyword">throws</span> T</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> (T)t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//假设方法包含在Task接口中，有一个检查型异常调用</span></span><br><span class="line">Task.&lt;RuntimeException&gt;throwAs(e);</span><br><span class="line"><span class="comment">//编译器会认为e是一个非检查型异常。</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    dowork</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Throwable t)</span><br><span class="line">&#123;</span><br><span class="line">    Task.&lt;RuntimeException&gt;throwAs(e);<span class="comment">//所有异常转换为编译器认为的非检查型异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现一个 <code>Task</code> 到 <code>Runnable</code> 的适配器，不过 <code>Runnable</code> 接口的类的 <code>run</code> 方法不允许抛出检查型异常，而我们要实现 <code>Task</code> 中的 <code>run</code> 可以抛出任何异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SupperessWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable t)</span> <span class="keyword">throws</span> T</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span>(T) t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Runnable <span class="title">asRunnable</span><span class="params">(Task task)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Task.&lt;RuntimeException&gt;throwAs(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> vodi <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(Task.asRunnable()-&gt;</span><br><span class="line">                                   &#123;</span><br><span class="line">                                       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                                       System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">                                       <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Check this out&quot;</span>);</span><br><span class="line">                                   &#125;));</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用泛型类，擦除和@SupperessWarnings注解，可以消除java部分基本限制。</p>
</li>
<li><p>注意类型擦除后的冲突</p>
<p>擦除后，方法的参数类型变成 <code>Object</code>，可能会和产生相同签名的方法。<strong>解决办法是修改方法名</strong></p>
<p><strong>泛型规范说明原则之一</strong></p>
<ul>
<li><p>为了支持擦除转换，施加一个限制：倘若两个接口类型是同一接口的不同参数化，一个类或类型变量就不能同时作为这两个接口类型的子类、</p>
<p><strong>非法示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Employee implements Comparable&lt;Employee&gt; &#123;...&#125;</span><br><span class="line">class Manager extends Employee implements Comparable&lt;Manager&gt;&#123;...&#125; &#x2F;&#x2F; ERROR </span><br></pre></td></tr></table></figure>

<p>因为 <code>Comparable&lt;Employee&gt;</code> 和 <code>Comparable&lt;Manager&gt;</code> 是<strong>同一接口的不同参数化</strong>。原因是可能与合成桥方法冲突。不能对不同类型有两个桥方法。</p>
<p>非泛型版本的合法示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Employee implements Comparable &#123;...&#125;</span><br><span class="line">class Manager extends Employee implements Comparable&#123;...&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3><p><code>Employee</code> 和 <code>Manager</code> 的关系是父类和子类，<strong>但是</strong> 泛型类<code>Pair&lt;Manager&gt;</code> 不是 <code>Pair&lt;Employee&gt;</code> 的子类。</p>
<p>通常无论S，T关系如何 <code>Pair&lt;S&gt;</code> 和 <code>Pair&lt;T&gt;</code> 没有任何关系</p>
<p><strong>泛型类型与数组的重要区别</strong></p>
<p>泛型类型不能够转换但是 <strong>Java 数组</strong>可以转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manager[] managerBuddies &#x3D; &#123;ceo, cfo&#125;;</span><br><span class="line">Employee[] employeeBuddies &#x3D; managerBuddies; &#x2F;&#x2F; OK</span><br></pre></td></tr></table></figure>

<p><strong>泛型类</strong>可以<strong>扩展</strong>或<strong>实现</strong>其他的<strong>泛型类</strong></p>
<p>和原始类型是继承关系</p>
<ul>
<li><p><code>ArrayList&lt;T&gt;</code> 类实现了 <code>List&lt;T&gt;</code> 接口</p>
</li>
<li><p><code>ArrayList&lt;Manager&gt;</code> 可以转换成一个 <code>List&lt;Manager&gt;</code></p>
<p><img src="E:\学习资料\笔记\Java核心卷Ⅰ\image-20210111180820799.png" alt="image-20210111180820799"></p>
</li>
</ul>
<h3 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h3><p>在上面 “<strong>泛型类型的继承规则</strong>” 中，说到 “<code>Pair&lt;Employee&gt;</code> 和 <code>Pair&lt;Manager&gt;</code> 没有任何关系”</p>
<p>因此对于下面代码段，不能将 <code>Pair&lt;Manager&gt;</code> 传递给这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuddies</span><span class="params">(Pair&lt;Employee&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Employee first = p.getFirst();</span><br><span class="line">    Employee second = p.getSecond();</span><br><span class="line">    System.out.println(first.getName() + <span class="string">&quot; and &quot;</span> + second.getName() + <span class="string">&quot; are buddies.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<strong>通配符</strong>能够解决 Java 这种严格的泛型类型系统 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuddies</span><span class="params">(Pair&lt;? extends Employee&gt; p)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="通配符概念"><a href="#通配符概念" class="headerlink" title="通配符概念"></a>通配符概念</h4><p>通配符类型中，允许参数发生改变。例如<code>Pair&lt;? extends Employee&gt;</code>表示任何泛型Pair类型，其类型参数是Employee子类。</p>
<p><code>Pair&lt;Manager&gt;</code>是<code>Pair&lt;? extends Employee&gt;</code>的<strong>子类型</strong></p>
<p><img src="E:\学习资料\笔记\Java核心卷Ⅰ\image-20210111182324062.png" alt="image-20210111182324062"></p>
<p>考虑如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">？extends Employee getFirst()</span><br><span class="line">void setFirst(？extends Employee)</span><br></pre></td></tr></table></figure>

<p>set方法可能产生不安全调用，编译器只知道需要某个子类型，但不知道具体类型，所以他拒接传递任何特定类型，？不能匹配。</p>
<p>get方法返回复制给一个Employee引用是完全合法的。</p>
<h4 id="通配符超类型限定"><a href="#通配符超类型限定" class="headerlink" title="通配符超类型限定"></a>通配符超类型限定</h4><p>通配符限定于类型变量限定类似。但是通配符限定还有<strong>超类型限定</strong></p>
<p>声明使用为类型T对象，或T的一个超类型对象</p>
<p>如 <code>？ super Manager</code>限制为Manager的所有超类型。</p>
<p>考虑如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">？super Manager getFirst()</span><br><span class="line">void setFirst(？super Manager)</span><br></pre></td></tr></table></figure>

<p>编译器无法知道set方法具体类型，所以拒接传递Employee或Object的方法调用，<strong>只能传递Manager类型对象，或其子类型对象</strong></p>
<p>get方法不能保证返回对象的类型，只能把它赋给Object。</p>
<p>恰好与extends相反</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minmaxBonus</span><span class="params">(Manager[] a,Pair&lt;? <span class="keyword">super</span> Manager&gt; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    Manager min = a[<span class="number">0</span>];</span><br><span class="line">    Manager max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(min.getBonus() &gt; a[i].getBonus()) min = a[i];</span><br><span class="line">        <span class="keyword">if</span>(max.getBonus() &lt; a[i].getBonus()) max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    result.setFirst(min);</span><br><span class="line">    result.setSecond(max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这个代码示例，可以传入 <code>Pair&lt;Employee&gt;</code> 也可以传入 <code>Pair&lt;Object&gt;</code></p>
<p><img src="E:\学习资料\笔记\Java核心卷Ⅰ\image-20210111205129157.png" alt="image-20210111205129157"></p>
<ul>
<li><p><input disabled="" type="checkbox">  记得看看</p>
</li>
<li><p>带有<strong>超类型限定</strong>的通配符允许<strong>写入</strong>一个泛型对象</p>
</li>
<li><p>带有<strong>子类型限定</strong>的通配符允许你<strong>读取</strong>一个泛型对象</p>
</li>
</ul>
<p><strong>超类型限定</strong>另一个常见用法</p>
<p><code>&lt;T extends Comparable&lt;? super T&gt;&gt;</code>去除调用参数不必要的限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; T min(T[] a)</span><br></pre></td></tr></table></figure>

<p><strong>子类型限定</strong>另一个常见用法是作为一个函数式接口的参数类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ArrayList&lt;Employee&gt; staff </span>= ...;</span><br><span class="line">Predicate&lt;Object&gt; oddHashcode = obj -&gt; obj.hashCode() % <span class="number">2</span> != <span class="number">0</span>;</span><br><span class="line">staff.removeIf(oddHashcode);</span><br></pre></td></tr></table></figure>

<h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><p>例如<code>Pair&lt;?&gt;</code></p>
<p>实际上<code>Pair&lt;?&gt;</code>和原始类型<code>Pair</code>有很大不同</p>
<p>考虑如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">？ getFirst()</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(?)</span></span></span><br></pre></td></tr></table></figure>

<p>get方法的值只能赋给Object引用。</p>
<p>set方法不能被调用（包括用Object）。</p>
<p><code>Pair&lt;?&gt;</code>和原始类型<code>Pair</code>原始类型<code>Pair</code>在于：<strong>可用任意Object对象调用原始类型<code>Pair</code>的set方法</strong>。</p>
<p>使用无限定通配符对很多简单操作有用</p>
<p>例如</p>
<p>不需要实际类型的时候</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法用于判断一个Pair是否包含一个null引用、</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="keyword">null</span> || p.getSecond() == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h4><p>通配符不是类型变量，因此编码中不能使用？作为一种类型。</p>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;交换pair元素</span><br><span class="line">public static void swap&lt;?&gt;(Pair&lt;?&gt; p)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>? t = p.getFirst()</code>是非法的所以方法<code>swap&lt;?&gt;(Pair&lt;?&gt; p)</code>错误。交换时必须保存一个元素。</p>
<p>解决方案</p>
<p>使用辅助方法（泛型方法），由swap调用swapHelper</p>
<p>swapHelper方法的参数通过捕获通配符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Pair&lt;T&gt; p)</span><span class="comment">//泛型方法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t = p.getFirst();</span><br><span class="line">    p.setFirst(p.getSecond());</span><br><span class="line">    p.setSecond(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Pair&lt;?&gt; p)</span> </span>&#123; swapHelper(p);&#125;</span><br></pre></td></tr></table></figure>



<p>编译器必须能够保证通配符表示单个确定的类型。例如 <code>ArrayList&lt;Pair&lt;T&gt;&gt;</code> 中的 <code>T</code> 永远不能捕获 <code>ArrayList&lt;Pair&lt;?&gt;&gt;</code> 中的通配符。<code>ArrayList</code> 可以保存两个 <code>Pair&lt;?&gt;</code>，其中 <code>?</code> 分别有不同的类型。</p>
<ul>
<li><input disabled="" type="checkbox"> <h3 id="反射和泛型（跳过反射）"><a href="#反射和泛型（跳过反射）" class="headerlink" title="反射和泛型（跳过反射）"></a>反射和泛型（跳过反射）</h3></li>
</ul>
<p>利用反射可获取泛型信息</p>
<h4 id="泛型Class类"><a href="#泛型Class类" class="headerlink" title="泛型Class类"></a>泛型Class类</h4>
      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://example.com/2021/03/28/%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="泛型程序设计" target="_blank" rel="external">http://example.com/2021/03/28/%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/hs-jose" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/hs-jose" target="_blank"><span class="text-dark">hs</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/28/%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/" title="接口、lambda表达式与内部类"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/28/Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/" title="Java基本程序设计结构"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button">
        <span>[&nbsp;</span><span>Catalogue</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/hs-jose" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>