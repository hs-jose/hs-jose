<!DOCTYPE html>
<html lang=ch>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>并发 | Hesai&#39;s Blog</title>
  <meta name="description" content="并发线程多任务（multitasking） 并发执行的进程数目不受限于 CPU 数目。操作系统会为每个进程分配 CPU 时间片，给人并行处理的感觉。（操作系统） 每个任务在一个线程（thread）中执行，线程是控制线程的简称。 如果一个程序可以同时运行多个线程，则该程序是多线程（multithreaded）的，即单个进程看起来同时完成多个任务。每个任务在一个线程中执行。 与进程相比  共享变量使线">
<meta property="og:type" content="article">
<meta property="og:title" content="并发">
<meta property="og:url" content="http://example.com/2021/03/28/%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="Hesai&#39;s blog">
<meta property="og:description" content="并发线程多任务（multitasking） 并发执行的进程数目不受限于 CPU 数目。操作系统会为每个进程分配 CPU 时间片，给人并行处理的感觉。（操作系统） 每个任务在一个线程（thread）中执行，线程是控制线程的简称。 如果一个程序可以同时运行多个线程，则该程序是多线程（multithreaded）的，即单个进程看起来同时完成多个任务。每个任务在一个线程中执行。 与进程相比  共享变量使线">
<meta property="og:locale">
<meta property="og:image" content="e:/学习资料/笔记/Java核心卷Ⅰ/image-20210119142403738.png">
<meta property="article:published_time" content="2021-03-28T15:05:01.868Z">
<meta property="article:modified_time" content="2021-03-28T15:40:30.582Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="tags">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="e:/学习资料/笔记/Java核心卷Ⅰ/image-20210119142403738.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://example.com/2021/03/28/%E5%B9%B6%E5%8F%91/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hesai&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/hs-jose" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">hs</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/hs-jose" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>记录知识</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E2%85%A0/">Java核心技术 Ⅰ</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E2%85%A1/">Java核心技术 Ⅱ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%85%A0-%E6%B7%BB%E5%8A%A0%E5%8D%9A%E6%96%87%E5%88%86%E7%B1%BB/">Java核心技术Ⅰ# 添加博文分类</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%85%A1/">Java核心技术Ⅱ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/effective-Java/">effective Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/">深入理解JVM</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/tags/" rel="tag">tags</a><span class="tag-list-count">13</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/tags/" style="font-size: 13px;">tags</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/">深入理解JVM</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/" class="title">Java内存区域与内存溢出异常</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:25.905Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/">深入理解JVM</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" class="title">垃圾收集器与内存分配策略</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:25.905Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/effective-Java/">effective Java</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%AF%B9%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/" class="title">通用方法</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:16.515Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/effective-Java/">effective Java</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/" class="title">创建和销毁对象</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:16.515Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%85%A0-%E6%B7%BB%E5%8A%A0%E5%8D%9A%E6%96%87%E5%88%86%E7%B1%BB/">Java核心技术Ⅰ# 添加博文分类</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/28/%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/" class="title">异常、断言和日志</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-28T15:05:01.868Z" itemprop="datePublished">2021-03-28</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">Catalogue</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">1.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.0.1.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">线程完成任务过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.0.1.2.1.</span> <span class="toc-text">新建线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.0.1.2.2.</span> <span class="toc-text">可运行线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.0.1.2.3.</span> <span class="toc-text">阻塞和等待线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.0.1.2.4.</span> <span class="toc-text">终止线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">线程属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.0.1.3.1.</span> <span class="toc-text">中断线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8D"><span class="toc-number">1.0.1.5.</span> <span class="toc-text">线程名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AA%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.0.1.6.</span> <span class="toc-text">未捕获异常的处理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.0.1.7.</span> <span class="toc-text">线程优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">1.0.2.</span> <span class="toc-text">同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">竞态条件详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">锁对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%85%A5%E9%94%81-reentrant"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">重入锁 reentrant</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">1.0.2.3.1.</span> <span class="toc-text">可重入锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">1.0.2.3.2.</span> <span class="toc-text">公平锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">条件对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%B0%8F%E7%BB%93"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">锁和条件小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.0.2.6.</span> <span class="toc-text">synchronized 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%9D%97"><span class="toc-number">1.0.2.7.</span> <span class="toc-text">同步块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E8%A7%86%E5%99%A8"><span class="toc-number">1.0.2.8.</span> <span class="toc-text">监视器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E5%AD%97%E6%AE%B5"><span class="toc-number">1.0.2.9.</span> <span class="toc-text">volatile 字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E5%8F%98%E9%87%8F"><span class="toc-number">1.0.2.10.</span> <span class="toc-text">final变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.0.2.11.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.0.2.12.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.0.2.13.</span> <span class="toc-text">线程局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E6%95%88%E7%9A%84%E6%98%A0%E5%B0%84%E3%80%81%E9%9B%86%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.0.2.14.</span> <span class="toc-text">高效的映射、集和队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E6%9D%A1%E7%9B%AE%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0"><span class="toc-number">1.0.2.15.</span> <span class="toc-text">映射条目原子更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%B9%B6%E5%8F%91%E6%95%A3%E5%88%97%E6%98%A0%E5%B0%84%E7%9A%84%E6%89%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.2.16.</span> <span class="toc-text">对并发散列映射的批操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%9B%86%E8%A7%86%E5%9B%BE"><span class="toc-number">1.0.2.17.</span> <span class="toc-text">并发集视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.0.2.18.</span> <span class="toc-text">写数组的拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95"><span class="toc-number">1.0.2.19.</span> <span class="toc-text">并行数组算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%83%E6%97%A9%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88"><span class="toc-number">1.0.2.20.</span> <span class="toc-text">较早的线程安全集合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.0.3.</span> <span class="toc-text">任务和线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Callable%E5%92%8CFuture"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">Callable和Future</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">执行器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E4%BB%BB%E5%8A%A1%E7%BB%84"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">控制任务组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fork-join-%E6%A1%86%E6%9E%B6"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">fork-join 框架</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97"><span class="toc-number">1.0.4.</span> <span class="toc-text">异步计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%AE%8C%E6%88%90Future"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">可完成Future</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.5.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">建立一个进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">运行一个进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%8F%A5%E6%9F%84"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">进程句柄</span></a></li></ol></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-并发" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      并发
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/28/%E5%B9%B6%E5%8F%91/" class="article-date">
	  <time datetime="2021-03-28T15:05:01.868Z" itemprop="datePublished">2021-03-28</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E2%85%A0/">Java核心技术 Ⅰ</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/tags/" rel="tag">tags</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/28/%E5%B9%B6%E5%8F%91/#comments" class="article-comment-link">Comments</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>多任务（multitasking）</p>
<p>并发执行的<strong>进程</strong>数目不受限于 CPU 数目。操作系统会为每个进程分配 CPU 时间片，给人并行处理的感觉。（操作系统）</p>
<p>每个任务在一个<strong>线程</strong>（thread）中执行，线程是控制线程的简称。</p>
<p>如果一个程序可以同时运行多个线程，则该程序是多线程（multithreaded）的，即单个进程看起来同时完成多个任务。每个任务在一个线程中执行。</p>
<p><strong>与进程相比</strong></p>
<ul>
<li>共享变量使线程之间通信更加高效，容易。</li>
<li>线程更轻量级，创建、撤销一个线程比启动新进程开销小。</li>
<li>进程与线程本质区别在于，每个进程有属于自己的一整套变量，线程则共享数据（风险）。</li>
</ul>
<h4 id="线程完成任务过程"><a href="#线程完成任务过程" class="headerlink" title="线程完成任务过程"></a>线程完成任务过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//某个类的实例想在一个线程中被执行，必须实现Runnable接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 将执行这个任务的代码放入一个类的 <code>run</code> 方法，同时这个类要实现 <code>Runnable</code> 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//task code</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>由于 <code>Runnable</code> 是一个函数式接口，所以也可以用 lambda 表达式创建实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="comment">//task code</span></span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>从创建的Runnable对象构造一个Thread对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(r);</span><br></pre></td></tr></table></figure>

<p>启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.start();</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>注意</strong></p>
<p><strong>不要</strong>直接调用 <code>Thread</code> 类或 <code>Runnable</code> 对象的 <code>run</code> 方法。直接调用 <code>run</code> 方法会在<strong>同一个线程中执行这个任务</strong>，而没有启动新的线程。应当调用 <code>Thread.start</code> 方法</p>
</blockquote>
<p>也可以通过建立 <code>Thread</code> 类子类来定义线程，因为 <code>Thread</code> 类实现了 Runnable 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        task code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用 start 方法。</p>
<p>但是不推荐这种方法，应当把<strong>要并行运行的任务与运行机制解耦合</strong></p>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>线程可以有 6 种状态</p>
<ul>
<li>New 新建</li>
<li> Runnable 可运行</li>
<li> Blocked 阻塞</li>
<li> Waiting 等待</li>
<li> Timed waiting 计时等待</li>
<li> Terminated 终止</li>
</ul>
<h5 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h5><p>用 <code>new</code> 操作符创建一个新线程，如 <code>new Thread(r)</code></p>
<p>线程还没开始运行，它的状态是新建（<code>new</code>）的。在线程运行之前还有一些基础工作要做</p>
<h5 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h5><p>一旦调用start方法，线程就处于可运行状态（Ruannable）。</p>
<p>线程处于<strong>可运行状态</strong>有两种情况</p>
<ol>
<li>一个可运行的线程可能正在运行</li>
<li>一个可运行的线程可能没有运行</li>
</ol>
<p>原因</p>
<ul>
<li>一旦一个线程开始运行，他不一定始终保持运行。运行中的线程有实要暂停，让其他线程有机会运行。</li>
</ul>
<blockquote>
<p>线程调度的细节依赖于操作系统提供的服务</p>
<ul>
<li><p>抢占式调度系统</p>
<p>给每个可运行线程一个时间片来执行任务</p>
<ul>
<li>时间片用完后，操作系统会<strong>剥夺</strong>该线程的运行权，让另一个线程一个机会来运行，操作系统会考虑优先级</li>
<li>所有的桌面以及服务器操作系统使用抢占式调度</li>
</ul>
</li>
<li><p>协作式调度</p>
<ul>
<li>一个线程只有在<strong>调用 <code>yield</code> 方法</strong>或者<strong>被阻塞</strong>或<strong>等待</strong>时，才失去控制权</li>
<li>手机等小型设备</li>
</ul>
</li>
</ul>
<p>多个处理器的机器上，可以有多个线程并行运行</p>
<p>当线程的数目多于处理器的数目，调度器还是需要分配时间片</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public class Thread implements Runnable</span></span><br><span class="line"><span class="comment">//使当前正在执行的线程向另一个线程交出运行权。这是一个静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>; </span><br></pre></td></tr></table></figure>

<h5 id="阻塞和等待线程"><a href="#阻塞和等待线程" class="headerlink" title="阻塞和等待线程"></a>阻塞和等待线程</h5><p>当线程处于<strong>阻塞</strong>或<strong>等待</strong>状态时，它<strong>暂时</strong>是<strong>不活动</strong>的 。</p>
<ul>
<li>不运行任何代码</li>
<li>消耗最小资源</li>
</ul>
<p>要由<strong>线程调度器</strong>重新<strong>激活</strong>这个线程。具体细节取决于它是<strong>怎样到达非活动状态</strong>的</p>
<ul>
<li>当一个线程试图获取一个内部的对象锁（注意区别于 <code>java.util.concurrent</code> 库中的 <code>Lock</code>）, 而且这个锁（内部的对象锁）目前被其他线程占有，该线程就会被阻塞。<ul>
<li>当所有的线程<strong>都释放</strong>了<strong>这个锁</strong>，并且<strong>线程调度器</strong>允许该线程持有这个锁，它将变成<strong>非阻塞状态</strong></li>
</ul>
</li>
<li>当线程等待另一个线程通知调度器出现一个条件时，这个线程会进入等待状态<ul>
<li>调用 <code>Object.wait</code> 方法或 <code>Thread.join</code> 方法</li>
<li>或者是等待 <code>java.util.concurrent</code> 库中的 <code>Lock</code> 或 <code>Condition</code> 时</li>
</ul>
</li>
<li>调用有超时参数的方法会让线程进入计时等待（timed waiting）状态<ul>
<li>这个状态一直保持到<strong>超时期满</strong>或者接收到适当的<strong>通知</strong></li>
<li>带有超时参数的方法<ul>
<li><code>Thread.sleep</code></li>
<li>计时版的 <code>Object.wait</code>、<code>Thread.join</code>、<code>Lock.trylock</code> 以及 <code>Condition.await</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>当一个线程处于<strong>阻塞或等待时（终止时）</strong>，就可以<strong>调度另一个</strong>线程运行。</p>
<p>当一个线程被<strong>重新激活</strong>（例如因为<strong>超时期满</strong>或<strong>成功获得了一个锁</strong>），<strong>调度器</strong>检查它是否具有比当前运行线程<strong>更高的优先级</strong>，如果有，调度器会<strong>剥夺</strong>某个<strong>当前运行</strong>线程的运行权，选择一个新线程运行。</p>
<p><strong>阻塞状态</strong>与<strong>等待状态</strong>并没有太大区别</p>
<p><img src="E:\学习资料\笔记\Java核心卷Ⅰ\image-20210119142403738.png" alt="image-20210119142403738"></p>
<h5 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h5><p>线程会由于以下原因之一而终止</p>
<ol>
<li><code>run</code> 方法<strong>正常退出</strong>，线程自然终止</li>
<li>因为一个<strong>没有捕获的异常</strong>终止了 <code>run</code> 方法，使线程意外终止</li>
</ol>
<p>可以调用线程的 <code>stop</code> 方法杀死线程，该方法会抛出 <code>ThreadDeath</code> 错误对象，但该方法已经弃用</p>
<blockquote>
<p>join方法，等待中止指定线程。</p>
<p>比如B中调用A线程的join，直到A执行完成后才会继续执行B</p>
</blockquote>
<h4 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h4><h5 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h5><p>区别中断（interrupt）和终止（terminated）不同</p>
<ul>
<li>interrupt 一个线程，不一定会使得该线程终止</li>
</ul>
<p>线程<strong>终止</strong>的情况</p>
<ul>
<li>线程的 <strong><code>run</code> 方法</strong>执行方法体中的<strong>最后一条语句</strong>后再执行**<code>return</code><strong>语句</strong>返回时 **</li>
<li>出现了方法中<strong>没有捕获的异常</strong>时</li>
<li><code>stop</code> 方法，但是已经被废弃了。</li>
</ul>
<blockquote>
<p>废弃原因如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">* @deprecated This method is inherently unsafe.  Stopping a thread with</span><br><span class="line">     *       Thread.stop causes it to unlock all of the monitors that it</span><br><span class="line">     *       has locked (as a natural consequence of the unchecked</span><br><span class="line">     *       &lt;code&gt;ThreadDeath&lt;&#x2F;code&gt; exception propagating up the stack).  If</span><br><span class="line">     *       any of the objects previously protected by these monitors were in</span><br><span class="line">     *       an inconsistent state, the damaged objects become visible to</span><br><span class="line">     *       other threads, potentially resulting in arbitrary behavior.  Many</span><br><span class="line">     *       uses of &lt;code&gt;stop&lt;&#x2F;code&gt; should be replaced by code that simply</span><br><span class="line">     *       modifies some variable to indicate that the target thread should</span><br><span class="line">     *       stop running.  The target thread should check this variable</span><br><span class="line">     *       regularly, and return from its run method in an orderly fashion</span><br><span class="line">     *       if the variable indicates that it is to stop running.  If the</span><br><span class="line">     *       target thread waits for long periods (on a condition variable,</span><br><span class="line">     *       for example), the &lt;code&gt;interrupt&lt;&#x2F;code&gt; method should be used to</span><br><span class="line">     *       interrupt the wait.</span><br><span class="line">     *       For more information, see</span><br><span class="line">     *       &lt;a href&#x3D;&quot;&#123;@docRoot&#125;&#x2F;..&#x2F;technotes&#x2F;guides&#x2F;concurrency&#x2F;threadPrimitiveDeprecation.html&quot;&gt;Why</span><br><span class="line">     *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;&#x2F;a&gt;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">  总而言之就是不安全</span><br></pre></td></tr></table></figure>
</blockquote>
<p>interrupt方法可以用来请求中止一个线程</p>
<p>当对一个线程调用interrupt方法，会设置线程中断状态，每个线程都有中断状态的boolean标志。</p>
<p>每个线程都应该不时地检查这个标志，判断线程是否被中断 </p>
<p>想要得出<strong>是否设置中断状态</strong>。</p>
<ul>
<li>调用静态的 <code>Thread.currentThread()</code> 方法获得当前线程，然后调用 <code>isInterrupted</code> 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a reference to the currently executing thread object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the currently executing thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title">currentThread</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!Thread.currentThread().isInterrupt() &amp;&amp; more work to <span class="keyword">do</span>)&#123;</span><br><span class="line">    <span class="keyword">do</span> more work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果线程<strong>被阻塞</strong>，就<strong>无法检查</strong>中断状态，就需要引入<code>InterruptExcption</code>异常</p>
<ul>
<li> 当一个被<code>sleep</code>或<code>wait</code>调用<strong>阻塞</strong>的线程上调用<code>interrupt</code>方法时，那个<strong>阻塞调用（即sleep或wait调用）</strong>将被一个<code>InterruptException</code><strong>异常中断</strong></li>
<li>有一些阻塞I/O调用不能被中断，对此应该考虑选择可中断的调用</li>
</ul>
<p>没有要求被中断的线程应该终止。中断一个线程只是引起它的注意。</p>
<p>被中断的线程可以决定如何响应中断。</p>
<ul>
<li><p>对于某些重要线程，应该处理这个异常，然后继续执行</p>
</li>
<li><p>对于希望将中断解释为一个终止请求的线程，在其<code>run</code>方法通常有如下形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Runnable r &#x3D; () -&gt; &#123;</span><br><span class="line">       try&#123;</span><br><span class="line">           ...</span><br><span class="line">           while(!Thread.currentThread().isInterrupt() &amp;&amp; more work to do)&#123;</span><br><span class="line">               do more work</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       catch(InterruptException)&#123;</span><br><span class="line">           &#x2F;&#x2F; thread was interrupted during sleep or wait</span><br><span class="line">       &#125;</span><br><span class="line">       finally&#123;</span><br><span class="line">           cleanup, if required</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;exiting the run method terminates the thread</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果在每次工作迭代后都调用 <code>sleep</code> 方法，那么 <code>isInterrupt</code> 方法没有必要也没有用处。</p>
<ul>
<li>如果设置了中断状态，此时如果调用 <code>sleep</code>，线程不会休眠（即不获得 <code>sleep</code> 效果），而是<strong>清除中断状态（!）</strong>，并抛出 <code>InterruptException</code></li>
<li>因此如果循环调用了 <code>sleep</code> 就不要检测中断状态，而应当捕获 <code>InterruptException</code> 异常</li>
</ul>
<p>如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span>(more work to <span class="keyword">do</span>)&#123;</span><br><span class="line">            <span class="keyword">do</span> more work</span><br><span class="line">            Thread.sleep(delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(InterruptException)&#123;</span><br><span class="line">        <span class="comment">// thread was interrupted during sleep</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        cleanup, <span class="keyword">if</span> required</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//exiting the run method terminates the thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>interrupt</code>方法是一个静态方法，它<strong>检查</strong>当前线程<strong>是否被中断</strong>。而且调用<code>interrupted</code>方法会<strong>清除</strong>该线程的<strong>中断状态</strong></p>
<p><code>isInterrupted</code>是一个实例方法，可以检查是否有线程被中断，调用这个方法不会改变中断状态</p>
</blockquote>
<p><strong>不要</strong>在代码底层<strong>抑制</strong><code>InterruptedException</code><strong>异常</strong></p>
<p>合理方法</p>
<ul>
<li><p>在<code>catch</code>子句中调用<code>Thread.currentThread().interrupt()</code>来设置中断状态 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySubTask</span><span class="params">()</span></span>&#123;        ...        </span><br><span class="line">    <span class="keyword">try</span>&#123;sleep(delay);&#125;        </span><br><span class="line">    <span class="keyword">catch</span>(InterruptException e)&#123;Thread.currentThread().interrupt();&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用 <code>throws InterruptException</code> 标记方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySubTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptException</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sleep(delay);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>daemon thread守护线程的<strong>唯一用途</strong>是为<strong>其他</strong>线程<strong>提供服务</strong>通过调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.setDaemon(<span class="keyword">true</span>);<span class="comment">//必须在线程启用前调用</span></span><br></pre></td></tr></table></figure>

<p><strong>举例</strong></p>
<ul>
<li><p>计时器线程定时发送 “计时器滴答” 信号给其他线程，所以是守护线程</p>
</li>
<li><p>清空过时缓存项的线程也是守护线程</p>
</li>
</ul>
<p>只剩下守护线程时，虚拟机就会退出</p>
<h4 id="线程名"><a href="#线程名" class="headerlink" title="线程名"></a>线程名</h4><p>默认情况下，线程命名为”Thread-0”、”Thread-1”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">t.setName(<span class="string">&quot;Web Clear&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>线程转储时可能很有用</p>
<h4 id="未捕获异常的处理器"><a href="#未捕获异常的处理器" class="headerlink" title="未捕获异常的处理器"></a>未捕获异常的处理器</h4><p>线程的 <code>run</code> 方法<strong>不能抛出</strong>任何<strong>检查型异常</strong>（检查型异常例如 IOException）（必须处理）</p>
<p>但是<strong>非检查型异常</strong>（派生于 <code>Error</code> 的例如系统资源耗尽，或派生于 <code>RuntimeException</code> 的例如数组访问越界）可能会导致线程终止，这种情况下，线程会死亡</p>
<p>对于<strong>可以传播</strong>的异常，并<strong>没有</strong>任何 <strong>catch 子句</strong>，实际上，线程死亡之前，会将异常传递到一个<strong>用于处理非捕获异常的处理器</strong></p>
<p>这个处理器必须属于一个实现了 <code>Thread.UncaughtExceptionHandler</code> 接口的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过 <code>setUncaughtExceptionHandler</code> 方法为任何线程安装一个处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    uncaughtExceptionHandler = eh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用 <code>Thread</code> 类的静态方法 <code>SetDefaultUncaughtExceptionHandler</code> 为<strong>所有线程</strong>安装一个默认的处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(</span><br><span class="line">            <span class="keyword">new</span> RuntimePermission(<span class="string">&quot;setDefaultUncaughtExceptionHandler&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    defaultUncaughtExceptionHandler = eh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; null unless explicitly set</span><br><span class="line">private volatile UncaughtExceptionHandler uncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; null unless explicitly set</span><br><span class="line">private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果<strong>没有</strong>安装<strong>默认处理器</strong>，则默认处理器为 <code>null</code></li>
<li>没有为<strong>单个线程</strong>安装处理器，那么处理器就是该线程的 <code>ThreadGroup</code> 对象</li>
</ul>
<p><code>ThreadGroup</code> 类实现了 <code>Thread.UncaughtExceptionHandler</code> 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroup</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">uncaughtException</span>(<span class="title">Thread</span> <span class="title">t</span>, <span class="title">Throwable</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">            Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            System.err.print(<span class="string">&quot;Exception in thread \&quot;&quot;</span></span><br><span class="line">                             + t.getName() + <span class="string">&quot;\&quot; &quot;</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadGroup</code> 的 <code>uncaughtException</code> 方法执行一下操作</p>
<ol>
<li>如果该线程组有父线程组，那么调用父线程组的 <code>uncaughtException</code> 方法</li>
<li>否则，如果 <code>Thread.getDefaultExceptionHandler</code> 方法返回一个非 <code>null</code> 处理器，则调用该处理器</li>
<li>否则，如果 <code>Throwable</code> 是一个 <code>ThreadDeath</code> 的一个实例，什么都不做</li>
<li>否则，将线程的名字以及 <code>Throwable</code> 的战轨迹输出到 <code>System.err</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于一个线程（victim thread）如果被stop方法调用，则会抛出ThreadDeath</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDeath</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4417128565033088268L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>线程组</strong>是可以<strong>一起管理的线程的集合</strong>。</p>
<p>默认情况下，创建的所有线程都属于同一个线程组，但是也可以建立其他的组</p>
</blockquote>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><blockquote>
<p>在没有使用操作系统线程的 Java 早期版本中，线程有优先级可能很有用。不过现在不要使用线程优先级了</p>
</blockquote>
<p>在 Java 中，每个线程有一个<strong>优先级</strong></p>
<p>默认情况下，一个线程会<strong>继承</strong>构造它的那个线程的<strong>优先级</strong></p>
<p>通过 <code>setPriority</code> 方法来提高或降低一个线程的优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>每当<strong>线程调度器</strong>有机会选择新线程时，它首先选择具有<strong>较高优先级</strong>的线程</p>
<p>但是，<strong>线程优先级高度依赖于系统</strong>。当虚拟机依赖于宿主机平台的线程实现时，Java 线程的优先级会映射到宿主机平台的优先级（有的平台没有优先级，现在不要使用优先级）</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p><strong>竞态条件（race condition）</strong>：两个或以上的<strong>线程</strong>需要<strong>共享</strong>对<strong>同一数据</strong>进行<strong>存取</strong>，如果两个线程分别对这一共享数据进行<strong>修改</strong>，那么两个线程会相互覆盖，结果取决于两个线程访问的次序。</p>
<p>需要通过<strong>同步存取</strong>来避免<strong>多线程破坏共享数据</strong></p>
<p><strong>示例代码</strong></p>
<p><strong>Bank.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span>[] accounts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">double</span> initialBalance)</span></span>&#123;</span><br><span class="line">        accounts = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">        Arrays.fill(accounts,initialBalance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(accounts[from] &lt; amount) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(Thread.currentThread());</span><br><span class="line">        accounts[from] -= amount;</span><br><span class="line">        System.out.printf(<span class="string">&quot; %10.2f from %d to %d&quot;</span>,amount,from,to);</span><br><span class="line">        accounts[to] += amount;</span><br><span class="line">        System.out.printf(<span class="string">&quot; Total Balance:%10.2f %n&quot;</span>,getTotalBalance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> a : accounts) sum += a;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accounts.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UnsynchBankTest.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsynchBankTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NACCOUNTS = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> INITIAL_BALANCE = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> MAX_AMOUNT = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELAY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Bank bank = <span class="keyword">new</span> Bank(NACCOUNTS,INITIAL_BALANCE);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NACCOUNTS; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> fromAccount = i;</span><br><span class="line">            Runnable r =  ()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                        <span class="keyword">int</span> toAccount = (<span class="keyword">int</span>) (bank.size()*Math.random());</span><br><span class="line">                        <span class="keyword">double</span> amount = MAX_AMOUNT*Math.random();</span><br><span class="line">                        bank.transfer(fromAccount,toAccount,amount);</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (DELAY*Math.random()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;jingtai</span><br><span class="line">            &#125;;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行发现，对于 <code>Total Balance</code> 的值会发生改变（应该保持 100000）</p>
<h4 id="竞态条件详解"><a href="#竞态条件详解" class="headerlink" title="竞态条件详解"></a>竞态条件详解</h4><p>问题在于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accounts[to] +&#x3D; amount;</span><br></pre></td></tr></table></figure>

<p>由于这行代码不是<strong>原子操作</strong>，可能如下处理</p>
<ol>
<li>将 <code>accounts[to]</code> 加载到寄存器</li>
<li>增加 <code>amount</code></li>
<li>将结果写回 <code>accounts[to]</code></li>
</ol>
<p>如果第一个线程在执行步骤 1、2 后，运行权被抢占，而第二个线程被<strong>唤醒</strong>，更新数组同一个元素后，第一个线程被唤醒完成第 3 步则可能出错</p>
<p>查看执行这个类中每一个语句的<strong>虚拟机字节码</strong>，以 <code>Bank</code> 类为例</p>
<ol>
<li>先将当前路径移动到 <code>Bank.java</code> 的位置</li>
<li>用 javac命令对.java 文件进行编译<ul>
<li><code>javac .\UnsynchBankTest.java Bank.java</code></li>
</ul>
</li>
<li>用 javap命令对.class 文件进行反编译<ul>
<li><code>javap -c -v Bank</code></li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">21: aload_0</span><br><span class="line">22: getfield      #2                  &#x2F;&#x2F; Field accounts:[D</span><br><span class="line">25: iload_1</span><br><span class="line">26: dup2</span><br><span class="line">27: daload</span><br><span class="line">28: dload_3</span><br><span class="line">29: dsub</span><br><span class="line">30: dastore</span><br></pre></td></tr></table></figure>

<p>可以看到一条语句由多条指令组成，而执行这些指令的线程可以在任何一条指令上被中断</p>
<p>对此，重点问题是：<strong>能够确保线程失去控制之前，方法已经完成</strong>（保证语句原子性）</p>
<h4 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h4><p>有两种机制可<strong>防止并发访问代码块</strong></p>
<ul>
<li>Java 提供 <code>synchronized</code> 关键字来达到这一目标</li>
<li> Java5 引入 <code>ReentrantLock</code> 类</li>
</ul>
<p><code>synchronized</code> 关键字会自动<strong>提供一个锁</strong>以及相关的<strong>条件</strong>，对于大多数需要<strong>显式锁</strong>，这种机制功能强</p>
<p><code>java.util.concurrent</code> 框架为这些基础机制提供单独的类</p>
<h4 id="重入锁-reentrant"><a href="#重入锁-reentrant" class="headerlink" title="重入锁 reentrant"></a>重入锁 reentrant</h4><p>可重入锁有</p>
<ul>
<li><code>synchronized</code></li>
<li><code>ReentrantLock</code></li>
</ul>
<p>用 <code>ReentrantLock</code> 保护代码块的基本结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();  <span class="comment">// block until condition holds  a ReentrantLock object</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// critical section 临界区</span></span><br><span class="line">            <span class="comment">// ... method body</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock()<span class="comment">// make sure the lock is unlocked even if an exception is thrown</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这结构保证任何时刻<strong>只有一个线程</strong>进入<strong>临界区</strong>。一旦一个<strong>线程</strong>锁定了<strong>锁对象</strong>（注意主语是<strong>线程</strong>），其他任何线程都无法通过 <code>lock</code> 语句。</p>
<p>当其他线程 <strong>调用 <code>lock</code>时，它们会暂停</strong>，直到第一个线程释放这个锁对象（这里指 myLock）</p>
<p><strong>注意</strong></p>
<ul>
<li><p>要把 unclock操作包括在 finally子句中，这一点非常重要。</p>
<ul>
<li>如果<strong>临界区的代码</strong>抛出一个<strong>异常</strong>，锁必须<strong>释放</strong>。否则其他线程将永远阻塞。</li>
</ul>
</li>
<li><p>使用锁时不能使用 try-with-resources语句。</p>
<ul>
<li><p>首先，解锁的方法名不是 <code>close</code>。（这句话的意思要和 <code>try-with-resources</code> 的特性，<code>try-with-resources</code> 会自动释放资源，即调用对应资源的 <code>close</code> 方法，而可能会认为锁也是一个资源，是否可以用这个语句来自动释放呢？答案是不可以的）即使将锁的 <code>unclock</code> 方法重命名成 <code>close</code>，<code>try-with-resources</code> 语句也无法正常工作</p>
</li>
<li><p>它（try-with-resources）首部希望声明一个新变量。但是如果使用一个锁，你可能想使用多个线程共享那个变量（而不是新变量）</p>
<p><strong><code>try-with-resources</code> 语句在首部声明的变量都是只在这语句块中使用的，使用完就销毁的。而对于一个锁，我们希望的是多个线程，能够抢占这个锁，并且这个锁是同一个对象，而不是各自生成一个新的锁对象。</strong></p>
</li>
</ul>
</li>
</ul>
<p>加入可重入锁的 Bank.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock banklock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span></span>&#123;</span><br><span class="line">        banklock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(accounts[from] &lt; amount) <span class="keyword">return</span>;</span><br><span class="line">            System.out.print(Thread.currentThread());</span><br><span class="line">            accounts[from] -= amount;</span><br><span class="line">            System.out.printf(<span class="string">&quot; %10.2f from %d to %d&quot;</span>,amount,from,to);</span><br><span class="line">            accounts[to] += amount;</span><br><span class="line">            System.out.printf(<span class="string">&quot; Total Balance:%10.2f %n&quot;</span>,getTotalBalance());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            banklock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        banklock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">double</span> a : accounts) sum += a;</span><br><span class="line">            <span class="keyword">return</span> sum;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            banklock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>假设一个线程调用了 <code>transfer</code>，但是在执行结束前被<strong>抢占（锁还是在该线程，所以还会继续执行指令）</strong>。再假设第二个线程也调用了 <code>transfer</code>。由于第二个线程不能获得锁，将在调用 <code>lock</code> 方法时被阻塞。必须等待<strong>第一个线程</strong>执行完 <code>transfer</code> 方法，释放锁后，第二个线程才能开始运行。</li>
</ul>
<p>注意：</p>
<ul>
<li>每个 Bank对象都有自己的 ReentrantLock对象。<ul>
<li>两个线程试图访问<strong>同一个 <code>Bank</code> 对象</strong>，那么<strong>锁</strong>可以用来保证<strong>串行化访问</strong></li>
<li>两个线程访问<strong>不同的 <code>Bank</code> 对象</strong>，每个线程会得到<strong>不同的锁对象</strong>，两个线程<strong>都不会阻塞</strong></li>
</ul>
</li>
</ul>
<h5 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h5><p><code>ReentrantLock</code> 称为<strong>重入锁</strong>，因为线程可以<strong>反复获得已拥有的锁</strong>。</p>
<p>重入锁有一个<strong>持有计数（hold count）</strong>来<strong>跟踪</strong>对 <code>lock</code> 方法的<strong>嵌套调用</strong>。</p>
<p>线程每一次调用 <code>lock</code> 方法后都要调用 <code>unlock</code> 方法来<strong>释放锁</strong>（一一对应）。</p>
<p><strong>关键</strong> ：根据这个特性，<strong>被一个锁保护的代码</strong>可以调用另一个使用<strong>相同锁（这里相同的锁指的是同一个锁对象）</strong>的方法。</p>
<ul>
<li><p>比如一个对象（例如一个 <code>Bank</code> 实例化的 <code>bank</code> 对象），这个对象只有维护<strong>一个锁对象</strong><code>banklock</code>。当这个锁对象被线程 A 给占用后（例如在调用 <code>transfer</code>，而 <code>transfer</code> 被 <code>banklock</code> 给保护），如果这个 <code>bank</code> 对象中还有其他的方法（例如 <code>getTotalBalance</code>）是被 <code>banklock</code> 这个锁对象给保护的话，现在就只有线程 A 可以调用 <code>getTotalBalance</code>（因为线程 A 有锁对象 <code>banklock</code>）。即使这个线程 A 中没有调用 <code>getTotalBalance</code>，只调用了 <code>transfer</code> 方法；其他线程也不能够调用 <code>getTotalBalance</code>，必须等线程 A 将调用的 <code>banklock</code> 都释放，才能够调用 <code>getTotalBalance</code> 或者 <code>transfer</code>。</p>
<p>即调用几次释放几次。</p>
</li>
<li><p><code>transfer</code> 方法中调用了 <code>getTotalBalance</code> 方法，此时会继续封锁 <code>banklock</code> 对象，<code>bankLock</code> 对象的持有计数为 2。当 <code>getTotalBalance</code> 方法退出时，持有计数变回 1（因为 <code>unlock</code> 了一次）。当 <code>transfer</code> 方法退出的时候，持有计数变为 0（因为又释放了一次），线程释放锁。</p>
</li>
</ul>
<blockquote>
<p>通常我们可能希望保护会<strong>更新</strong>或<strong>检查</strong>共享对象的代码块，从而能确信当前操作执行完之后其他线程才能使用同一对象</p>
</blockquote>
<p><strong>注意</strong></p>
<ul>
<li>应该确保临界区（即锁保护的代码块）中的代码<strong>不要因为抛出异常而跳出临界区。</strong><ul>
<li>如果在临界区代码块结束之前抛出了异常，<code>finally</code> 子句将释放锁，但是对象可能处于<strong>被破坏的状态</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* &lt;p&gt;This lock supports a maximum of <span class="number">2147483647</span> recursive locks by</span><br><span class="line">* the same thread. Attempts to exceed <span class="keyword">this</span> limit result in</span><br><span class="line">* &#123;<span class="meta">@link</span> Error&#125; <span class="keyword">throws</span> from locking methods.</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ReentrantLock</code> 允许的持有计数最大为 2147483647。</li>
</ul>
<h5 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h5><p>对于 <code>ReentrantLock</code> 对象的构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Creates an instance of &#123;@code ReentrantLock&#125;.</span><br><span class="line"> * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync &#x3D; new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Creates an instance of &#123;@code ReentrantLock&#125; with the</span><br><span class="line"> * given fairness policy.</span><br><span class="line"> *</span><br><span class="line"> * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>ReentrantLock(boolean fair)</code> 构造一个采用<strong>公平策略</strong>的锁。一个公平锁<strong>倾向</strong>于<strong>等待时间最长的线程</strong>（队列先进先出）。不过这种公平保证可能<strong>严重影响性能</strong>。所以在默认情况下，不要求锁是公平的。</p>
<blockquote>
<p>公平锁比常规锁要<strong>慢很多</strong>。</p>
<p>对于要解决的问题有一个特定的理由确实要考虑公平性时，才应使用公平锁。</p>
<p>即使使用公平锁，也无法确保<strong>线程调度器</strong>是公平的。<strong>如果</strong>线程调度器选择<strong>忽略</strong>一个已经为锁等待很长时间的线程，它就没有机会得到公平处理</p>
</blockquote>
<p>这篇 CSDN 上的博客把 <code>ReentrantLock</code> 讲得很生动<a target="_blank" rel="noopener" href="https://blog.csdn.net/yanyan19880509/article/details/52345422?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6.control">轻松学习 java 可重入锁 (ReentrantLock) 的实现原理</a></p>
<h4 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h4><p><strong>情景</strong>：<strong>线程 A</strong>（获得锁对象）进入<strong>临界区</strong>后，却发现只有<strong>满足某个条件</strong>之后它才能执行。而通过引入<strong>条件对象</strong>，让其他线程（线程 B）可以获得这个锁对象去执行任务，同时可能线程 B 的操作能让线程 A 满足该条件，让线程 A 能够继续执行任务。</p>
<p>引入<strong>条件对象（条件变量（conditional variable））</strong>来管理那些已经获得一个锁却不能做有用工作的线程</p>
<p>例如</p>
<p>线程 A 要进行转账给其他账户，但是该账户的余额不足，因此进行了等待（<strong>不满足某个条件</strong>），等待其他账户给它进行转账</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span></span>&#123;</span><br><span class="line">    banklock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(accounts[from] &lt; amount)&#123;</span><br><span class="line">            <span class="comment">//wait</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// transfer funds</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        banklock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这个线程刚刚获得了对 <code>banklock</code> 的排他性访问权，因此别的线程没有存款机会，因此引入<strong>条件对象</strong></p>
<blockquote>
<p>一个<strong>锁对象</strong>可以有一个或多个相关联的<strong>条件对象</strong>。</p>
<p>用 <code>newCondition</code> 方法获得一个条件对象。</p>
<p>习惯上给每个条件对象一个合适的名字来反映它<strong>表示的条件</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> Condition sufficientFunds;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">double</span> initialBalance)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        sufficientFunds = banklock.newCondition(); <span class="comment">//获得banklock的一个条件对象</span></span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到举例中：线程 A 中调用 <code>transfer</code> 发现了余额不够，因此调用 <code>sufficientFunds.await();</code></p>
<ul>
<li>当前线程现在暂停，并<strong>放弃锁</strong>。这就<strong>允许另一个线程执行</strong>，同时我们希望这另一个线程能够增加放弃锁的线程的账户余额（使之满足条件）</li>
</ul>
<blockquote>
<p>等待获得锁的线程和已经调用了 <code>await</code> 方法的线程有本质的不同</p>
<ul>
<li>一旦一个线程调用 await 方法就进入了这个条件的等待集（wait set）。当锁可用时，该线程并不会变为可运行状态。实际上，它仍保持非活动状态，直到另一个线程在同一条件调用 signalAll方法<ul>
<li>一个线程调用了 <code>await</code> 方法后，只有其他的线程在<strong>同一条件</strong>上调用 <code>signalAll</code> 或 <code>signal</code> 方法才可能把这个线程从等待集中取出，否则它将一直处于非活动状态。</li>
<li>它渴望的是 <code>siganlAll</code> 或 <code>signal</code>，而不是 <code>unclock</code></li>
</ul>
</li>
</ul>
</blockquote>
<p>当另一个线程完成转账时，应该调用：<code>sufficientFunds.signalAll();</code></p>
<ul>
<li><p>这个调用会重新<strong>激活</strong>等待<strong>这个条件</strong>的<strong>所有</strong>线程。</p>
</li>
<li><p>当这些线程从<strong>等待集</strong>中移除，它们再次成为<strong>可运行的线程</strong>，<strong>调度器</strong>最终将再次将它们<strong>激活</strong>。同时它们会<strong>尝试重新进入该对象</strong>。一旦<strong>锁可用</strong>，它们中的某个线程将从 <strong><code>await</code> 调用返回</strong>，<strong>得到</strong>这个<strong>锁</strong>，并从之前**暂停的地方继续执行 **</p>
<ul>
<li><code>signalAll</code> 方法会让所有在该条件下的等待集中的线程激活，但是不代表该线程就能立马执行，这些线程也是<strong>需要获得该锁对象</strong>，并从暂停的地方（await 地方）继续执行</li>
</ul>
</li>
<li><p>线程应当<strong>再次测试条件</strong>。不能保证现在一定满足条件 ——<code>signalAll</code> 方法仅仅是<strong>通知</strong>的线程：现在<strong>有可能满足</strong>条件，值得再次检查条件</p>
<ul>
<li><p>这里有可能满足条件的意思是：可能其他线程执行 <code>signalAll</code> 的这个操作时就根本没有使等待集的线程满足条件、也有可能是 <code>signalAll</code> 方法调用时的时候确实满足了，但是等到等待集的某个线程获得锁对象的时候，就又不满足了。</p>
<p>signalAll只是接触等待线程的阻塞，是他们可以在线程释放锁后竞争。</p>
</li>
<li><p>因为我们需要确保这个等待集的线程确实能够从 <code>await</code> 中解脱出来，因此我们需要将 <code>await</code> 调用放在循环中，来保证 <code>signalAll</code> 后能够再次检查。</p>
<p>常用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!(OK to proceed))</span><br><span class="line">	condition.await();</span><br></pre></td></tr></table></figure></li>
<li><p>await线程只能寄希望于其他线程，如果没有其他线程重新激活等待线程，就永远不再运行。</p>
</li>
</ul>
</li>
</ul>
<p>singal：随机选择一个等待集中的线程，并解除这个线程阻塞状态，比解除所有线程阻塞更高效，但是有死锁风险（可能被解除线程发现自己仍不能运行，它会再次阻塞，如果没有其他线程调用singal）</p>
<p>signalAll：重新激活等待这个条件的所有线程。</p>
<p><strong>死锁（deadlock）</strong>现象有可能发生：所有其他线程都被阻塞，最后一个活动线程调用了<code>await</code>方法，但没有先解除另外某个线程的阻塞。此时没有线程可以接触其他线程的阻塞状态，程序永远挂起。</p>
<p><strong>调用<code>signalAll()</code>方法的时机</strong>只要一个对象的状态有变化而且有利于等待的线程，就可以调用<code>signalAll</code></p>
<p>​    例如一个账户的余额发生改变时，就应该给等待线程一个机会来检查余额。 在完成转账的时候，调用<code>signalAll</code>方法</p>
<blockquote>
<p><strong>注意</strong></p>
<p>只有当线程<strong>拥有一个条件的锁</strong>时，它才能在这个条件上调用 <code>await</code>、<code>signalAll</code>、<code>signal</code></p>
</blockquote>
<h4 id="锁和条件小结"><a href="#锁和条件小结" class="headerlink" title="锁和条件小结"></a>锁和条件小结</h4><ul>
<li><strong>锁</strong>用来<strong>保护代码片段</strong>，一次只能由<strong>一个线程</strong>执行被保护的代码。</li>
<li><strong>锁</strong>可以<strong>管理</strong>试图进入被保护代码段的<strong>线程</strong></li>
<li><strong>一个锁</strong>可以由一个或多个相关联的<strong>条件对象</strong></li>
<li>每个<strong>条件对象管理</strong>那些已经<strong>进入</strong>被保护<strong>代码段</strong>但<strong>不能运行</strong>的<strong>线程</strong> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base of synchronization control for this lock. Subclassed</span></span><br><span class="line"><span class="comment">     * into fair and nonfair versions below. Uses AQS state to</span></span><br><span class="line"><span class="comment">     * represent the number of holds on the lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">       	...	</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">   		...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getHoldCount();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">/*      +------+  prev +-----+       +-----+</span></span><br><span class="line"><span class="comment">     * head |      | &lt;---- |     | &lt;---- |     |  tail</span></span><br><span class="line"><span class="comment">     *      +------+       +-----+       +-----+</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The synchronization state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** First node of condition queue. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">/** Last node of condition queue. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>ReentrantLock</code> 里面维护一个 <code>Sync</code> 类对象，而 <code>Sync</code> 对象维护一个先进先出（FIFO）的队列，用来管理线程</p>
<p>可以看到 <code>ReentrantLock</code> 的 <code>newCondition</code> 方法是调用 <code>Sync</code> 类的 <code>newCondition</code> 方法。</p>
<p>而 <code>newCondition</code> 方法实例化一个 <code>Condition</code> 对象，该对象里面也维护着一个队列。在 <code>ConditionObject</code> 中的 <code>Node</code> 类和 <code>AbstractQueuedSynchronizer</code> 中的 <code>Node</code> 类是一样的。</p>
<p>也可以看到持有计数（hold count）是通过整型变量 <code>state</code> 来记录的</p>
<h4 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h4><p>Java 语言内置的一种机制</p>
<p>从 1.0 版本开始，Java 中的<strong>每个对象</strong>都有一个<strong>内部锁</strong>。</p>
<p>如果一个方法声明时有 <code>synchronized</code> 关键字，那么对象的锁（内部对象锁）将保护整个方法。</p>
<ul>
<li><p>要调用这个方法，线程必须获得内部对象锁</p>
</li>
<li><p>```java<br>public synchronized void method(){</p>
<pre><code>    method body
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**等价于**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public void method()&#123;</span><br><span class="line">    this.intrinsicLock.lock();</span><br><span class="line">    try&#123;</span><br><span class="line">        method body</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        this.intrinsicLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>内部对象锁</strong>只有一个<strong>关联条件</strong>。</p>
<ul>
<li><strong><code>wait</code> 方法</strong>将一个线程增加到<strong>等待集</strong>中</li>
<li><code>notifyAll</code> 和 <code>notify</code> 方法可以<strong>解除</strong>等待线程的<strong>阻塞</strong></li>
</ul>
<p>调用 <code>wait</code><strong>等价于</strong><code>intrinsicCondition.await();</code></p>
<p>调用 <code>notifyAll</code><strong>等价于</strong><code>intrinsicCondition.signalAll();</code></p>
<blockquote>
<p><code>wait</code>、<code>notifyAll</code> 以及 <code>notify</code> 方法是 <code>Object</code> 类的 <code>final</code> 方法。</p>
<p><code>Condition</code> 方法必须命名为 <code>await</code>、<code>signalAll</code> 和 <code>signal</code>，从而不会与那些方法发生冲突</p>
</blockquote>
<p>使用 <code>synchronized</code> 关键字实现 <code>Bank</code> 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span>[] accounts;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">double</span> initialBalance)</span></span>&#123;</span><br><span class="line">        accounts = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">        Arrays.fill(accounts,initialBalance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(accounts[from] &lt; amount)&#123;</span><br><span class="line">            wait(); <span class="comment">// wait on intrinsic object lock&#x27;s single conditon</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(Thread.currentThread());</span><br><span class="line">        accounts[from] -= amount;</span><br><span class="line">        System.out.printf(<span class="string">&quot; %10.2f from %d to %d&quot;</span>,amount,from,to);</span><br><span class="line">        accounts[to] += amount;</span><br><span class="line">        System.out.printf(<span class="string">&quot; Total Balance:%10.2f %n&quot;</span>,getTotalBalance());</span><br><span class="line">        notifyAll(); <span class="comment">// notify all threads waiting on the condition</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> a : accounts) sum += a;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accounts.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释说明：</p>
<ul>
<li>每个对象都有一个内部锁，并且这个锁有一个内部条件。</li>
<li>这个锁会管理试图进入 <code>synchronized</code> 方法的线程。</li>
<li>这个条件可以管理调用 <code>wait</code> 的线程</li>
</ul>
<p>将<strong>静态方法</strong>声明为<strong>同步（synchronized）</strong>也是合法的</p>
<ul>
<li><p>如果调用这样一个方法，它会获得相关类对象的内部锁</p>
<p>例如 <code>Bank</code> 类有一个<strong>静态同步方法</strong>，调用这个方法时，**<code>Bank.class</code>** 对象的锁会被锁定</p>
<p>此时没有其他线程可以调用这个类的该方法或任何其他同步静态方法</p>
<ul>
<li>因为内部锁也是一个可重入锁，当一个线程获得该锁时，其他线程就不能调用被这个锁保护的代码段 </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">     <span class="comment">/* Only one thread at a time can own an object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">     * @throws  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment">     *               the owner of this object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>; <span class="comment">//该方法只能在一个同步方法或同步块中调用</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">/* @throws  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment">     *               the owner of this object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>; <span class="comment">//该方法只能在同步方法或同步块中调用</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">/* @param      timeout   the maximum time to wait in milliseconds.</span></span><br><span class="line"><span class="comment">     * @throws  IllegalArgumentException      if the value of timeout is</span></span><br><span class="line"><span class="comment">     *               negative.</span></span><br><span class="line"><span class="comment">     * @throws  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment">     *               the owner of the object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">     * @throws  InterruptedException if any thread interrupted the</span></span><br><span class="line"><span class="comment">     *             current thread before or while the current thread</span></span><br><span class="line"><span class="comment">     *             was waiting for a notification.  The &lt;i&gt;interrupted</span></span><br><span class="line"><span class="comment">     *             status&lt;/i&gt; of the current thread is cleared when</span></span><br><span class="line"><span class="comment">     *             this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">//该方法只能在一个同步方法或同步块中调用</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">/* @param      timeout   the maximum time to wait in milliseconds.</span></span><br><span class="line"><span class="comment">     * @param      nanos      additional time, in nanoseconds range</span></span><br><span class="line"><span class="comment">     *                       0-999999.</span></span><br><span class="line"><span class="comment">     * @throws  IllegalArgumentException      if the value of timeout is</span></span><br><span class="line"><span class="comment">     *                      negative or the value of nanos is</span></span><br><span class="line"><span class="comment">     *                      not in the range 0-999999.</span></span><br><span class="line"><span class="comment">     * @throws  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment">     *               the owner of this object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">     * @throws  InterruptedException if any thread interrupted the</span></span><br><span class="line"><span class="comment">     *             current thread before or while the current thread</span></span><br><span class="line"><span class="comment">     *             was waiting for a notification.  The &lt;i&gt;interrupted</span></span><br><span class="line"><span class="comment">     *             status&lt;/i&gt; of the current thread is cleared when</span></span><br><span class="line"><span class="comment">     *             this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;...&#125; <span class="comment">//该方法只能在一个同步方法或同步块中调用 ， 导致一个线程进入等待状态，直到它得到通知或经过了指定的时间</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">/* @throws  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment">     *               the owner of the object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">     * @throws  InterruptedException if any thread interrupted the</span></span><br><span class="line"><span class="comment">     *             current thread before or while the current thread</span></span><br><span class="line"><span class="comment">     *             was waiting for a notification.  The &lt;i&gt;interrupted</span></span><br><span class="line"><span class="comment">     *             status&lt;/i&gt; of the current thread is cleared when</span></span><br><span class="line"><span class="comment">     *             this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; <span class="comment">//该方法只能在一个同步方法或同步块中调用</span></span><br><span class="line">        wait(<span class="number">0</span>);  <span class="comment">//导致一个线程进入等待状态，直到它得到通知</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内部锁</strong>和<strong>条件</strong>存在一些限制</p>
<ul>
<li><strong>不能中断</strong>一个正在<strong>尝试</strong>获得该锁的<strong>线程</strong></li>
<li><strong>不能</strong>指定<strong>尝试获得锁</strong>时的<strong>超时时间</strong></li>
<li>每个锁<strong>仅有一个条件</strong>可能是不够的</li>
</ul>
<p><strong>建议</strong></p>
<ul>
<li>最好既不使用 Lock/Condition，也步使用 synchronized 关键字<ul>
<li>可以使用 java.util.concurrent 包中的某种机制，它会处理所有的锁定<ul>
<li>例如：阻塞队列同步完成一个共同任务的线程、并行流</li>
</ul>
</li>
</ul>
</li>
<li>如果 <code>synchronized</code> 关键字适合，尽量使用</li>
<li>需要 <code>Lock/Condition</code> 结构提供的额外能力，则使用 <code>Lock/Condition</code></li>
</ul>
<h4 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h4><p>每个java对象都有一个内部锁。</p>
<p>通过两种方法可以获得这个锁</p>
<ul>
<li>线程调用同步方法</li>
<li>进入同步块</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj)&#123; <span class="comment">// this is the syntax for a synchronized block</span></span><br><span class="line">    critical section</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 <code>lock</code> 对象，只是为了使用每个 Java 对象拥有的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span>[] accounts;</span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock)&#123; <span class="comment">// an ad-hoc lock</span></span><br><span class="line">            accounts[from] -= amount;</span><br><span class="line">        	accounts[to] += amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端锁定（client-side locking）</strong>：使用一个<strong>对象的锁</strong>来实现额外的原子操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Vector&lt;Double&gt; accounts, <span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(accounts)&#123; <span class="comment">// an ad-hoc lock</span></span><br><span class="line">        accounts.set(from,accounts.get(from) - amount);</span><br><span class="line">        accounts.set(to,accounts.get(to) + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端锁定非常脆弱，通常不推荐使用</p>
<ul>
<li>上面这代码中，我们不能保证 <code>Vector</code> 内部类中，对所有更改方法都使用内部锁</li>
</ul>
<h4 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h4><p><strong>锁</strong>和<strong>条件</strong>是实现线程同步的强大工具，但严格来讲它们<strong>不是面向对象的</strong></p>
<p><strong>监视器（monitor）</strong>具有如下特性（这里是监视器的概念，不是 Java 真实实现的监视器）</p>
<ul>
<li>监视器是<strong>只包含私有字段</strong>的类</li>
<li>监视器类的<strong>每个对象</strong>有一个关联的<strong>锁</strong></li>
<li>所有的方法由这个锁锁定<ul>
<li>如果客户端调用 <code>obj.method()</code> 那么 <code>obj</code> 对象的<strong>锁</strong>在方法调用<strong>开始</strong>时自动<strong>获得</strong>，并且当方法<strong>返回时</strong>自动<strong>释放</strong>该锁</li>
<li>因为所有的字段时私有的，这样的安排可以确保一个线程处理字段时，没有其他线程能够访问这些字段</li>
</ul>
</li>
<li>锁可以有任意<strong>多个</strong>相关联的<strong>条件</strong></li>
</ul>
<p>Java 监视器的<strong>早期版本</strong>只有单一条件，而不使用任何显式的条件变量，如<code>await accounts[from] &gt;= amount</code></p>
<ul>
<li>盲目地重新测试条件是低效的</li>
<li>利用显式的条件变量解决这个问题：每个条件变量管理单独的一组线程</li>
</ul>
<p>Java 以<strong>不太严格</strong>的方式采用监视器概念</p>
<ul>
<li>Java 中的<strong>每一个对象</strong>都有一个内部锁和一个内部条件。</li>
<li>如果一个方法用 <code>synchronized</code> 关键字声明，则它表现得就像一个监视器方法</li>
<li>可以通过调用 <code>await</code>、<code>notify</code>、<code>notifyAll</code> 来访问条件变量</li>
</ul>
<p>Java 对象不同于监视器的地方，削弱了线程的安全性</p>
<ul>
<li>字段不要求是 <code>private</code></li>
<li>方法不要求是 <code>synchronized</code></li>
<li>内部锁对客户是可用的</li>
</ul>
<h4 id="volatile-字段"><a href="#volatile-字段" class="headerlink" title="volatile 字段"></a>volatile 字段</h4><p>相当于修改了字段的可见性。</p>
<p>场景：只是为了读写一两个实例字段而使用同步，所带来的开销好像有些划不来</p>
<p><strong>出错可能原因</strong></p>
<ul>
<li>有多处理器的计算机能够暂时在寄存器或本地内存缓存中保存内存值<ul>
<li>运行在不同处理器上的线程可能看到<strong>同一个内存位置</strong>有<strong>不同值</strong></li>
</ul>
</li>
<li>编译器可以改变指令的顺序以使吞吐量最大化<ul>
<li>编译器不会选择可能改变<strong>代码语义</strong>的顺序。但编译器认为内存值，只有在代码中有显式的修改指令时才会改变。但是内存值可能被<strong>另一个线程</strong>改变</li>
</ul>
</li>
</ul>
<p>使用<strong>锁</strong>来保护可能被多个线程访问的代码，不存在上述问题。编译器被要求在必要的时候<strong>刷新本地缓存</strong>来支持锁</p>
<p><code>volatile</code> 关键字为<strong>实例字段</strong>的<strong>同步访问</strong>提供一种<strong>免锁机制</strong></p>
<ul>
<li>如果声明一个字段为 <code>volatile</code>，那么编译器和虚拟机就知道该字段可能被另一个线程并发更新 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private volatile boolean done;</span><br><span class="line">public boolean isDone() &#123;return done;&#125;</span><br><span class="line">public void setDone() &#123;done &#x3D; true;&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会插入适当的代码，以确保如果一个线程对 <code>done</code> 变量做了修改，这个修改对读取这个变量的所有<strong>其他线程都可见</strong></p>
<ul>
<li>线程对 <code>volatile</code> 关键字修饰的变量进行修改后，要立刻写回主内存中<ul>
<li><code>volatile</code> 使得该变量的每次修改后，增加了一个<strong>内存屏障</strong>，保证修改后的值必须刷新到<strong>主内存</strong>，才能进行内存屏障后续的指令操作</li>
</ul>
</li>
<li>线程对 <code>volatile</code> 关键字修饰的变量进行读取的时候，要从<strong>主内存</strong>中读，而不是缓存</li>
</ul>
<p><strong>注意</strong></p>
<p><code>volatile</code> 变量不能提供原子性（不能保证原子性）</p>
<ul>
<li>即不能确保翻转字段中的值。不能保证读取、翻转和写入不被中断</li>
</ul>
<p>例如 <code>i++</code>，对应指令可以分为 load、increment、store、memory barries 四个操作。</p>
<blockquote>
<p>内存屏障是线程安全的，但是内存屏障<strong>之前</strong>的指令<strong>不是线程安全</strong>的</p>
</blockquote>
<p>对于自增操作来说，<strong>寄存器</strong>保存<strong>中间值</strong>，在<strong>没有刷入主内存</strong>之前，可能被另外的线程打断，并读取同一个变量进行操作，从而出现了不一致的情况。</p>
<p>volatile修饰的字段读性能与普通字段几乎相同，写性能较低</p>
<h4 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h4><p>使用锁和 <code>volatile</code> 修饰符，可以从多个线程安全地读取一个字段</p>
<p>将一个字段声明为 <code>final</code> 时，也可以安全地访问该共享字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;String,Double&gt; accounts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>其他线程</strong>会在<strong>构造器完成构造</strong>之后<strong>才看到这个 accounts 变量</strong></p>
<p>如果不使用 <code>final</code>，就不能保证其他线程看到的是 <code>accounts</code> 更新的值，它们可能只是看到 <code>null</code>，而不是新构造的 <code>HashMap</code></p>
<p>注意：final 不保证 map 的操作（<code>put</code>，<code>get</code> 方法）是线程安全的，如果有多个线程更改和读取这个映射（map），仍需要同步</p>
<blockquote>
<p>final</p>
<ul>
<li><p>修饰方法</p>
<ul>
<li>方法无法被子类重写，但可以被继承</li>
</ul>
</li>
<li><p>修饰引用</p>
<ul>
<li><p>基本数据类型</p>
<p>引用为常量，赋初值后无法修改</p>
</li>
<li><p>引用数据类型（对象，数组）</p>
<p>对象、数组可以修改，但对象、数组的引用地址不能修改。（类似指针不能再指向其他对象，数组）</p>
</li>
<li><p>类的成员变量</p>
<p>必须赋初值</p>
</li>
</ul>
</li>
<li><p>修饰类</p>
<ul>
<li>类无法被继承</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p><code>java.util.concurrent.atomic</code> 包中有很多类使用了很高效的机器级指令来保证其他操作的原子性</p>
<p>。。。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>所有线程都被阻塞。</p>
<p>锁和条件不能解决多线程中的死锁问题</p>
<h4 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h4><p>使用 <code>ThreadLocal</code> 辅助类为<strong>各个线程</strong>提供<strong>各自的实例</strong></p>
<p>解决问题：例如 <code>SimpleDateFormat</code> 类不是线程安全的，如果多线程并发访问，其内部的数据结构可能会被破坏而结果错误</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>多个线程同时调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String dateStamp = dataFormat.format(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>

<p>则在同时访问 dateFormat 对象时可能出错</p>
<ul>
<li>可以通过使用同步，但是开销很大</li>
<li>在需要的时候构造一个局部 <code>SimpleDateFormat</code> 对象，但是太浪费</li>
</ul>
<p>解决办法：</p>
<p>为每个线程构造一个实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormat =</span><br><span class="line">    ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>要访问具体的格式化方法，可以调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String dateStamp = dateFormat.get().format(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>

<ul>
<li>在一个给定线程中<strong>首次</strong>调用 <code>get</code> 时，会调用构造器中的 <code>lambda</code> 表达式。</li>
<li>此后的 <code>get</code> 方法返回属于当前线程的那个实例</li>
</ul>
<p>多个线程生成随机数问题：</p>
<p><code>java.util.Random</code> 类是线程安全，但多线程访问需要等待一个共享的随机数生成器，效率低</p>
<ul>
<li><p>可以使用 <code>ThreadLocal</code> 辅助类，为每个线程提供一个单独的生成器</p>
</li>
<li><p>Java7 提供一个便利类</p>
<ul>
<li>```<br>int random = ThreadLocalRandom.current().nextInt(upperBound);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;ThreadLocalRandom.current()&#96;返回特定于当前线程的&#96;Random&#96;类的实例</span><br><span class="line"></span><br><span class="line">#### 废弃&#96;stop&#96;和&#96;suspend&#96;方法的原因</span><br><span class="line"></span><br><span class="line">最初Java版本中</span><br><span class="line"></span><br><span class="line">- &#96;stop&#96;来终止线程</span><br><span class="line"></span><br><span class="line">- &#96;suspend&#96;方法来阻塞线程，直到另一个线程调用&#96;resume&#96;</span><br><span class="line"></span><br><span class="line">&#96;stop&#96;和&#96;suspend&#96;方法都试图控制一个给定线程，而没有线程的互操作</span><br><span class="line"></span><br><span class="line">##### stop方法</span><br><span class="line"></span><br><span class="line">该方法会终止所有未结束的方法，包括&#96;run&#96;方法。</span><br><span class="line"></span><br><span class="line">当线程被终止，它会立即释放被它锁定的所有对象的锁。这会导致对象处于不一致的状态因此：希**望停止一个线程的时候应该中断（intterupt）该线程**，被中断的线程可以在安全的时候终止</span><br><span class="line"></span><br><span class="line">&gt; 被停止（stop方法调用）的线程会抛出&#96;ThreadDeath&#96;异常，从而退出它调用的所有同步方法。因此这个线程会释放它持有的内部对象锁</span><br><span class="line"></span><br><span class="line">##### suspend方法</span><br><span class="line"></span><br><span class="line">&#96;suspend&#96;方法不会破坏对象，但是会导致**死锁**</span><br><span class="line"></span><br><span class="line">用&#96;suspend&#96;挂起一个持有锁的线程，那么在线程恢复运行之前这个锁是不可用的。</span><br><span class="line"></span><br><span class="line">如果调用&#96;suspend&#96;的方法线程试图获得同一个锁（被&#96;suspend&#96;的线程持有的锁），那么程序出现死锁**被挂起的线程等待恢复，将其挂起的线程等待获得锁**</span><br><span class="line"></span><br><span class="line">安全挂起线程，可以引入一个suspendRequested，并在run方法某个安全的地方测试。安全地方指**该线程没有没有锁定其他线程需要的对象**的地方。</span><br><span class="line"></span><br><span class="line">### 线程安全集合</span><br><span class="line"></span><br><span class="line">多个线程并发修改一个数据结构，很容易破坏这个数据结构。</span><br><span class="line"></span><br><span class="line">可以通过提供**锁**来保护共享的数据结构，也可以选择**线程安全的实现**</span><br><span class="line"></span><br><span class="line">#### 阻塞队列 blocking queue</span><br><span class="line"></span><br><span class="line">很多线程问题可以用一个或多个队列来安全的描述。（OS）</span><br><span class="line"></span><br><span class="line">- 生产者线程向队列插入元素</span><br><span class="line">- 消费者线程向队列获取元素</span><br><span class="line"></span><br><span class="line">使用队列不需要考虑同步（实现 线程安全队列类必须考虑锁和条件）</span><br><span class="line"></span><br><span class="line">**阻塞队列**：出现一下两种情况，阻塞队列将导致**线程阻塞**</span><br><span class="line"></span><br><span class="line">- 试图向队列**添加**元素而队列已**满**</span><br><span class="line">- 想从队列**移出**元素而队列为**空**时</span><br><span class="line"></span><br><span class="line">阻塞队列方法分成3种：根据当队列**满或空**时它们完成的动作分</span><br><span class="line"></span><br><span class="line">- &#96;put&#96;、&#96;take&#96;  </span><br><span class="line"></span><br><span class="line">  - &#96;put&#96;如果队列满则阻塞  </span><br><span class="line">  -  &#96;take&#96;如果队列空则阻塞</span><br><span class="line"></span><br><span class="line">- &#96;add&#96;、&#96;remove&#96;、&#96;element&#96;</span><br><span class="line"></span><br><span class="line">  抛出异常   &#96;IllegalStateException&#96;、&#96;NoSuchElementException&#96;</span><br><span class="line"></span><br><span class="line">- &#96;offer&#96;、&#96;poll&#96;、&#96;peek&#96;  - 给出一个错误提示而不会抛出异常</span><br><span class="line"></span><br><span class="line">  - 给出一个错误提示而不会抛出异常 </span><br><span class="line">  - 返回&#96;false&#96;或&#96;null&#96;</span><br><span class="line"></span><br><span class="line">&gt; &#96;poll&#96;和&#96;peek&#96;方法返回&#96;null&#96;来**指示失败**，因此，向这些队列中**插入**&#96;null&#96;值是**非法**的、</span><br><span class="line">&gt;</span><br><span class="line">&gt; 同时也有带超时时间的&#96;offer&#96;方法和&#96;poll&#96;方法</span><br><span class="line">&gt;</span><br><span class="line">&gt; &#96;put&#96;和&#96;take&#96;方法与不带超时参数的&#96;offer&#96;和&#96;poll&#96;方法等效</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;java.util.concurrent&#96;包种提供了阻塞队列的几个变体</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123;</span><br><span class="line">    boolean add(E e);</span><br><span class="line">    boolean offer(E e);</span><br><span class="line">    void put(E e) throws InterruptedException;</span><br><span class="line">    boolean offer(E e, long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line">    E take() throws InterruptedException;</span><br><span class="line">    E poll(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line">    int remainingCapacity();</span><br><span class="line">    boolean remove(Object o);</span><br><span class="line">    public boolean contains(Object o);</span><br><span class="line">    int drainTo(Collection&lt;? super E&gt; c);</span><br><span class="line">    int drainTo(Collection&lt;? super E&gt; c, int maxElements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingDeque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putFirst</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putLast</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function">E <span class="title">takeFirst</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function">E <span class="title">takeLast</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function">E <span class="title">pollFirst</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function">E <span class="title">pollLast</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LinkedBlockingQueue</code> 的容量没有上界，但是可以指定一个最大容量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LinkedBlockingDeque</code> 是一个双端队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingDeque</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingDeque</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/** Main lock guarding all access */</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Condition for waiting takes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Condition for waiting puts */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ArrayBlockingQueue</code> 在构造时，需要<strong>指定容量</strong>，并且有一个可选的参数来指定是否需要<strong>公平性</strong></p>
<ul>
<li>设置了公平参数，那么等待了最长时间的线程会优先得到处理。</li>
<li>通常公平性会降低性能 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The queued items */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line">    <span class="comment">/** Main lock guarding all access */</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="comment">/** Condition for waiting takes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="comment">/** Condition for waiting puts */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">        notEmpty = lock.newCondition();</span><br><span class="line">        notFull =  lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PriorityBlockingQueue</code> 是一个<strong>优先队列</strong>，不是先进先出队列。</p>
<ul>
<li>元素按照它们的优先级顺序移除</li>
<li>队列没有容量上限</li>
<li>如果队列是空的，则获取元素操作会阻塞 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The comparator, or null if priority queue uses elements&#x27;</span></span><br><span class="line"><span class="comment">     * natural ordering.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lock used for all public operations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Condition for blocking when empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spinlock for allocation, acquired via CAS.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DelayQueue</code> 包含实现了 <code>Delayed</code> 接口的对象</p>
<p>元素只有在延迟结束的情况，才能从 <code>DelayQueue</code> 移除</p>
<p>还需要实现 <code>compareTo</code> 方法，<code>DelayQueue</code> 使用该方法对元素排序（不能通过构造器传入 <code>comparator</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 返回对象的剩余延迟。0或负值表示延迟已经结束</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java7 增加 <code>TransferQueue</code> 接口，允许生产者线程等待，直到消费者准备就绪就可以接收元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//传输成功返回true，否则false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e)</span></span>;</span><br><span class="line">	<span class="comment">// 传输一个值，或者尝试在给定的超时时间传输这个值，这个调用将阻塞，直到另一个线程将元素删除</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasWaitingConsumer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWaitingConsumerCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedTransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高效的映射、集和队列"><a href="#高效的映射、集和队列" class="headerlink" title="高效的映射、集和队列"></a>高效的映射、集和队列</h4><p><code>java.util.concurrent</code>提供映射、有序集和队列的高效实现</p>
<p><code>ConcurrentHashMap</code>、<code>ConcurrentSkipListMap</code>、<code>ConcurrentSkipListSet</code>、`ConcurrentLinkedQueue</p>
<p>这些集合通过<strong>允许并发</strong>地访问数据结构的<strong>不同部分</strong>，尽可能<strong>减少竞争</strong></p>
<p>与大多数集合不同，这些类的 <code>size</code> 方法不一定在常量时间内完成操作</p>
<ul>
<li>确定这些集合的当前大小通常需要遍历</li>
</ul>
<p>集合返回<strong>弱一致性（weakly consistent）</strong>的迭代器</p>
<ul>
<li><p>迭代器不一定能反映出它们构造之后的所有更改</p>
</li>
<li><p>但不会将同一个值返回两次</p>
</li>
<li><p>不会抛出 <code>ConcurrentModificationException</code>异常</p>
<blockquote>
<p> java.util 包中的集合在迭代器构造后发生改变，会抛出异常ConcurrentModificationException</p>
</blockquote>
</li>
</ul>
<p><code>ConcurrentHashMap</code> 可以高效的支持大量的<strong>阅读器</strong>和一定数量的<strong>书写器</strong>。</p>
<ul>
<li>默认情况下可以至多 16 个同时运行的书写器线程。</li>
<li>可以有更多的书写其线程，但是同一时间如果多于 16 个，其他线程将暂时阻塞 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>; <span class="comment">// 默认初是容量为16</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">// 装载银子默认值为0.75，如果每个桶的平均负载超过装载因子，表的大小会重新调整</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123; <span class="comment">// 并发级别是估计的并发书写器的线程数</span></span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">            initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">        <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">        <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mappingCount</span><span class="params">()</span> </span>&#123;...&#125; <span class="comment">//如果映射操作20亿个条目，可以将大小作为long返回</span></span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentNavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="映射条目原子更新"><a href="#映射条目原子更新" class="headerlink" title="映射条目原子更新"></a>映射条目原子更新</h4><p>java 新API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.compute(word,(k,v) -&gt; v == <span class="keyword">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>);<span class="comment">//提供一个键和计算新值的函数，键接受和键相关联的值</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ConcurrentHashMap</code> 中不允许有 null 值，因为很多方法都使用 <code>null</code> 值来指示映射中某个给定的键不存在</p>
</blockquote>
<p><code>computeIfPresent</code> 只在已经有原值的情况下计算</p>
<p><code>computeIfAbsent</code> 只在没有原值的情况下计算新值</p>
<p>以上两个方法不处理键</p>
<p>首次增加一个键时通常需要特殊处理，merge方法可以较为方便的完成，merge有个参数表示键不存在时的初始值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.merge(word,<span class="number">1L</span>,(existingValue, newValue) -&gt; existingValue + newValue);</span><br><span class="line"><span class="comment">//可简化为</span></span><br><span class="line">map.merge(word,<span class="number">1L</span>,Long::sum)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果传入 <code>merge</code> 或 <code>compute</code> 的函数返回 null，则将从映射中删除现有的条目</p>
</blockquote>
<h4 id="对并发散列映射的批操作"><a href="#对并发散列映射的批操作" class="headerlink" title="对并发散列映射的批操作"></a>对并发散列映射的批操作</h4><p>即使有其他线程在处理映射，这些操作也能安全地执行。</p>
<p>批操作会<strong>遍历</strong>映射，处理遍历过程中找到的元素</p>
<blockquote>
<p>除非知道批操作运行时映射不会修改，否则要把结果看作是映射状态的一个近似</p>
</blockquote>
<p>有三种不同操作</p>
<ul>
<li>search（搜索）为每个键或值应用一个函数，直到函数生成一个非 null 的结果。然后搜索终止，返回这个函数的结果</li>
<li>reduce（归约）组合所有键或值，这里要使用所提供的一个累加函数</li>
<li>forEach 为所有键或值应用一个函数</li>
</ul>
<p>每个操作有四个版本</p>
<ul>
<li>operationKeys：处理键</li>
<li> operationValues：处理值</li>
<li> operation：处理键和值</li>
<li> operationEntries：处理 Map.Entry 对象</li>
</ul>
<p>对于上述各操作，需要指定<strong>参数化阈值（parallelism threshold）</strong>。如果映射包含的元素多余这个阈值就会并行完成批操作。</p>
<ul>
<li>希望批操作在一个线程中完成可使用Long.MAX_VALUE作为阈值</li>
<li>希望尽可能多的线程运行批操作可使用1作为阈值</li>
</ul>
<h4 id="并发集视图"><a href="#并发集视图" class="headerlink" title="并发集视图"></a>并发集视图</h4><p>java中没有ConcurrentHashSet类</p>
<p>静态<code>newKeySet</code>方法会生成一个<code>Set&lt;K&gt;</code>,这实际上是一个<code>ConcurrentHashMap&lt;K,Boolean&gt;</code>的一个包装器（所欲映射的值为Boolean.TRUE,因为只把它用成一个集，所以不关心映射值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; words = ConcurrentHashMap.&lt;String&gt;newKeySet();</span><br></pre></td></tr></table></figure>

<p>原来有一个映射可使用keySet生成键集，这个集可更改。</p>
<p>删除集的元素，键（及对应值）也会从映射中删除。</p>
<p>向集中增加元素没有意义，没有相应值可以增加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; words = map.keySet(<span class="number">1L</span>);</span><br><span class="line">words.add(<span class="string">&quot;Java&quot;</span>)<span class="comment">//不存在时使用初始值1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@link</span> Set&#125; backed by a ConcurrentHashMap</span></span><br><span class="line"><span class="comment">     * from the given type to &#123;<span class="doctag">@code</span> Boolean.TRUE&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt; the element type of the returned set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; <span class="function">KeySetView&lt;K,Boolean&gt; <span class="title">newKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KeySetView&lt;K,Boolean&gt;</span><br><span class="line">        (<span class="keyword">new</span> ConcurrentHashMap&lt;K,Boolean&gt;(), Boolean.TRUE);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the keys in this map, using the</span></span><br><span class="line"><span class="comment">     * given common mapped value for any additions (i.e., &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Collection#add&#125; and &#123;<span class="doctag">@link</span> Collection#addAll(Collection)&#125;).</span></span><br><span class="line"><span class="comment">     * This is of course only appropriate if it is acceptable to use</span></span><br><span class="line"><span class="comment">     * the same value for all additions from this view.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mappedValue the mapped value to use for any additions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the set view</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the mappedValue is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> KeySetView&lt;K,V&gt; <span class="title">keySet</span><span class="params">(V mappedValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mappedValue == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KeySetView&lt;K,V&gt;(<span class="keyword">this</span>, mappedValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写数组的拷贝"><a href="#写数组的拷贝" class="headerlink" title="写数组的拷贝"></a>写数组的拷贝</h4><p><code>CopyOnWriteArrayList</code> 和 <code>CopyOnWriteArraySet</code> 是线程安全的集合</p>
<ul>
<li>所有更改器会建立底层数组的一个副本<ul>
<li>如果迭代<strong>访问</strong>集合的线程数超过<strong>更改</strong>集合的线程数，是有用的</li>
<li>迭代器包含当前数组一个引用，数组被修改后，迭代器仍然引用旧的数组</li>
</ul>
</li>
<li>原来的迭代器可以访问一致但可能过时的视图，而且不存在任何同步开销 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="并行数组算法"><a href="#并行数组算法" class="headerlink" title="并行数组算法"></a>并行数组算法</h4><p>Arrays类提供大量并行化操作。</p>
<p><code>Arrays.parallelSort()</code>可对一个基本类型值或对象数组排序。</p>
<p><code>Arrays.parallelPrefix</code> 方法用一个给定结合操作和相应前缀的累加结果替换各个数组元素</p>
<p><code>Arrays.parallelSetAll</code> 方法会用一个函数计算得到的值填充一个数组。这个函数接收元素索引，然后计算相应位置上的值</p>
<h4 id="较早的线程安全集合"><a href="#较早的线程安全集合" class="headerlink" title="较早的线程安全集合"></a>较早的线程安全集合</h4><p><code>Vector</code> 和 <code>Hashtable</code> 类提供了<strong>动态数组</strong>和<strong>散列表</strong>的<strong>线程安全</strong>的实现</p>
<p>但已过时，被 <code>ArrayList</code> 和 <code>HashMap</code> 取代（这两个不是线程安全的）</p>
<p>集合库提供一种机制：<strong>同步包装器（synchronization wrapper）</strong>将<strong>集合类</strong>变成<strong>线程安全</strong>的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; syncArrayList &#x3D; Collections.synchronizedList(new ArrayList&lt;E&gt;());</span><br><span class="line">Map&lt;K, V&gt; synchHashMap &#x3D; Collections.synchronizedMap(new HashMap&lt;K, V&gt;());</span><br></pre></td></tr></table></figure>

<p>通过<strong>同步包装器</strong>，结果集合（例如 <code>syncArrayList </code>和 <code>synchHashMap </code>）的方法使用<strong>锁</strong>加以保护，可以提供线程安全的访问</p>
<p>同时，应该确保<strong>没有任何线程</strong>通过<strong>原始</strong>的<strong>非同步方法</strong>访问数据结构。</p>
<ul>
<li>确保不保存原始对象的任何引用，简单地构造一个集合并立即传递给包装器</li>
</ul>
<p>最好使用 <code>java.util.concurrent</code> 包中定义的集合，而不是同步包装器</p>
<ul>
<li>例外：如果经常更改的数组列表。使用同步的 <code>ArrayList</code> 要胜过 <code>CopyOnWriteArrayList</code></li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>这个是<strong>方法</strong>，不是构造器，不能 <code>new</code></li>
<li>错误代码：<code>List&lt;String&gt; syncArrayList =  new Collections.synchronizedList(new ArrayList&lt;String&gt;());</code></li>
</ul>
<h3 id="任务和线程池"><a href="#任务和线程池" class="headerlink" title="任务和线程池"></a>任务和线程池</h3><p>如果程序中创建了大量的生命期很短的线程，不应该吧把每个任务映射到一个单独线程，而应该使用<strong>线程池</strong>。</p>
<p>原因：构造一个新线程涉及与操作系统的交互，开销较大。</p>
<p>线程池中包含许多准备运行的线程。</p>
<p>为<strong>线程池</strong>提供一个 <code>Runnable</code>，就会有一个线程调用 <code>run</code> 方法。当 <code>run</code> 方法<strong>退出</strong>时，该线程<strong>不会死亡</strong>，而是<strong>留在池</strong>中，为下一个请求提供服务。</p>
<h4 id="Callable和Future"><a href="#Callable和Future" class="headerlink" title="Callable和Future"></a>Callable和Future</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//运行一个将产生结果的的任务</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Runnable</code> 与 <code>Callable</code> </p>
<ul>
<li><code>Runnable</code> 没有参数，也有没返回值的异步方法；<code>Callable</code> 有返回值</li>
<li><code>Runnable</code> 不抛出异常；<code>Callable</code> 可以抛出异常</li>
<li><code>Callable</code> 接口是一个<strong>参数化类型</strong>，只有一个方法 <code>call</code></li>
</ul>
<p> <code>Callable</code>:</p>
<ul>
<li>类型参数是返回值类型<ul>
<li>例如，<code>Callable&lt;Integer&gt;</code> 表示一个最终返回 <code>Integer</code> 对象的<strong>异步计算</strong></li>
</ul>
</li>
<li>可能<strong>返回一个结果</strong>，也可能<strong>抛出异常</strong> </li>
</ul>
<p><code>Future</code>保存异步计算的结果</p>
<p>可以启动一个计算，将Future对象交给某个线程，这个Future对象的所有者在结果计算好之后就可以获取结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试取消这个任务的运行</span></span><br><span class="line">    <span class="comment">//如果任务已经完成或已经取消或由于某些原因而不能取消，则返回false;</span></span><br><span class="line">    <span class="comment">//如果任务还没有开始，然后调用了cancel，则取消该任务就不会执行。</span></span><br><span class="line">    <span class="comment">//如果任务已经开始了，这是需要看mayInterruptIfRunning参数，来决定是否中断该任务</span></span><br><span class="line">    <span class="comment">//在调用cancel后调用isDone会返回true</span></span><br><span class="line">    <span class="comment">//如果cancel方法返回true,则调用isCancel返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在任务完成前被取消，则返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果任务结束，无论是正常完成、中途取消、还是发生异常，都返回true</span></span><br><span class="line">    <span class="comment">//如果任务还在进行，返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CancellationException if the computation was cancelled</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if the computation threw an</span></span><br><span class="line"><span class="comment">     * exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if the current thread was interrupted</span></span><br><span class="line"><span class="comment">     * while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//获取结果，这个方法会阻塞，直到计算完成</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait // 阻塞等待的最长时间，如果时间过来还没计算完，则抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CancellationException if the computation was cancelled</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if the computation threw an</span></span><br><span class="line"><span class="comment">     * exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if the current thread was interrupted</span></span><br><span class="line"><span class="comment">     * while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TimeoutException if the wait timed out</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//阻塞，直到结果可用或超过了指定时间</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>取消</strong>一个<strong>任务</strong>涉及<strong>两个步骤</strong></p>
<ul>
<li>必须找到并中断底层线程<ul>
<li>如果 <code>Future</code> 对象不知道任务在哪个线程执行，则<strong>取消</strong>任务没有任何效果</li>
</ul>
</li>
<li>任务实现（在 call 方法中）必须感知到中断，并放弃它的工作<ul>
<li>如果任务<strong>没有监视</strong>执行该任务的线程的<strong>中断状态</strong>，取消任务没有任何效果</li>
</ul>
</li>
</ul>
</blockquote>
<p>执行 <code>Callable</code> 的一种方法是使用 <code>FutureTask</code>，它实现了 <code>Future</code> 和 <code>Runnable</code> 接口，可以构造一个<strong>线程</strong>来运行这个<strong>任务</strong>。</p>
<ul>
<li>意思是把所要做的任务放在 <code>FutureTask</code> 中，然后创建一个线程，将 <code>FutureTask</code> 放进去来执行 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; task = ...;</span><br><span class="line">FutureTask futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(task);</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(futureTask); <span class="comment">// it&#x27;s Runnable</span></span><br><span class="line">t.start();</span><br><span class="line">...</span><br><span class="line">Integer result = task.get(); <span class="comment">// it&#x27;s Future</span></span><br></pre></td></tr></table></figure>

<p>更常见的做法是，将一个 <code>Callable</code> 传递到一个<strong>执行器</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p><strong>执行器</strong>（Executors）类有许多静态工厂方法，用来<strong>构造线程池</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>newCachedThreadPool</td>
<td>必要时创建新线程；空闲线程会保留60s</td>
</tr>
<tr>
<td>newFixedThreadPool</td>
<td>池中包含固定数目线程；空闲线程一直保留</td>
</tr>
<tr>
<td>newWorkStealingPool</td>
<td>一种适合fork-join任务的线程池，其中复杂任务会分解为更简单任务，空线程会“密取”较简单任务</td>
</tr>
<tr>
<td>newSingleThreadExecutor</td>
<td>只有一个线程的池，顺序执行所提交任务</td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>用于调度执行固定线程池</td>
</tr>
<tr>
<td>newSingleThreadScheduledExecutor</td>
<td>用于调度执行单线程的池</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 池中包含固定数目的线程；空闲线程会一直保留</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一种适合“fork-join”任务的线程池，其中复杂的任务会分解为更简单的任务，空闲线程会密取较简单的任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">            (parallelism,</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a work-stealing thread pool using all</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Runtime#availableProcessors available processors&#125;</span></span><br><span class="line"><span class="comment">     * as its target parallelism level.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #newWorkStealingPool(int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">            (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadFactory用于在需要的时候创建新的线程</span></span><br><span class="line">    <span class="comment">// 最多有nThreads个数量的线程线程处理任务。如果有多余任务在nThreads个线程都在工作时进入，该任务会进入队列直到线程可以利用</span></span><br><span class="line">    <span class="comment">// 如果在shutdown之前，有某个线程由于failure而终止，一个新的线程会取代它并执行剩余工作（如果需要的话）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有一个线程的“池”，会顺序执行所提交的任务</span></span><br><span class="line">    <span class="comment">//注意，如果这个唯一的线程在shutdown之前,在执行的时候，由于failure而终止，会有新的线程代替它并执行剩余工作</span></span><br><span class="line">    <span class="comment">// 与newFixedThreadPool(1)区别在于：newSingleThreadExecutor的线程数保证不能改变</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必要时创建新线程，空闲线程会一致保留60秒</span></span><br><span class="line">    <span class="comment">//该线程适用于有大量短存活时间的异步任务</span></span><br><span class="line">    <span class="comment">//会立即执行各个任务</span></span><br><span class="line">    <span class="comment">// 有空闲线程可用，就使用空闲线程执行任务</span></span><br><span class="line">    <span class="comment">// 没有可用的空闲线程，就创建一个新的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a single-threaded executor that can schedule commands</span></span><br><span class="line"><span class="comment">     * to run after a given delay, or to execute periodically.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 用于调度执行的单线程“池”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, threadFactory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a thread pool that can schedule commands to run after a</span></span><br><span class="line"><span class="comment">     * given delay, or to execute periodically.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//用于调度执行的固定线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a thread pool that can schedule commands to run after a</span></span><br><span class="line"><span class="comment">     * given delay, or to execute periodically.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 用于调度执行的固定线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an object that delegates all defined &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * ExecutorService&#125; methods to the given executor, but not any</span></span><br><span class="line"><span class="comment">     * other methods that might otherwise be accessible using</span></span><br><span class="line"><span class="comment">     * casts. This provides a way to safely &quot;freeze&quot; configuration and</span></span><br><span class="line"><span class="comment">     * disallow tuning of a given concrete implementation.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor the underlying implementation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> ExecutorService&#125; instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if executor null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">unconfigurableExecutorService</span><span class="params">(ExecutorService executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedExecutorService(executor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an object that delegates all defined &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * ScheduledExecutorService&#125; methods to the given executor, but</span></span><br><span class="line"><span class="comment">     * not any other methods that might otherwise be accessible using</span></span><br><span class="line"><span class="comment">     * casts. This provides a way to safely &quot;freeze&quot; configuration and</span></span><br><span class="line"><span class="comment">     * disallow tuning of a given concrete implementation.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor the underlying implementation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> ScheduledExecutorService&#125; instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if executor null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">unconfigurableScheduledExecutorService</span><span class="params">(ScheduledExecutorService executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService(executor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a default thread factory used to create new threads.</span></span><br><span class="line"><span class="comment">     * This factory creates all new threads used by an Executor in the</span></span><br><span class="line"><span class="comment">     * same &#123;<span class="doctag">@link</span> ThreadGroup&#125;. If there is a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * java.lang.SecurityManager&#125;, it uses the group of &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * System#getSecurityManager&#125;, else the group of the thread</span></span><br><span class="line"><span class="comment">     * invoking this &#123;<span class="doctag">@code</span> defaultThreadFactory&#125; method. Each new</span></span><br><span class="line"><span class="comment">     * thread is created as a non-daemon thread with priority set to</span></span><br><span class="line"><span class="comment">     * the smaller of &#123;<span class="doctag">@code</span> Thread.NORM_PRIORITY&#125; and the maximum</span></span><br><span class="line"><span class="comment">     * priority permitted in the thread group.  New threads have names</span></span><br><span class="line"><span class="comment">     * accessible via &#123;<span class="doctag">@link</span> Thread#getName&#125; of</span></span><br><span class="line"><span class="comment">     * &lt;em&gt;pool-N-thread-M&lt;/em&gt;, where &lt;em&gt;N&lt;/em&gt; is the sequence</span></span><br><span class="line"><span class="comment">     * number of this factory, and &lt;em&gt;M&lt;/em&gt; is the sequence number</span></span><br><span class="line"><span class="comment">     * of the thread created by this factory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a thread factory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">defaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a thread factory used to create new threads that</span></span><br><span class="line"><span class="comment">     * have the same permissions as the current thread.</span></span><br><span class="line"><span class="comment">     * This factory creates threads with the same settings as &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Executors#defaultThreadFactory&#125;, additionally setting the</span></span><br><span class="line"><span class="comment">     * AccessControlContext and contextClassLoader of new threads to</span></span><br><span class="line"><span class="comment">     * be the same as the thread invoking this</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> privilegedThreadFactory&#125; method.  A new</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> privilegedThreadFactory&#125; can be created within an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> AccessController#doPrivileged AccessController.doPrivileged&#125;</span></span><br><span class="line"><span class="comment">     * action setting the current thread&#x27;s access control context to</span></span><br><span class="line"><span class="comment">     * create threads with the selected permission settings holding</span></span><br><span class="line"><span class="comment">     * within that action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that while tasks running within such threads will have</span></span><br><span class="line"><span class="comment">     * the same access control and class loader settings as the</span></span><br><span class="line"><span class="comment">     * current thread, they need not have the same &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * java.lang.ThreadLocal&#125; or &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * java.lang.InheritableThreadLocal&#125; values. If necessary,</span></span><br><span class="line"><span class="comment">     * particular values of thread locals can be set or reset before</span></span><br><span class="line"><span class="comment">     * any task runs in &#123;<span class="doctag">@link</span> ThreadPoolExecutor&#125; subclasses using</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ThreadPoolExecutor#beforeExecute(Thread, Runnable)&#125;.</span></span><br><span class="line"><span class="comment">     * Also, if it is necessary to initialize worker threads to have</span></span><br><span class="line"><span class="comment">     * the same InheritableThreadLocal settings as some other</span></span><br><span class="line"><span class="comment">     * designated thread, you can create a custom ThreadFactory in</span></span><br><span class="line"><span class="comment">     * which that thread waits for and services requests to create</span></span><br><span class="line"><span class="comment">     * others that will inherit its values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a thread factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AccessControlException if the current access control</span></span><br><span class="line"><span class="comment">     * context does not have permission to both get and set context</span></span><br><span class="line"><span class="comment">     * class loader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">privilegedThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PrivilegedThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Callable&#125; object that, when</span></span><br><span class="line"><span class="comment">     * called, runs the given task and returns the given result.  This</span></span><br><span class="line"><span class="comment">     * can be useful when applying methods requiring a</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Callable&#125; to an otherwise resultless action.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to run</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result the result to return</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a callable object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if task null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Callable&#125; object that, when</span></span><br><span class="line"><span class="comment">     * called, runs the given task and returns &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to run</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a callable object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if task null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;Object&gt;(task, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Callable&#125; object that, when</span></span><br><span class="line"><span class="comment">     * called, runs the given privileged action and returns its result.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action the privileged action to run</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a callable object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if action null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(<span class="keyword">final</span> PrivilegedAction&lt;?&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> action.run(); &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Callable&#125; object that, when</span></span><br><span class="line"><span class="comment">     * called, runs the given privileged exception action and returns</span></span><br><span class="line"><span class="comment">     * its result.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action the privileged exception action to run</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a callable object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if action null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(<span class="keyword">final</span> PrivilegedExceptionAction&lt;?&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="keyword">return</span> action.run(); &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Callable&#125; object that will, when called,</span></span><br><span class="line"><span class="comment">     * execute the given &#123;<span class="doctag">@code</span> callable&#125; under the current access</span></span><br><span class="line"><span class="comment">     * control context. This method should normally be invoked within</span></span><br><span class="line"><span class="comment">     * an &#123;<span class="doctag">@link</span> AccessController#doPrivileged AccessController.doPrivileged&#125;</span></span><br><span class="line"><span class="comment">     * action to create callables that will, if possible, execute</span></span><br><span class="line"><span class="comment">     * under the selected permission settings holding within that</span></span><br><span class="line"><span class="comment">     * action; or if not possible, throw an associated &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * AccessControlException&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable the underlying task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the callable&#x27;s result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a callable object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if callable null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">privilegedCallable</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PrivilegedCallable&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Callable&#125; object that will, when called,</span></span><br><span class="line"><span class="comment">     * execute the given &#123;<span class="doctag">@code</span> callable&#125; under the current access</span></span><br><span class="line"><span class="comment">     * control context, with the current context class loader as the</span></span><br><span class="line"><span class="comment">     * context class loader. This method should normally be invoked</span></span><br><span class="line"><span class="comment">     * within an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> AccessController#doPrivileged AccessController.doPrivileged&#125;</span></span><br><span class="line"><span class="comment">     * action to create callables that will, if possible, execute</span></span><br><span class="line"><span class="comment">     * under the selected permission settings holding within that</span></span><br><span class="line"><span class="comment">     * action; or if not possible, throw an associated &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * AccessControlException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable the underlying task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the callable&#x27;s result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a callable object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if callable null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AccessControlException if the current access control</span></span><br><span class="line"><span class="comment">     * context does not have permission to both set and get context</span></span><br><span class="line"><span class="comment">     * class loader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">privilegedCallableUsingCurrentClassLoader</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PrivilegedCallableUsingCurrentClassLoader&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Non-public classes supporting the public methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A callable that runs given task and returns given result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Runnable task;</span><br><span class="line">        <span class="keyword">final</span> T result;</span><br><span class="line">        RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            task.run();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A callable that runs under established access control settings</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivilegedCallable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;T&gt; task;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">        PrivilegedCallable(Callable&lt;T&gt; task) &#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.acc = AccessController.getContext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> PrivilegedExceptionAction&lt;T&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> T <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> task.call();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, acc);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A callable that runs under established access control settings and</span></span><br><span class="line"><span class="comment">     * current ClassLoader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivilegedCallableUsingCurrentClassLoader</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;T&gt; task;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader ccl;</span><br><span class="line"></span><br><span class="line">        PrivilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt; task) &#123;</span><br><span class="line">            SecurityManager sm = System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Calls to getContextClassLoader from this class</span></span><br><span class="line">                <span class="comment">// never trigger a security check, but we check</span></span><br><span class="line">                <span class="comment">// whether our callers have this permission anyways.</span></span><br><span class="line">                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Whether setContextClassLoader turns out to be necessary</span></span><br><span class="line">                <span class="comment">// or not, we fail fast if permission is not available.</span></span><br><span class="line">                sm.checkPermission(<span class="keyword">new</span> RuntimePermission(<span class="string">&quot;setContextClassLoader&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.acc = AccessController.getContext();</span><br><span class="line">            <span class="keyword">this</span>.ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> PrivilegedExceptionAction&lt;T&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> T <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            Thread t = Thread.currentThread();</span><br><span class="line">                            ClassLoader cl = t.getContextClassLoader();</span><br><span class="line">                            <span class="keyword">if</span> (ccl == cl) &#123;</span><br><span class="line">                                <span class="keyword">return</span> task.call();</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                t.setContextClassLoader(ccl);</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="keyword">return</span> task.call();</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    t.setContextClassLoader(cl);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, acc);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default thread factory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread factory capturing access control context and class loader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivilegedThreadFactory</span> <span class="keyword">extends</span> <span class="title">DefaultThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader ccl;</span><br><span class="line"></span><br><span class="line">        PrivilegedThreadFactory() &#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            SecurityManager sm = System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Calls to getContextClassLoader from this class</span></span><br><span class="line">                <span class="comment">// never trigger a security check, but we check</span></span><br><span class="line">                <span class="comment">// whether our callers have this permission anyways.</span></span><br><span class="line">                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Fail fast</span></span><br><span class="line">                sm.checkPermission(<span class="keyword">new</span> RuntimePermission(<span class="string">&quot;setContextClassLoader&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.acc = AccessController.getContext();</span><br><span class="line">            <span class="keyword">this</span>.ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.newThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            Thread.currentThread().setContextClassLoader(ccl);</span><br><span class="line">                            r.run();</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, acc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A wrapper class that exposes only the ExecutorService methods</span></span><br><span class="line"><span class="comment">     * of an ExecutorService implementation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService e;</span><br><span class="line">        DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123; e.execute(command); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; e.shutdown(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> e.shutdownNow(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> e.isShutdown(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> e.isTerminated(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.awaitTermination(timeout, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.submit(task);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.submit(task);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.submit(task, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">return</span> e.invokeAll(tasks);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                             <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">return</span> e.invokeAll(tasks, timeout, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.invokeAny(tasks);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.invokeAny(tasks, timeout, unit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizableDelegatedExecutorService</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">DelegatedExecutorService</span> </span>&#123;</span><br><span class="line">        FinalizableDelegatedExecutorService(ExecutorService executor) &#123;</span><br><span class="line">            <span class="keyword">super</span>(executor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A wrapper class that exposes only the ScheduledExecutorService</span></span><br><span class="line"><span class="comment">     * methods of a ScheduledExecutorService implementation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatedScheduledExecutorService</span></span></span><br><span class="line"><span class="class">            <span class="keyword">extends</span> <span class="title">DelegatedExecutorService</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService e;</span><br><span class="line">        DelegatedScheduledExecutorService(ScheduledExecutorService executor) &#123;</span><br><span class="line">            <span class="keyword">super</span>(executor);</span><br><span class="line">            e = executor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.schedule(command, delay, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.schedule(callable, delay, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.scheduleAtFixedRate(command, initialDelay, period, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.scheduleWithFixedDelay(command, initialDelay, delay, unit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cannot instantiate. */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Executors</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果线程的生存期很短，或者大量时间都在阻塞，可以使用一个缓存线程池（<code>newCachedThreadPool</code>，立即执行各任务，使用空线程，没有则创建一个）<ul>
<li>如果线程工作量很大而且并不阻塞，就不要用缓存线程池了，会运行太多的线程</li>
</ul>
</li>
<li>为了得到最优的运行速度，并发线程数等于处理器的内核数，应当使用固定线程池 (<code>newFixedThreadPool</code>)</li>
<li> 单线程执行器（<code>newSingleThreadExecutor</code>）对于性能分析很有帮助</li>
<li>临时用一个单线程池替换缓存或固定线程池，能测量<strong>不使用并发的情况</strong>下应用的<strong>运行速度会慢多少</strong></li>
</ul>
<p><code>newCachedThreadPool</code>、<code>newFixedThreadPool</code> 和 <code>newSingleThreadExecutor</code> 三个方法返回实现了 <code>ExcutorService</code> 接口的 <code>ThreadPoolExecutor</code> 类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &#123;<span class="doctag">@code</span> Executor&#125; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法不会等待正在执行的任务到结束</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//提交一个Callable对象集合中的所有对象</span></span><br><span class="line">    <span class="comment">//这个方法会阻塞，直到所有任务都完成</span></span><br><span class="line">    <span class="comment">//返回表示所有任务答案的一个Future对象列表</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given tasks, returning the result</span></span><br><span class="line"><span class="comment">     * of one that has completed successfully (i.e., without throwing</span></span><br><span class="line"><span class="comment">     * an exception), if any do. Upon normal or exceptional return,</span></span><br><span class="line"><span class="comment">     * tasks that have not completed are cancelled.</span></span><br><span class="line"><span class="comment">     * The results of this method are undefined if the given</span></span><br><span class="line"><span class="comment">     * collection is modified while this operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result returned by one of the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks or any element task</span></span><br><span class="line"><span class="comment">     *         subject to execution is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if tasks is empty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if no task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if tasks cannot be scheduled</span></span><br><span class="line"><span class="comment">     *         for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given tasks, returning the result</span></span><br><span class="line"><span class="comment">     * of one that has completed successfully (i.e., without throwing</span></span><br><span class="line"><span class="comment">     * an exception), if any do before the given timeout elapses.</span></span><br><span class="line"><span class="comment">     * Upon normal or exceptional return, tasks that have not</span></span><br><span class="line"><span class="comment">     * completed are cancelled.</span></span><br><span class="line"><span class="comment">     * The results of this method are undefined if the given</span></span><br><span class="line"><span class="comment">     * collection is modified while this operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result returned by one of the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks, or unit, or any element</span></span><br><span class="line"><span class="comment">     *         task subject to execution is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TimeoutException if the given timeout elapses before</span></span><br><span class="line"><span class="comment">     *         any task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if no task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if tasks cannot be scheduled</span></span><br><span class="line"><span class="comment">     *         for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//返回该执行器生命周期中线程池的最大大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLargestPoolSize</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="comment">///...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 <code>sumbit</code> 方法，将 <code>Runnable</code> 或 <code>Callable</code> 对象提交给 <code>ExecutorService</code>、</p>
<p>调用 <code>sumbit</code> 时，会得到一个 <code>Future</code> 对象，可用来得到结果或取消任务</p>
<p>下面是3个submit</p>
<ul>
<li><p>```<br><T> Future<T> submit(Callable<T> task);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<ul>
<li>返回 <code>Future&lt;?&gt;</code>，可以使用这个对象调用 <code>isDone</code>、<code>cancel</code>、<code>isCancelled</code></li>
<li>但是 <code>get</code> 方法只是简单返回 <code>null</code></li>
</ul>
</li>
<li><p>```<br><T> Future<T> submit(Runnable task, T result);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 对于这个返回的 &#96;Future&#96; 对象，它的 &#96;get&#96; 方法在完成时返回指定的 &#96;result&#96; 对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用完一个**线程池**，调用 &#96;shutdown&#96;。启动线程池关闭序列</span><br><span class="line"></span><br><span class="line">被关闭的执行器不在接受新任务。所欲任务完成是线程池中线程死亡。</span><br><span class="line"></span><br><span class="line">另一种调用&#96;shutdownNow&#96;，线程池会取消所有尚未开始任务</span><br><span class="line"></span><br><span class="line">**总结使用连接池时所做的工作**</span><br><span class="line"></span><br><span class="line">1. 调用 &#96;Executors&#96; 类的静态方法 &#96;newCachedThreadPool&#96; 或 &#96;newFixedThreadPool&#96;</span><br><span class="line">2. 调用 &#96;sumbit&#96; 提交 &#96;Runnable&#96; 或 &#96;Callable&#96; 对象</span><br><span class="line">3. 保存好返回的 &#96;Future&#96; 对象，以便得到结果或者取消任务</span><br><span class="line">4. 当不想再提交任何任务时，调用 &#96;shutdown&#96;</span><br><span class="line"></span><br><span class="line">&gt; 连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的[线程](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;线程&#x2F;103101)使用。</span><br><span class="line"></span><br><span class="line">&#96;Executors&#96; 类中的 &#96;newScheduledThreadPool&#96; 和 &#96;newSingleThreadScheduledExecutor&#96; 方法返回实现 &#96;ScheduledExecutorService&#96; 接口</span><br><span class="line"></span><br><span class="line">- &#96;ScheduledExecutorService&#96; 接口为调度执行或重复执行任务提供一些方法</span><br><span class="line">  - 这是对支持建立线程池的 java.util.Timer 的泛化</span><br><span class="line">  - 可以调度 &#96;Runnable&#96; 或 &#96;Callable&#96; 在一个初始延迟之后运行一次</span><br><span class="line">  - 也可以调度 &#96;Runnable&#96; 定期运行 </span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public interface ScheduledExecutorService extends ExecutorService &#123;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;调度在指定的时间之后执行任务</span><br><span class="line">    public ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                       long delay, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,</span><br><span class="line">                                           long delay, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;调度在初始延迟之后，周期性地运行给定的任务，周期长度时period个单位</span><br><span class="line">    public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  long initialDelay,</span><br><span class="line">                                                  long period,</span><br><span class="line">                                                  TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;调度在初始延迟之后，周期性地运行给定的任务，在一次调用完成和下次调用开始之前有长度为delay个单位的延迟</span><br><span class="line">    public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                     long initialDelay,</span><br><span class="line">                                                     long delay,</span><br><span class="line">                                                     TimeUnit unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatedScheduledExecutorService</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">DelegatedExecutorService</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line">	<span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="控制任务组"><a href="#控制任务组" class="headerlink" title="控制任务组"></a>控制任务组</h4><p>使用执行器原因</p>
<ul>
<li>执行器服务作为线程池来提高任务执行的效率</li>
<li>需要控制一组相关任务<ul>
<li>例如在执行器中使用 <code>shutdownNow</code> 方法取消所有任务 </li>
</ul>
</li>
</ul>
<p><code>invokeAny</code>方法提交一个Callable对象集合中所有对象，并返回某个已完成任务结果，一般是最快完成的那个。</p>
<p><code>invokeAll</code>方法提交后会阻塞，直到所有任务都完成，并返回表示所有任务答案的一个Future对象列表。</p>
<p>以下代码，在第一个 <code>result.get()</code> 调用会阻塞，直到第一个结果可用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Callable&lt;T&gt;&gt; tasks = ...;</span><br><span class="line">List&lt;Future&lt;T&gt;&gt; results = executor.invokeAll(tasks);</span><br><span class="line"><span class="keyword">for</span>(Future&lt;T&gt; result : results)&#123;</span><br><span class="line">    processFuture(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 <code>ExecutorCompletionService</code> 来管理计算结果（顺序输出等）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先获得一个执行器，</span></span><br><span class="line">ExecutorCompletionService&lt;T&gt; service = <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executor);<span class="comment">//然后构造一个ExecutorCompletionService</span></span><br><span class="line"><span class="keyword">for</span>(Callable&lt;T&gt; task : tasks) service.submit(task);<span class="comment">//提交任务</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.size(); i++)</span><br><span class="line">    	processFuture(service.take().get());<span class="comment">//该服务会管理Future对象的一个阻塞队列，包含所提交任务结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCompletionService</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">CompletionService</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractExecutorService aes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue; <span class="comment">//管理Future对象的阻塞队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FutureTask extension to enqueue upon completion</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueingFuture</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">        QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</span><br><span class="line">            <span class="keyword">super</span>(task, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123; completionQueue.add(task); &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;V&gt; task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RunnableFuture&lt;V&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (aes == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;V&gt;(task);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> aes.newTaskFor(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RunnableFuture&lt;V&gt; <span class="title">newTaskFor</span><span class="params">(Runnable task, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (aes == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;V&gt;(task, result);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> aes.newTaskFor(task, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造一个执行器完成服务来收集给定执行器的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorCompletionService</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">        <span class="keyword">this</span>.aes = (executor <span class="keyword">instanceof</span> AbstractExecutorService) ?</span><br><span class="line">            (AbstractExecutorService) executor : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.completionQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Future&lt;V&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorCompletionService</span><span class="params">(Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span> || completionQueue == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">        <span class="keyword">this</span>.aes = (executor <span class="keyword">instanceof</span> AbstractExecutorService) ?</span><br><span class="line">            (AbstractExecutorService) executor : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.completionQueue = completionQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交一个任务给底层的执行器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">submit</span><span class="params">(Callable&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;V&gt; f = newTaskFor(task);</span><br><span class="line">        executor.execute(<span class="keyword">new</span> QueueingFuture(f));</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">submit</span><span class="params">(Runnable task, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;V&gt; f = newTaskFor(task, result);</span><br><span class="line">        executor.execute(<span class="keyword">new</span> QueueingFuture(f));</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除下一个已完成的结果，如果没有可用的已完成结果，则阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> completionQueue.take();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> completionQueue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 移除并返回下一个已完成的结果，如果没有可以用的已完成结果，则返回null，</span></span><br><span class="line">   	<span class="comment">// 这个方法会等待给定的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> completionQueue.poll(timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fork-join-框架"><a href="#fork-join-框架" class="headerlink" title="fork-join 框架"></a>fork-join 框架</h4><p>有的应用使用大量线程，但多数线程空闲。</p>
<p>Java7中引入fork-join框架。</p>
<p>将任务分解成子任务</p>
<p>采用框架可用的一种方式完成这种递归计算</p>
<ul>
<li>需要提供<code>RecursiveTask&lt;T&gt;</code>的类（如果计算生成类型为T的结果）</li>
<li>提供扩展<code>RecursiveAction</code>的类（如不生成任何结果）</li>
</ul>
<p>再覆盖compute方法来生成并调用子任务，然后合并其结果。</p>
<blockquote>
<p>get方法也可获得当前结果，不过一般不是使用，可能抛出检查型异常。compute中不允许抛出检查型异常</p>
</blockquote>
<p>fork-join框架采用<strong>工作密取（work stealing）</strong>平衡可用线程的负载。</p>
<p>每个工作线程都有一个双端队列来完成任务，一个工作线程键子任务压入其双端队列的对头（只有一个线程可以访问队头，无需加锁），一个工作线程空闲时，从队尾密取一个任务。</p>
<h3 id="异步计算"><a href="#异步计算" class="headerlink" title="异步计算"></a>异步计算</h3><h4 id="可完成Future"><a href="#可完成Future" class="headerlink" title="可完成Future"></a>可完成Future</h4><blockquote>
<p>Future调用get获得值，这个方法会阻塞，直到值可用。</p>
</blockquote>
<p><code>CompletableFuture</code>类，提供获得结果的新机制</p>
<p>注册一个<strong>回调recall</strong>，一旦结果可用，就会（在某个线程）利用该结果调用这个回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; f &#x3D; ...;</span><br><span class="line">f.thenAccept(s-&gt;Process the result string s);</span><br></pre></td></tr></table></figure>

<p>通过这种方式，<strong>无需阻塞</strong>就可以在结果可用时对结果进行处理</p>
<ul>
<li><input disabled="" type="checkbox"> 。。。</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>有时需要执行另一个程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Process</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessBuilder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Process类在一个单独的操作系统进程中执行一个命令<ul>
<li>允许与标准输入、输出和错误流交互</li>
</ul>
</li>
<li>ProcessBuilder类允许我们配置 Process对象<ul>
<li>该类可以取代 <code>Runtime.exec</code> 调用，更加灵活</li>
</ul>
</li>
</ul>
<h4 id="建立一个进程"><a href="#建立一个进程" class="headerlink" title="建立一个进程"></a>建立一个进程</h4><p>首先确定想要执行的命令。可以提供一个List<String>,或直接提供命令字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder = <span class="keyword">new</span> ProcessBuilder(<span class="string">&quot;gcc&quot;</span>,<span class="string">&quot;myapp.c&quot;</span>);<span class="comment">//第一个字符串必须是一个可执行命令，而不是一个shell内置命令</span></span><br></pre></td></tr></table></figure>

<p>每个进程都有一个工作目录，用于解析相对目录名。默认进程工作目录与虚拟机相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder = builder.diretory(path.toFile());<span class="comment">//改变工作目录</span></span><br></pre></td></tr></table></figure>

<p>指定进程的标准输入、输出、错误流，默认是管道</p>
<p>使用以下方法访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStream processIn = p.getOutputStream();</span><br><span class="line">InputStream processOut = p.getInputStream();</span><br><span class="line">InputStream processErr = p.getErrorStream();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> 进程的输入流是JVM的一个输出流。与之相反，读取进程输出和错误流内容，对进程来说都是输出流，对我们来说是输入流。</p>
</blockquote>
<p>可以指定新进程的输入、输出、错误流与JVM相同。如果用户在一个控制台运行JVM，所有用户输入都会转发到进程，进程的输出显示在控制台。</p>
<p>可以调用<code>builder.redirectIO()</code>为流建立这个设置。</p>
<p>传入<code>redirectInput、redirectOutput、redirectError</code></p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">builder.redirectInput(inputFile)</span><br><span class="line">.redirectOutput(outPutFile)</span><br><span class="line">.redirectError(errorFile)<span class="comment">//通过提供File对象，将进程流重定向到文件</span></span><br><span class="line"><span class="comment">//进程启动时，会创建或删除输出和错误文件。</span></span><br><span class="line">builder.redirectOutput(ProcessBuilder.Redirect.appendTo(outputfile));<span class="comment">//追加现有文件</span></span><br></pre></td></tr></table></figure>

<p>合并输出、错误流，这样可以按进程生成消息顺序显示输出和错误消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.redirectOutputStream(<span class="keyword">true</span>)<span class="comment">//启用合并，这样之后不能在ProcessBuilder调用redirectError，也不能在Process上调用getErrorStream</span></span><br></pre></td></tr></table></figure>

<p>修改进程环境</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; env = builder.environment();</span><br><span class="line">env.put(<span class="string">&quot;LANG&quot;</span>,<span class="string">&quot;fr_FR&quot;</span>);</span><br><span class="line">env.remove(<span class="string">&quot;JAVA_HOME&quot;</span>);</span><br><span class="line">Process p = builder.start();</span><br></pre></td></tr></table></figure>

<h4 id="运行一个进程"><a href="#运行一个进程" class="headerlink" title="运行一个进程"></a>运行一个进程</h4><p>配置构建器后，调用它的start方法启动进程。</p>
<blockquote>
<p>进程流缓冲空间有限。不能写入太多收入，而且要及时读取输出。大量输入输出可能要在单独线程中生成消费。</p>
</blockquote>
<ul>
<li><p>等待进程完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int result &#x3D; process.waitFor();</span><br></pre></td></tr></table></figure></li>
<li><p>不想无期限等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> delay = ...;</span><br><span class="line"><span class="keyword">if</span>(process.waitFor(delay,TimeUnit.SECONDS))&#123;</span><br><span class="line">	<span class="keyword">int</span> result = process.exitValue();</span><br><span class="line">	...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	process.destoryForcibly();</span><br><span class="line">&#125;<span class="comment">//第一个waitFor调用返回过程的退出值（管理0表示成功，或非0错误码）</span></span><br><span class="line"><span class="comment">//如果进程没有超时，第二个调用返回true然后调用exitValue方法获取退出值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="进程句柄"><a href="#进程句柄" class="headerlink" title="进程句柄"></a>进程句柄</h4><p><code>ProcessHandle</code>接口可以获取一个进程的更多信息。</p>
<p>4中获得ProcessHandle方法</p>
<ul>
<li>给定一个Process 对象 p，<code>p.toHandle()</code>生成它的ProcessHandle</li>
<li>给的一个long 类型操作系统进程ID，<code>ProcessHandle.of(id)</code>,生成这个进程句柄</li>
<li><code>Process.current()</code>是运行这个java虚拟机进程的句柄</li>
<li><code>ProcessHandle.allProcess()</code>。可以生成对当前进程所有可见的操作系统进程是<code>Stream&lt;ProcessHandle&gt;</code></li>
</ul>
<p>给定一个进程句柄，可以得到它的进程ID，父子进程、后代进程</p>
<p>info方法可以生成一个ProcessHandle.Info对象，它提供一些方法获得进程的相关信息。所有这些方法都返回Optional值，因为可能某特定操作系统不能报告这个信息。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://example.com/2021/03/28/%E5%B9%B6%E5%8F%91/" title="并发" target="_blank" rel="external">http://example.com/2021/03/28/%E5%B9%B6%E5%8F%91/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/hs-jose" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/hs-jose" target="_blank"><span class="text-dark">hs</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/28/%E9%9B%86%E5%90%88/" title="集合"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/28/%E9%AB%98%E7%BA%A7%E6%A0%91/" title="高级树"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button">
        <span>[&nbsp;</span><span>Catalogue</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/hs-jose" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>